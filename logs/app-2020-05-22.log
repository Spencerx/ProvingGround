2020.05.22 10:45:46 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 10:45:46 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 10:45:46 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 10:46:13 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 10:46:13 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 10:46:13 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-897240716)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1179944372)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1349890185)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-1470620296)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,774457819)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-1419946672)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:55:44 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 10:55:44 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 10:55:44 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,1349890185)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,774457819)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-897240716)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1470620296)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1419946672)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 11:01:58 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 11:01:58 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 11:01:58 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1179944372)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-1470620296)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-897240716)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1349890185)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1419946672)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,774457819)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:45:54 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 11:45:54 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 11:45:54 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,774457819)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1349890185)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1179944372)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:17:05 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:17:05 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:17:05 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1349890185)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1419946672)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-1470620296)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1179944372)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-897240716)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:41:36 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:41:36 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:41:36 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,774457819)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1349890185)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1470620296)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:44:14 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:44:14 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:44:14 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1179944372)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-1470620296)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:46:00 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:46:00 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:46:00 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-897240716)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,1349890185)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:47:08 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:47:08 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:47:08 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,774457819)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1179944372)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-1470620296)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1349890185)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-897240716)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:49:00 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:49:00 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:49:00 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1470620296)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1179944372)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1349890185)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,774457819)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:55:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:55:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:55:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:57:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:57:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:57:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1179944372)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1419946672)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,774457819)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,-2097001952)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1615518517)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cisat :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cisat)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$cjjjr :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cjjjr)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$chjip :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$chjip)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cjbca :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$cjbca)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$ciguq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ciguq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$chvtl :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$chvtl)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjjhd :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjjhd)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$ckfhg :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckfhg)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$chsqq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$chsqq)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cjuji :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$cjuji)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$ciuxz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ciuxz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cihtr :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cihtr)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (16,1299211175)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckjrf :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckjrf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$clhrr :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clhrr)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$civin :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$civin)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckwmr :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckwmr)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjvvf :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjvvf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjkbm :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjkbm)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_l)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (17,1481277112)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckjvw :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckjvw)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$clkro :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clkro)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ciqgl :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ciqgl)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckycv :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckycv)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjssz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjssz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjeus :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjeus)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_r)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (18,61122141)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dqfrl :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dqfrl)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$dqove :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dqove)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dpmvr :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dpmvr)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dqkjv :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dqkjv)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$dpzpx :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dpzpx)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dptpz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dptpz)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms))),TermState([lemma:((eqM) (e_r)) (e_r) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (19,1838221781)
2020.05.22 12:58:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dqzby :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dqzby)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$driyb :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$driyb)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dqhgb :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dqhgb)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dreio :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dreio)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$dqssn :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dqssn)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dqnfe :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dqnfe)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms))),TermState([lemma:((eqM) (e_l)) (e_l) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:25 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 15:11:25 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 15:11:25 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:40 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 15:11:40 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 15:11:40 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,774457819)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-897240716)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1481277112)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjwyu :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjwyu)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$ckrun :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckrun)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cihww :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cihww)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckhxp :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckhxp)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjjvp :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjjvp)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ciwik :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ciwik)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_r)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (17,1615518517)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (16,1299211175)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckbqk :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckbqk)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$ckwfk :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckwfk)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cimjj :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cimjj)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckmqg :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckmqg)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjoiq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjoiq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjbsq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjbsq)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjyqf :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjyqf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$cktlo :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cktlo)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cijpy :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cijpy)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckjre :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckjre)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjlmq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjlmq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ciykc :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ciykc)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_l)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (18,-2097001952)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cmcrs :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cmcrs)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$cnawj :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cnawj)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckhwz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ckhwz)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cmpdk :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$cmpdk)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cllxp :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cllxp)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckwoa :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ckwoa)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (19,1838221781)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$drujz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$drujz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$dsdvy :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dsdvy)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$drewa :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$drewa)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$drzbh :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$drzbh)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$drony :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$drony)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$drjuf :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$drjuf)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms))),TermState([lemma:((eqM) (e_l)) (e_l) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (20,61122141)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$drltq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$drltq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$druxu :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$druxu)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dqopb :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dqopb)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$drqob :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$drqob)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$drelv :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$drelv)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dqxim :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dqxim)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms))),TermState([lemma:((eqM) (e_r)) (e_r) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)

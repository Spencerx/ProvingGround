2020.05.22 10:45:46 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 10:45:46 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 10:45:46 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 10:46:13 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 10:46:13 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 10:46:13 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-897240716)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1179944372)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1349890185)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-1470620296)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,774457819)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-1419946672)
2020.05.22 10:46:20 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:55:44 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 10:55:44 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 10:55:44 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,1349890185)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,774457819)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-897240716)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1470620296)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1419946672)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 10:55:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 11:01:58 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 11:01:58 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 11:01:58 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1179944372)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-1470620296)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-897240716)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1349890185)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1419946672)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,774457819)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 11:02:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:45:54 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 11:45:54 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 11:45:54 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,774457819)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1349890185)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1179944372)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 11:45:59 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:17:05 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:17:05 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:17:05 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1349890185)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1419946672)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-1470620296)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1179944372)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-897240716)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:17:09 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:41:36 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:41:36 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:41:36 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,774457819)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1349890185)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1470620296)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:41:41 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:44:14 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:44:14 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:44:14 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1179944372)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-1470620296)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:44:18 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:46:00 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:46:00 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:46:00 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-897240716)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,1349890185)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:46:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:47:08 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:47:08 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:47:08 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,774457819)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1179944372)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,-1470620296)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1349890185)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-897240716)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:47:12 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:49:00 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:49:00 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:49:00 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1470620296)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1179944372)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-1419946672)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1349890185)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,774457819)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:49:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:55:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:55:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:55:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,774457819)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 12:55:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:57:07 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 12:57:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 12:57:07 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1179944372)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1419946672)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,774457819)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 12:57:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,-2097001952)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1615518517)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cisat :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cisat)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$cjjjr :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cjjjr)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$chjip :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$chjip)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cjbca :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$cjbca)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$ciguq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ciguq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$chvtl :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$chvtl)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjjhd :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjjhd)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$ckfhg :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckfhg)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$chsqq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$chsqq)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cjuji :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$cjuji)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$ciuxz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ciuxz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cihtr :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cihtr)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (16,1299211175)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckjrf :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckjrf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$clhrr :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clhrr)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$civin :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$civin)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckwmr :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckwmr)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjvvf :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjvvf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjkbm :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjkbm)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_l)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (17,1481277112)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckjvw :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckjvw)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$clkro :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clkro)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ciqgl :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ciqgl)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckycv :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckycv)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjssz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjssz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjeus :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjeus)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_r)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (18,61122141)
2020.05.22 12:58:03 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dqfrl :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dqfrl)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$dqove :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dqove)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dpmvr :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dpmvr)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dqkjv :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dqkjv)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$dpzpx :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dpzpx)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dptpz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dptpz)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms))),TermState([lemma:((eqM) (e_r)) (e_r) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 12:58:04 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 12:58:04 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (19,1838221781)
2020.05.22 12:58:04 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dqzby :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dqzby)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$driyb :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$driyb)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dqhgb :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dqhgb)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dreio :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dreio)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$dqssn :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dqssn)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dqnfe :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dqnfe)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms))),TermState([lemma:((eqM) (e_l)) (e_l) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:25 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 15:11:25 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 15:11:25 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:40 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 15:11:40 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 15:11:40 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,774457819)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1349890185)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-897240716)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 15:11:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1481277112)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjwyu :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjwyu)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$ckrun :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckrun)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cihww :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cihww)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckhxp :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckhxp)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjjvp :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjjvp)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ciwik :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ciwik)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_r)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (17,1615518517)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (16,1299211175)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckbqk :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckbqk)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$ckwfk :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckwfk)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cimjj :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cimjj)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckmqg :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckmqg)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjoiq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjoiq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjbsq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjbsq)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjyqf :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjyqf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$cktlo :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cktlo)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cijpy :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cijpy)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckjre :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckjre)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjlmq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjlmq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ciykc :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ciykc)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_l)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (18,-2097001952)
2020.05.22 15:11:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cmcrs :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cmcrs)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$cnawj :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cnawj)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckhwz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ckhwz)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cmpdk :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$cmpdk)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cllxp :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cllxp)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckwoa :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ckwoa)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (19,1838221781)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$drujz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$drujz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$dsdvy :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dsdvy)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$drewa :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$drewa)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$drzbh :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$drzbh)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$drony :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$drony)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$drjuf :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$drjuf)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms))),TermState([lemma:((eqM) (e_l)) (e_l) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (20,61122141)
2020.05.22 15:11:51 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$drltq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$drltq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$druxu :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$druxu)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dqopb :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dqopb)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$drqob :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$drqob)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$drelv :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$drelv)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dqxim :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dqxim)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms))),TermState([lemma:((eqM) (e_r)) (e_r) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:39:11 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 17:39:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 17:39:11 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1349890185)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,1179944372)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,774457819)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1470620296)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 17:39:24 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,-2097001952)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjztp :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjztp)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$ckrrq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckrrq)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ciskq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ciskq)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckjht :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckjht)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjoqo :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjoqo)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjefl :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjefl)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (16,1615518517)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckaff :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckaff)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$ckwtf :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckwtf)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cijzn :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cijzn)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckmeu :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckmeu)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjmcf :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjmcf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ciyvs :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ciyvs)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (17,1481277112)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1299211175)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjqnf :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cjqnf)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$ckmtn :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$ckmtn)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ciaul :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ciaul)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckbvy :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckbvy)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjcxj :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjcxj)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cipib :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cipib)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_l)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckjll :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckjll)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$clhgh :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clhgh)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ciryz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ciryz)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckurx :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckurx)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjwpq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjwpq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjhxq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjhxq)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_r)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (18,1838221781)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dqabl :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dqabl)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$dqicz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dqicz)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dpftq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dpftq)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dqehb :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dqehb)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$dputu :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dputu)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dpopg :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dpopg)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms))),TermState([lemma:((eqM) (e_l)) (e_l) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (19,61122141)
2020.05.22 17:39:30 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$druaj :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$druaj)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$dsglf :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dsglf)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dqygj :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dqygj)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dsaqy :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dsaqy)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$drmvl :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$drmvl)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$drfyg :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$drfyg)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms))),TermState([lemma:((eqM) (e_r)) (e_r) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (21,-1947019198)
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (20,-567661294)
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (22,-841318884)
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:40:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (23,1591302876)
2020.05.22 17:40:30 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:40:30 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (24,2073475022)
2020.05.22 17:40:30 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:40:30 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (25,-1023996419)
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,1122475947)
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (29,-1218353307)
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (29,634599903)
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (31,-1767243359)
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (29,1528679509)
2020.05.22 17:42:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,508716104)
2020.05.22 17:50:21 [INFO] provingground.learning.HoTTBot.$anonfun:75:20 - Vector((((eqM) (e_l)) (e_r),1.0,[(((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (((mul) (e_l)) (e_r))) (e_r)) (lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)))) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) : 0.001024170092306373]))
2020.05.22 17:55:37 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 17:55:37 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 17:55:37 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,-897240716)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,1179944372)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,-1419946672)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,1349890185)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1470620296)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,774457819)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,-2097001952)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckaeb :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckaeb)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$cksqz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cksqz)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cioxc :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cioxc)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckjsl :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckjsl)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjnsm :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjnsm)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjbwu :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjbwu)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (16,1615518517)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckngl :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckngl)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$cljga :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cljga)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cithn :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cithn)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckynt :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckynt)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjydd :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjydd)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjjjn :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjjjn)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (17,1481277112)
2020.05.22 17:55:42 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cllte :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$cllte)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$cmiro :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cmiro)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cjucb :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cjucb)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$clxnm :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$clxnm)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$ckxct :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ckxct)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckjij :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$ckjij)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_r)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (18,1299211175)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckqor :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckqor)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$clotk :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clotk)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$citvh :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$citvh)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$clctt :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$clctt)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$ckaoz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ckaoz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjkzy :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjkzy)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_l)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (19,1838221781)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dspda :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dspda)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$dsymh :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dsymh)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$drwnk :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$drwnk)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dstzb :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dstzb)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$dsilv :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dsilv)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dscnp :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dscnp)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms))),TermState([lemma:((eqM) (e_l)) (e_l) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (20,61122141)
2020.05.22 17:55:43 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$drrah :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$drrah)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$dsaca :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dsaca)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dqyep :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dqyep)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$drvuk :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$drvuk)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$drlbq :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$drlbq)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$drezj :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$drezj)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms))),TermState([lemma:((eqM) (e_r)) (e_r) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (21,-789544750)
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (22,-1645551407)
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (23,2040525956)
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:55:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (24,-1800305335)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (25,-599115809)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (26,-635849561)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,-2020288530)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,-1871900621)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,700937163)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (29,-2133912413)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,-1108485285)
2020.05.22 17:55:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (29,-383201582)
2020.05.22 17:55:46 [INFO] provingground.learning.HoTTBot.$anonfun:75:20 - Success: Vector((((eqM) (e_l)) (e_r),1.0,[(((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (((mul) (e_l)) (e_r))) (e_r)) (lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)))) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) : 0.001024170092306373]))
2020.05.22 18:00:44 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalProver]
2020.05.22 18:00:44 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (1,-1349507052)
2020.05.22 18:00:44 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalProver(TermState([eqM : 0.2857142857142857, mul : 0.2857142857142857, e_l : 0.047619047619047616, e_r : 0.047619047619047616, mul : 0.047619047619047616, eqM : 0.047619047619047616, axiom_{eqM(a)(a)} : 0.047619047619047616, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.047619047619047616, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.047619047619047616, axiom_{eqM(mul(e_l)(a))(a)} : 0.047619047619047616, axiom_{eqM(mul(a)(e_r))(a)} : 0.047619047619047616],[(M) → ((M) → (𝒰 _0)) : 0.2857142857142857, (M) → ((M) → (M)) : 0.2857142857142857, M : 0.047619047619047616, M : 0.047619047619047616, (M) → ((M) → (M)) : 0.047619047619047616, (M) → ((M) → (𝒰 _0)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.047619047619047616, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.047619047619047616, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.047619047619047616],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (2,1419581202)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Lemmas(Vector((((eqM) (e_r)) (e_r),None,0.0027509184472828325), (((eqM) (e_l)) (e_l),None,0.0027509184472828325), (((eqM) (e_l)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_l)) (((mul) (e_l)) (e_l)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_l)) (e_r)),None,0.0012526844961492322), (((eqM) (e_r)) (((mul) (e_r)) (e_r)),None,0.0012526844961492322)))
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (3,-397054148)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.Weight]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (5,-1403795547)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (7,-1403795547)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (8,-1403795547)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (4,-397054148)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (6,-1403795547)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (10,-897240716)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.26167884451748746)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - Weight(0.1191605777412563)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (e_r),None)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (9,774457819)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (12,1349890185)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (13,-1470620296)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.HoTTMessages.UseLemma]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (11,-1419946672)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_l)),None)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (e_l),None)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_l)) (((mul) (e_l)) (e_r)),None)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_l)) (e_r)),None)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (14,1179944372)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - UseLemma(((eqM) (e_r)) (((mul) (e_r)) (e_r)),None)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1615518517)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1299211175)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckpfo :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckpfo)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$clkmu :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clkmu)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ciywv :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$ciywv)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$clajj :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$clajj)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$ckblz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ckblz)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjood :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjood)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (16,-2097001952)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckjge :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckjge)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$clfzf :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clfzf)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cioxn :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cioxn)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckutc :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckutc)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjuuo :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjuuo)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjgeb :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjgeb)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_l)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (15,1481277112)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$ckkxu :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$ckkxu)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$clghd :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$clghd)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$citza :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$citza)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$ckvur :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$ckvur)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$cjxgh :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$cjxgh)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cjkbz :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cjkbz)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 18:00:49 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$clfxg :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$clfxg)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$cmcnn :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$cmcnn)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$cjqyv :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$cjqyv)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$clquk :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$clquk)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$ckrvs :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$ckrvs)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$cketl :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$cketl)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms))),TermState([lemma:((eqM) (e_r)) (((mul) (e_r)) (e_r)) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),8.392037190113217E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (17,1838221781)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dtrzj :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dtrzj)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$dtzru :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dtzru)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dtbez :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dtbez)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dtvxj :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dtvxj)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$dtmom :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dtmom)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dthbu :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dthbu)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms))),TermState([lemma:((eqM) (e_l)) (e_l) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:243:22 - posted TypeTag[provingground.learning.LocalTangentProver]
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - (18,61122141)
2020.05.22 18:00:50 [INFO] provingground.learning.PostBuffer.$anon.post:245:22 - LocalTangentProver(TermState([mul : 0.2671305532353558, eqM : 0.2671305532353558, axiom_{(eqM(a)(b) \to eqM(b)(a))} : 0.038161507605050826, axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} : 0.038161507605050826, axiom_{eqM(mul(e_l)(a))(a)} : 0.038161507605050826, axiom_{eqM(mul(a)(e_r))(a)} : 0.038161507605050826, e_l : 0.038161507605050826, axiom_{eqM(a)(a)} : 0.038161507605050826, e_r : 0.038161507605050826, (mul) (e_r) : 0.029639086093165203, (eqM) (e_r) : 0.029639086093165203, (mul) (e_l) : 0.029639086093165203, (eqM) (e_l) : 0.029639086093165203, ((mul) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_r)) (e_r) : 0.004713805544950942, ((eqM) (e_r)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_l) : 0.004713805544950942, ((eqM) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_r) : 0.004713805544950942, ((mul) (e_l)) (e_l) : 0.004713805544950942, ((mul) (e_r)) (e_r) : 0.004713805544950942, (axiom_{eqM(mul(a)(e_r))(a)}) (e_r) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_r) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) : 0.004234155156166457, (axiom_{eqM(mul(e_l)(a))(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(a)(a)}) (e_l) : 0.004234155156166457, (axiom_{eqM(mul(a)(e_r))(a)}) (e_l) : 0.004234155156166457, (axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) : 0.004234155156166457],[(M) → ((M) → (M)) : 0.26666666666666666, (M) → ((M) → (𝒰 _0)) : 0.26666666666666666, M : 0.0761904761904762, ((eqM) (e_r)) (e_r) : 0.05, ((eqM) (e_r)) (e_l) : 0.05, ((eqM) (e_l)) (e_l) : 0.05, ((eqM) (e_l)) (e_r) : 0.05, (`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) : 0.0380952380952381, (`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) : 0.0380952380952381, (`a : M ) ~> (((eqM) (`a)) (`a)) : 0.0380952380952381, (`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) : 0.0380952380952381],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),Set((P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_r)) ∈ Funcs) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_l))) (e_l)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dtjkm :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_l))) (e_l)) (`$dtjkm)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_r) ∈ Typs), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs)), (P₁((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((((eqM) (`a)) (`b)) → (((eqM) (`b)) (`a)))) ∈ Typs)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) ∈ Funcs), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) (e_l)) ((axiom_{eqM(a)(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(mul ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(mul ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(M ∈ Typs) =) (Coeff(Init(Typs))) * (P₀(M ∈ Typs)), (P₁((M) → ((M) → (𝒰 _0)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (𝒰 _0)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(eqM ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(eqM ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_l)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(a)(e_r))(a)} ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (`a)) (e_r))) (`a)) ∈ Typs)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(eqM) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(eqM) ∈ Funcs)), (P₁((`$dtsqs :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_l)) (`$dtsqs)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((mul) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(e_r ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ Funcs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs) =) (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))} ∈ Terms)), (P₁(((mul) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies) =) (P₁((eqM) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((mul) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_r)) (e_l) ∈ Typs), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_r)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypFamilyOpt)})), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{(eqM(a)(b) \to eqM(b)(a))} ∈ Terms)), (P₁({Terms ∈ Restrict(TypOpt)}) =) P₁(((eqM) (e_l)) (e_l) ∈ Typs), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_r ∈ Terms)), (P₁(Wrap((mul) (e_r)) ∈ Funcs) =) (P₁((mul) (e_r) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁(axiom_{eqM(a)(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(a)(a)} ∈ Terms)), (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(e_l ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (`a)) (`a)) ∈ Typs)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dsrsx :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_r)) (e_r))) (e_r)) (`$dsrsx)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((mul) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil)) =) (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(((eqM) (e_l)) (e_l) ∈ Typs) =) (P₁(((eqM) (e_l)) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)})), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> (((eqM) (((mul) (e_l)) (`a))) (`a)) ∈ Typs)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((M) → ((M) → (M)) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((M) → ((M) → (M)) ∈ Typs)), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(Wrap(mul) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(mul) ∈ Funcs)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ Funcs), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_l)) (e_r))) (e_r)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((`$dtnwh :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (e_l)) (`$dtnwh)) ((axiom_{eqM(a)(a)}) (e_l))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms) =) (Coeff(Init(Terms))) * (P₀(axiom_{eqM(mul(e_l)(a))(a)} ∈ Terms)), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_l)) ∈ TypFamilies), (P₁((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs) =) (Coeff(Init(Typs))) * (P₀((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))) ∈ Typs)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms)), (P₁((`$dtdqw :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (((mul) (e_l)) (e_r))) (e_r)) (`$dtdqw)) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((eqM) (e_l)) ∈ Funcs) =) (P₁((eqM) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_l)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),Typs,Restrict(TypOpt)))) * (P₁(Wrap((eqM) (e_l)) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(TypFamilyOpt)}) =) P₁(Wrap((eqM) (e_r)) ∈ TypFamilies), (P₁(Wrap(eqM) ∈ TypFamilies) =) (Coeff(Init(TypFamilies))) * (P₀(Wrap(eqM) ∈ TypFamilies)), (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) ∈ Funcs), (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs) =) (Coeff(Init(Funcs))) * (P₀(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs)), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (((mul) (e_r)) (e_r))) (e_r)) ((axiom_{eqM(mul(a)(e_r))(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_r) ∈ Terms)), (P₁((mul) (e_r) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(Wrap((mul) (e_l)) ∈ Funcs) =) (P₁((mul) (e_l) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)})), (P₁((axiom_{eqM(mul(a)(e_r))(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(mul(a)(e_r))(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,TypFamilies,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap(eqM) ∈ TypFamilies))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁(((eqM) (e_l)) (e_r) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_r ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((mul) (e_r)) ∈ Funcs), (P₁(((eqM) (e_l)) (e_l) ∈ Terms) =) ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((eqM) (e_l)) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((mul) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((`$dsyab :  M) ↦ (((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_r)) (e_r)) (`$dsyab)) ((axiom_{eqM(a)(a)}) (e_r))) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((eqM) (e_r)) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) ∈ Funcs), (P₁((eqM) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((axiom_{eqM(mul(e_l)(a))(a)}) (e_r) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{eqM(mul(e_l)(a))(a)}) ∈ Funcs))) * (P₁(e_r ∈ Terms)), (P₁({Terms ∈ Restrict(FuncOpt)}) =) P₁(Wrap((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_l)) ∈ Funcs), (P₁((axiom_{eqM(a)(a)}) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms),Funcs,Restrict(FuncOpt)))) * (P₁(Wrap(axiom_{eqM(a)(a)}) ∈ Funcs))) * (P₁(e_l ∈ Terms)), (P₁((eqM) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms),AtCoord(TermsWithTyp,M :: HNil),Filter(WithTyp(typ))))) * (P₁(Wrap(eqM) ∈ Funcs))) * (P₁(e_l ∈ AtCoord(TermsWithTyp,M :: HNil))), (P₁((((axiom_{(eqM(a)(b) \to eqM(b)(a))}) (e_r)) (e_r)) ((axiom_{eqM(a)(a)}) (e_r)) ∈ Terms) =) ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(axiom_{(eqM(a)(b) \to eqM(b)(a))}) ∈ Funcs))) * (P₁((axiom_{eqM(a)(a)}) (e_r) ∈ Terms)), (P₁(((eqM) (e_r)) (e_l) ∈ Terms) =) ((Coeff(BaseThenCondition(ZipMapOpt(UnifApplnOpt,TypFamilies,Terms,Terms),TypFamilies,Restrict(TypFamilyOpt)))) * (P₁(Wrap((eqM) (e_r)) ∈ TypFamilies))) * (P₁(e_l ∈ Terms))),TermState([lemma:((eqM) (e_r)) (e_r) : 1.0],[],Vector(),[],[((eqM) (e_l)) (e_r) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),3.821478201051794E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0)
2020.05.22 18:00:50 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 18:00:51 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 18:00:50 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (19,-882146633)
2020.05.22 18:00:51 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (20,1943774896)
2020.05.22 18:00:51 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 18:00:51 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (21,-1058594355)
2020.05.22 18:00:51 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 18:00:51 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (22,1544283379)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (23,-1699185398)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.TermData.TermResult]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (24,282002186)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - posted TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,1556203222)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (27,-1019977704)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,-1534969617)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (30,1853727301)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (27,1530413512)
2020.05.22 18:00:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:86:22 - (27,-1352424661)
2020.05.22 18:00:53 [INFO] provingground.learning.HoTTBot.$anonfun:75:20 - Success: Vector((((eqM) (e_l)) (e_r),1.0,[(((((axiom_{(eqM(a)(b) \to (eqM(b)(c) \to eqM(a)(c)))}) (e_l)) (((mul) (e_l)) (e_r))) (e_r)) (lemma:((eqM) (e_l)) (((mul) (e_l)) (e_r)))) ((axiom_{eqM(mul(e_l)(a))(a)}) (e_r)) : 0.001024170092306373]))

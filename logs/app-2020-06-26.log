2020.06.26 06:45:31 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TautologyInitState], id: (1,-384837536), content:
TautologyInitState(TermState([m : 0.14285714285714285, sym : 0.14285714285714285, ((mul) (m)) (n) : 0.14285714285714285, refl : 0.14285714285714285, mul : 0.14285714285714285, n : 0.14285714285714285, trans : 0.14285714285714285],[M : 1.0],Vector(),[],[],Empty))
2020.06.26 06:45:31 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (2,1588327529), content:
SpecialInitState(TermState([trans : 0.9, sym : 0.1],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.05,Some(TermGenParams(0.0,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.26 06:45:31 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (3,246182078), content:
SpecialInitState(TermState([left-multiply : 0.2, right-multiply : 0.2, ((mul) (m)) (n) : 0.2, m : 0.2, n : 0.2],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.5,Some(TermGenParams(0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.26 06:45:31 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.LocalProver], id: (4,582823858), content:
LocalProver(TermState([m : 0.08333333333333333, left-multiply : 0.08333333333333333, eqM : 0.08333333333333333, mul : 0.08333333333333333, n : 0.08333333333333333, trans : 0.08333333333333333, sym : 0.08333333333333333, ass1 : 0.08333333333333333, right-multiply : 0.08333333333333333, ass2 : 0.08333333333333333, refl : 0.08333333333333333, ((mul) (m)) (n) : 0.08333333333333333],[M : 1.0],Vector(),[],[((eqM) (((mul) (m)) (n))) (((mul) (n)) (m)) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0,Some(500000))
2020.06.26 06:45:31 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.LocalProver]
2020.06.26 06:45:46 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (5,447984253), content:
provingground.learning.ExpressionEval$$anon$2@1ab3b27d
2020.06.26 06:45:46 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 06:45:47 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 06:45:47 [INFO] provingground.learning.HoTTBot.expEvToFinalState:474:26 - computing final state
2020.06.26 06:45:47 [INFO] provingground.learning.ExprCalc.stableVec:643:46 - completed 2 steps
2020.06.26 06:45:48 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (6,-1664112044)
2020.06.26 06:45:48 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 06:45:48 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 06:45:48 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 06:45:50 [INFO] provingground.learning.HoTTBot.$anonfun:378:26 - Results: 3
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.666676177661691E-4; statement weight 4.922526522818089E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.6875890673843706E-4; statement weight 3.283350224245018E-7
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.6875890673843706E-4; statement weight 2.901648730630753E-7
2020.06.26 06:45:51 [INFO] provingground.learning.ExprCalc.stableVec:643:46 - completed 2 steps
2020.06.26 06:45:51 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (7,1645406931)
2020.06.26 06:45:51 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.26 06:45:51 [INFO] provingground.learning.HoTTBot.$anonfun:904:24 - excluded lemmas:

2020.06.26 06:45:52 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (8,-1445828818)
2020.06.26 06:45:52 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (9,-962844701)
2020.06.26 06:45:52 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (10,1833728595)
2020.06.26 06:45:52 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 06:45:54 [INFO] provingground.learning.ExprCalc.stableVec:643:46 - completed 2 steps
2020.06.26 06:45:55 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (11,368099790)
2020.06.26 06:45:55 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 06:45:56 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.26 06:45:56 [INFO] provingground.learning.HoTTBot.$anonfun:1011:22 - previous special init states are 2
2020.06.26 06:45:56 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.26 06:45:57 [INFO] provingground.learning.ExprCalc.stableVec:643:46 - completed 2 steps
2020.06.26 06:45:56 [INFO] provingground.learning.ExprCalc.stableVec:643:46 - completed 2 steps
2020.06.26 06:45:58 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (12,412426767)
2020.06.26 06:45:58 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.26 06:45:58 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (13,-2086306360)
2020.06.26 06:45:58 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.26 06:45:58 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (14,-1666923435), content:
TangentBaseCompleted
2020.06.26 06:45:58 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.26 06:45:58 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.26 06:45:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 06:45:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 06:45:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 06:45:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 06:46:00 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 06:46:00 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 06:46:02 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 06:46:02 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 06:46:02 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 4.0E-5
2020.06.26 06:46:03 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 06:46:04 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.26 06:46:05 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.26 06:46:07 [INFO] provingground.learning.HoTTBot.$anonfun:1207:26 - generating equations with 3 base states and 18 lemmas (before pruning)
2020.06.26 06:46:07 [INFO] provingground.learning.HoTTBot.$anonfun:1215:26 - Tangent lemmas (used with bases below): 3
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.040700000848968604)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),0.001214698356305945)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),0.001114032298292804)
2020.06.26 06:46:07 [INFO] provingground.learning.HoTTBot.$anonfun:1229:28 - Terms in base (used with tangents above): 3
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.053326178457998585
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.002437424090839206
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.002437424090839206
2020.06.26 06:46:07 [INFO] provingground.learning.HoTTBot.$anonfun:1241:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.050046293108537594
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.011126917673166644
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.010695179485308265
2020.06.26 06:46:07 [INFO] provingground.learning.HoTTBot.$anonfun:1248:28 - Inference by unified applications, triples and weights (for this base state)
(0.053326178457998585, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.040700000848968604, 9.920316256645221E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 06:46:07 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.26 06:46:08 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.26 06:46:08 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 1.6000000000000004E-6
2020.06.26 06:46:11 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 3.2000000000000006E-7; running again
2020.06.26 06:46:14 [INFO] provingground.learning.HoTTBot.$anonfun:1267:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.053326178457998585

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap((mul) (m)) ∈ Funcs))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.002437424090839206
P₁(((mul) (m)) (n) ∈ Terms) -> 0.053326178457998585
P₁((mul) (m) ∈ Terms) -> 0.001286599861208855
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(n ∈ Terms) -> 0.053326178457998585
P₁(left-multiply ∈ Terms) -> 0.053326178457998585

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.002437424090839206
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(right-multiply ∈ Terms) -> 0.053326178457998585


2020.06.26 06:46:14 [INFO] provingground.learning.HoTTBot.$anonfun:1229:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.016270597645731934
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.016270597645731934
2020.06.26 06:46:14 [INFO] provingground.learning.HoTTBot.$anonfun:1241:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.08055093331491427
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.017883196935657784
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.01723230794846274
2020.06.26 06:46:14 [INFO] provingground.learning.HoTTBot.$anonfun:1248:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.040700000848968604, 6.622133379945163E-4) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 06:46:14 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 6.400000000000002E-8; running again
2020.06.26 06:46:14 [INFO] provingground.learning.HoTTBot.$anonfun:1267:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.016270597645731934
P₁(((mul) (m)) (n) ∈ Terms) -> 0.08837517523251155
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(n ∈ Terms) -> 0.08837517523251155
P₁(left-multiply ∈ Terms) -> 0.08837517523251155

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.016270597645731934
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(right-multiply ∈ Terms) -> 0.08837517523251155


2020.06.26 06:46:14 [INFO] provingground.learning.HoTTBot.$anonfun:1229:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.45000000000000007
2020.06.26 06:46:14 [INFO] provingground.learning.HoTTBot.$anonfun:1241:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.09114656135389602
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0202355433962171
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.019499036808838258
2020.06.26 06:46:14 [INFO] provingground.learning.HoTTBot.$anonfun:1248:28 - Inference by unified applications, triples and weights (for this base state)
(0.45000000000000007, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.040700000848968604, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 06:46:17 [INFO] provingground.learning.HoTTBot.$anonfun:1267:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.45000000000000007

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.26 06:46:17 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 1.2800000000000004E-8; running again
2020.06.26 06:46:19 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.5600000000000007E-9; running again
2020.06.26 06:46:21 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 5.120000000000001E-10; running again
2020.06.26 06:46:23 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 1.0240000000000002E-10; running again
2020.06.26 06:46:25 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0480000000000003E-11; running again
2020.06.26 06:46:25 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 2.0480000000000003E-11
2020.06.26 06:46:27 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,767292983)
2020.06.26 06:46:27 [INFO] provingground.learning.HoTTBot.scribeLog:1942:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,767292983)
2020.06.26 06:46:27 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.26 06:46:27 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.26 06:47:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,372168707), content:
provingground.learning.ExpressionEval$$anon$2@162ed803
2020.06.26 06:47:07 [INFO] provingground.learning.HoTTBot.scribeLog:1942:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,372168707)
2020.06.26 06:47:07 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 06:47:07 [INFO] provingground.learning.HoTTBot.expEvToFinalState:474:26 - computing final state
2020.06.26 06:47:07 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 06:47:09 [INFO] provingground.learning.ExprCalc.stableVec:643:46 - completed 2 steps
2020.06.26 06:47:12 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,209762951)
2020.06.26 06:47:12 [INFO] provingground.learning.HoTTBot.scribeLog:1942:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,209762951)
2020.06.26 06:47:13 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 06:47:13 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 06:47:13 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 06:47:13 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 06:47:35 [INFO] provingground.learning.ExprCalc.stableVec:643:46 - completed 2 steps
2020.06.26 06:47:53 [INFO] provingground.learning.HoTTBot.$anonfun:378:26 - Results: 5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.565980368125865E-4; statement weight 1.871203887165631E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.5757607259762927E-4; statement weight 6.015493085387075E-8
Lemma: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best proof: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 3.6357335767957786E-6; statement weight 6.143877824764005E-8
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best proof: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 1.5966674388756185E-7; statement weight 2.2332562602499821E-10
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.5757607259762927E-4; statement weight 5.2078036146675147E-8
2020.06.26 06:47:59 [INFO] provingground.learning.HoTTBot.$anonfun:378:26 - Steps (in final state): 3
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best proof: trans with weight 0.05649437698358171; statement weight 5.944062904839253E-12
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best proof: (left-multiply) (((mul) (m)) (n)) with weight 0.005971859364160798; statement weight 4.561625690383875E-13
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best proof: (right-multiply) (m) with weight 0.005949184168104393; statement weight 4.5358737659944094E-13
2020.06.26 06:48:04 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-1173733910)
2020.06.26 06:48:04 [INFO] provingground.learning.HoTTBot.scribeLog:1942:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-1173733910)
2020.06.26 06:48:04 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.26 06:48:04 [INFO] provingground.learning.HoTTBot.$anonfun:904:24 - excluded lemmas:

2020.06.26 06:48:04 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (19,-334754299)
2020.06.26 06:48:04 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (20,-1514984774)
2020.06.26 06:48:04 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,1200301437)
2020.06.26 06:48:04 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 06:48:04 [INFO] provingground.learning.HoTTBot.scribeLog:1942:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,1200301437)
2020.06.26 06:48:23 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.26 06:48:23 [INFO] provingground.learning.HoTTBot.$anonfun:1011:22 - previous special init states are 2
2020.06.26 06:48:23 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.26 06:53:20 [INFO] provingground.learning.ExprCalc.stableVec:643:46 - completed 2 steps
2020.06.26 06:53:20 [INFO] provingground.learning.ExprCalc.stableVec:643:46 - completed 2 steps
2020.06.26 06:53:48 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (22,-450463441)
2020.06.26 06:53:48 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.26 06:53:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (23,1526556128)
2020.06.26 06:53:53 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.26 06:53:53 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435), content:
TangentBaseCompleted
2020.06.26 06:53:53 [INFO] provingground.learning.HoTTBot.scribeLog:1942:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435)
2020.06.26 06:53:53 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.26 06:53:53 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.26 06:53:55 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 06:53:55 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 06:53:56 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 06:53:56 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 06:53:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 06:53:59 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 06:54:01 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.26 06:54:06 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 6, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.26 06:54:08 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 6, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.26 06:54:15 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 9, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.26 06:54:17 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 9, less than the time limit 2 minutes, with cutoff 3.2000000000000006E-7; running again
2020.06.26 06:54:28 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 12, less than the time limit 2 minutes, with cutoff 3.2000000000000006E-7; running again
2020.06.26 06:54:31 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 13, less than the time limit 2 minutes, with cutoff 6.400000000000002E-8; running again
2020.06.26 06:54:44 [INFO] provingground.learning.HoTTBot.$anonfun:1207:26 - generating equations with 2 base states and 294 lemmas (before pruning)
2020.06.26 06:54:44 [INFO] provingground.learning.HoTTBot.$anonfun:1215:26 - Tangent lemmas (used with bases below): 5
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.0019023250043913482)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),3.414132136422497E-5)
(((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))),5.049952416727228E-4)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)),7.517409716603833E-5)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),3.086374927356086E-5)
2020.06.26 06:54:44 [INFO] provingground.learning.HoTTBot.$anonfun:1229:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.014686056891822131
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.014686039470995445
2020.06.26 06:54:44 [INFO] provingground.learning.HoTTBot.$anonfun:1241:28 - Lemmas in base for mixin (used with tangents above): 5
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.009279700601667187
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0016839595707925838
Type: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best term: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 0.0052375041070770395
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best term: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 0.002315271469460844
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.0015809124953228364
2020.06.26 06:54:44 [INFO] provingground.learning.HoTTBot.$anonfun:1248:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 5.049952416727228E-4, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 7.517409716603833E-5, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.014686056891822131, 0.0019023250043913482, 2.7937653241227126E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.014686039470995445, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 06:54:44 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 16, less than the time limit 2 minutes, with cutoff 6.400000000000002E-8; running again
2020.06.26 06:54:45 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 14, less than the time limit 2 minutes, with cutoff 1.2800000000000004E-8; running again
2020.06.26 06:55:05 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 20, less than the time limit 2 minutes, with cutoff 2.5600000000000007E-9; running again
2020.06.26 06:55:13 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 28, less than the time limit 2 minutes, with cutoff 1.2800000000000004E-8; running again
2020.06.26 06:55:18 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 12, less than the time limit 2 minutes, with cutoff 5.120000000000001E-10; running again
2020.06.26 06:55:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 18, less than the time limit 2 minutes, with cutoff 1.0240000000000002E-10; running again
2020.06.26 06:55:42 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 29, less than the time limit 2 minutes, with cutoff 2.5600000000000007E-9; running again
2020.06.26 06:55:47 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 10, less than the time limit 2 minutes, with cutoff 2.0480000000000003E-11; running again
2020.06.26 06:55:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 10, less than the time limit 2 minutes, with cutoff 4.096E-12; running again
2020.06.26 06:56:06 [INFO] provingground.learning.HoTTBot.$anonfun:1267:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.014686056891822131
P₁(((mul) (m)) (n) ∈ Terms) -> 0.09772534061444456
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.09772534061444456
P₁(n ∈ Terms) -> 0.09772534061444456
P₁(left-multiply ∈ Terms) -> 0.09772534061444456

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.014686039470995445
P₁(m ∈ Terms) -> 0.09772534061444456
P₁(right-multiply ∈ Terms) -> 0.09772534061444456


2020.06.26 06:56:06 [INFO] provingground.learning.HoTTBot.$anonfun:1229:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.4702136096817541
2020.06.26 06:56:06 [INFO] provingground.learning.HoTTBot.$anonfun:1241:28 - Lemmas in base for mixin (used with tangents above): 5
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.009886803589090621
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0017650959175670702
Type: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best term: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 0.005600152646471065
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best term: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 0.0024757537322823544
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.0016903760099316201
2020.06.26 06:56:06 [INFO] provingground.learning.HoTTBot.$anonfun:1248:28 - Inference by unified applications, triples and weights (for this base state)
(0.4702136096817541, 5.049952416727228E-4, 2.3745563545904074E-4) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 7.517409716603833E-5, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0019023250043913482, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 06:56:09 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 10, less than the time limit 2 minutes, with cutoff 8.192000000000001E-13; running again
2020.06.26 06:56:09 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 8.192000000000001E-13
2020.06.26 06:56:12 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 30, less than the time limit 2 minutes, with cutoff 5.120000000000001E-10; running again
2020.06.26 06:56:25 [INFO] provingground.learning.HoTTBot.$anonfun:1267:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.4702136096817541

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.26 06:56:29 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 16, less than the time limit 2 minutes, with cutoff 1.0240000000000002E-10; running again
2020.06.26 06:56:43 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 13, less than the time limit 2 minutes, with cutoff 2.0480000000000003E-11; running again
2020.06.26 06:56:57 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 14, less than the time limit 2 minutes, with cutoff 4.096E-12; running again
2020.06.26 06:57:11 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 14, less than the time limit 2 minutes, with cutoff 8.192000000000001E-13; running again
2020.06.26 06:57:11 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 8.192000000000001E-13
2020.06.26 06:57:12 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (25,1296818273)
2020.06.26 06:57:12 [INFO] provingground.learning.HoTTBot.scribeLog:1942:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (25,1296818273)
2020.06.26 06:57:12 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.26 06:57:12 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.26 07:00:55 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (26,1256147108), content:
provingground.learning.ExpressionEval$$anon$2@4adf48a4
2020.06.26 07:00:55 [INFO] provingground.learning.HoTTBot.scribeLog:1942:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (26,1256147108)
2020.06.26 07:00:55 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 07:00:55 [INFO] provingground.learning.HoTTBot.expEvToFinalState:474:26 - computing final state
2020.06.26 07:00:55 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 07:01:05 [INFO] provingground.learning.ExprCalc.stableVec:643:46 - completed 2 steps
2020.06.26 07:01:25 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (27,1095149066)
2020.06.26 07:01:25 [INFO] provingground.learning.HoTTBot.scribeLog:1942:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (27,1095149066)
2020.06.26 07:01:25 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 07:01:25 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 07:01:25 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 07:01:25 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 07:03:23 [INFO] provingground.learning.ExprCalc.stableVec:643:46 - completed 2 steps
2020.06.26 07:03:49 [ERROR] provingground.learning.ExprCalc.stableVec:640:25 - Timeout for stable vector after 13 steps
2020.06.26 07:05:17 [INFO] provingground.learning.HoTTBot.$anonfun:378:26 - Results: 5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.5608334347953203E-4; statement weight 1.8673979780399668E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.5705754331719667E-4; statement weight 5.992011857209685E-8
Lemma: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best proof: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 3.626481268514317E-6; statement weight 6.119576449417655E-8
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best proof: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 1.5904073068973297E-7; statement weight 2.2202862101333956E-10
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.5705754331719667E-4; statement weight 5.188292685458741E-8
2020.06.26 07:05:19 [INFO] provingground.learning.HoTTBot.$anonfun:378:26 - Steps (in final state): 4
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best proof: trans with weight 0.05648815690233422; statement weight 5.9495617142746624E-12
Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))); best proof: (`$amcpgrn :  M) ↦ (((((trans) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$amcpgrn)) ((((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)))) with weight 5.116846693820452E-8; statement weight 2.231605889160362E-13
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best proof: (left-multiply) (((mul) (m)) (n)) with weight 0.005967787740154664; statement weight 4.5190115957564127E-13
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best proof: (right-multiply) (m) with weight 0.005945170940484299; statement weight 4.4953694977448133E-13
2020.06.26 07:16:34 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (28,329518743)
2020.06.26 07:16:34 [INFO] provingground.learning.HoTTBot.scribeLog:1942:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (28,329518743)
2020.06.26 07:16:34 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.26 07:16:34 [INFO] provingground.learning.HoTTBot.$anonfun:904:24 - excluded lemmas:

2020.06.26 07:16:34 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (29,-1950297280)
2020.06.26 07:16:34 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (30,1126357868)
2020.06.26 07:16:34 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (31,1326820922)
2020.06.26 07:16:34 [INFO] provingground.learning.HoTTBot.scribeLog:1942:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (31,1326820922)
2020.06.26 07:16:34 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 07:18:14 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.26 07:18:14 [INFO] provingground.learning.HoTTBot.$anonfun:1011:22 - previous special init states are 2
2020.06.26 07:18:14 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.26 10:51:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TautologyInitState], id: (1,-384837536), content:
TautologyInitState(TermState([m : 0.14285714285714285, sym : 0.14285714285714285, ((mul) (m)) (n) : 0.14285714285714285, refl : 0.14285714285714285, mul : 0.14285714285714285, n : 0.14285714285714285, trans : 0.14285714285714285],[M : 1.0],Vector(),[],[],Empty))
2020.06.26 10:51:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (2,1588327529), content:
SpecialInitState(TermState([trans : 0.9, sym : 0.1],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.05,Some(TermGenParams(0.0,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.26 10:51:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (3,246182078), content:
SpecialInitState(TermState([left-multiply : 0.2, right-multiply : 0.2, ((mul) (m)) (n) : 0.2, m : 0.2, n : 0.2],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.5,Some(TermGenParams(0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.26 10:51:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.LocalProver], id: (4,582823858), content:
LocalProver(TermState([m : 0.08333333333333333, left-multiply : 0.08333333333333333, eqM : 0.08333333333333333, mul : 0.08333333333333333, n : 0.08333333333333333, trans : 0.08333333333333333, sym : 0.08333333333333333, ass1 : 0.08333333333333333, right-multiply : 0.08333333333333333, ass2 : 0.08333333333333333, refl : 0.08333333333333333, ((mul) (m)) (n) : 0.08333333333333333],[M : 1.0],Vector(),[],[((eqM) (((mul) (m)) (n))) (((mul) (n)) (m)) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0,Some(500000))
2020.06.26 10:51:09 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.LocalProver]
2020.06.26 10:51:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (5,469478999), content:
provingground.learning.ExpressionEval$$anon$2@1bfbae57
2020.06.26 10:51:24 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 10:51:25 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 10:51:24 [INFO] provingground.learning.HoTTBot.expEvToFinalState:476:26 - computing final state
2020.06.26 10:51:24 [INFO] provingground.learning.ExprCalc.finalVec:662:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 10:51:24 [INFO] provingground.learning.ExprCalc.finalVec:663:22 - Number of equations: 4128
2020.06.26 10:51:26 [INFO] provingground.learning.ExprCalc.stableVec:644:46 - completed 2 steps
2020.06.26 10:51:26 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (6,-1664112044)
2020.06.26 10:51:26 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 10:51:26 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 10:51:26 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 10:51:28 [INFO] provingground.learning.ExprCalc.finalVec:662:22 - Computing final vector, with maximum time Some(60000), exponent: 0.5, decay: 1.0
2020.06.26 10:51:28 [INFO] provingground.learning.ExprCalc.finalVec:663:22 - Number of equations: 2882
2020.06.26 10:51:28 [INFO] provingground.learning.HoTTBot.$anonfun:380:26 - Results: 3
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.666676177661691E-4; statement weight 4.922526522818089E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.6875890673843706E-4; statement weight 3.283350224245018E-7
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.6875890673843706E-4; statement weight 2.901648730630753E-7
2020.06.26 10:51:28 [INFO] provingground.learning.ExprCalc.stableVec:644:46 - completed 2 steps
2020.06.26 10:51:29 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (7,1645406931)
2020.06.26 10:51:29 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.26 10:51:29 [INFO] provingground.learning.HoTTBot.$anonfun:906:24 - excluded lemmas:

2020.06.26 10:51:29 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (8,-1445828818)
2020.06.26 10:51:29 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (9,-962844701)
2020.06.26 10:51:29 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (10,1833728595)
2020.06.26 10:51:29 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 10:51:31 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 10:51:31 [INFO] provingground.learning.HoTTBot.baseState:946:16 - Computed expression evaluator
2020.06.26 10:51:31 [INFO] provingground.learning.ExprCalc.finalVec:662:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 10:51:31 [INFO] provingground.learning.ExprCalc.finalVec:663:22 - Number of equations: 7626
2020.06.26 10:51:31 [INFO] provingground.learning.ExprCalc.stableVec:644:46 - completed 2 steps
2020.06.26 10:51:33 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (11,368099790)
2020.06.26 10:51:33 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 10:51:34 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.26 10:51:34 [INFO] provingground.learning.HoTTBot.$anonfun:1014:22 - previous special init states are 2
2020.06.26 10:51:34 [INFO] provingground.learning.HoTTBot.$anonfun:1017:22 - Using 7557 equations for base states
2020.06.26 10:51:34 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.26 10:51:33 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 10:51:34 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 10:51:34 [INFO] provingground.learning.HoTTBot.baseState:946:16 - Computed expression evaluator
2020.06.26 10:51:34 [INFO] provingground.learning.ExprCalc.finalVec:662:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 10:51:34 [INFO] provingground.learning.ExprCalc.finalVec:663:22 - Number of equations: 7600
2020.06.26 10:51:34 [INFO] provingground.learning.HoTTBot.baseState:946:16 - Computed expression evaluator
2020.06.26 10:51:34 [INFO] provingground.learning.ExprCalc.finalVec:662:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 10:51:34 [INFO] provingground.learning.ExprCalc.finalVec:663:22 - Number of equations: 7604
2020.06.26 10:51:34 [INFO] provingground.learning.ExprCalc.stableVec:644:46 - completed 2 steps
2020.06.26 10:51:34 [INFO] provingground.learning.ExprCalc.stableVec:644:46 - completed 2 steps
2020.06.26 10:51:35 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (12,412426767)
2020.06.26 10:51:35 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.26 10:51:35 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (13,-2086306360)
2020.06.26 10:51:35 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.26 10:51:35 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (14,-1666923435), content:
TangentBaseCompleted
2020.06.26 10:51:35 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.26 10:51:35 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.26 10:51:36 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 10:51:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 10:51:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 10:51:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 10:51:38 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 10:51:38 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 10:51:39 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 10:51:39 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 10:51:39 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 4.0E-5
2020.06.26 10:51:41 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 10:51:41 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.26 10:51:43 [INFO] provingground.learning.HoTTBot.$anonfun:1212:26 - generating equations with 3 base states and 18 lemmas (before pruning)
2020.06.26 10:51:43 [INFO] provingground.learning.HoTTBot.$anonfun:1220:26 - Tangent lemmas (used with bases below): 3
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.040700000848968604)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),0.001214698356305945)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),0.001114032298292804)
2020.06.26 10:51:43 [INFO] provingground.learning.HoTTBot.$anonfun:1234:28 - Terms in base (used with tangents above): 3
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.053326178457998585
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.002437424090839206
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.002437424090839206
2020.06.26 10:51:43 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.050046293108537594
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.011126917673166644
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.010695179485308265
2020.06.26 10:51:43 [INFO] provingground.learning.HoTTBot.$anonfun:1253:28 - Inference by unified applications, triples and weights (for this base state)
(0.053326178457998585, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.040700000848968604, 9.920316256645221E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 10:51:44 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.26 10:51:45 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.26 10:51:48 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 4, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.26 10:51:48 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 1.6000000000000004E-6
2020.06.26 10:51:48 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 3.2000000000000006E-7; running again
2020.06.26 10:51:50 [INFO] provingground.learning.HoTTBot.$anonfun:1272:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.053326178457998585

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap((mul) (m)) ∈ Funcs))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.002437424090839206
P₁(((mul) (m)) (n) ∈ Terms) -> 0.053326178457998585
P₁((mul) (m) ∈ Terms) -> 0.001286599861208855
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(n ∈ Terms) -> 0.053326178457998585
P₁(left-multiply ∈ Terms) -> 0.053326178457998585

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.002437424090839206
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(right-multiply ∈ Terms) -> 0.053326178457998585


2020.06.26 10:51:50 [INFO] provingground.learning.HoTTBot.$anonfun:1234:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.016270597645731934
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.016270597645731934
2020.06.26 10:51:50 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.08055093331491427
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.017883196935657784
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.01723230794846274
2020.06.26 10:51:50 [INFO] provingground.learning.HoTTBot.$anonfun:1253:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.040700000848968604, 6.622133379945163E-4) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 10:51:51 [INFO] provingground.learning.HoTTBot.$anonfun:1272:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.016270597645731934
P₁(((mul) (m)) (n) ∈ Terms) -> 0.08837517523251155
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(n ∈ Terms) -> 0.08837517523251155
P₁(left-multiply ∈ Terms) -> 0.08837517523251155

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.016270597645731934
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(right-multiply ∈ Terms) -> 0.08837517523251155


2020.06.26 10:51:51 [INFO] provingground.learning.HoTTBot.$anonfun:1234:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.45000000000000007
2020.06.26 10:51:51 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.09114656135389602
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0202355433962171
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.019499036808838258
2020.06.26 10:51:51 [INFO] provingground.learning.HoTTBot.$anonfun:1253:28 - Inference by unified applications, triples and weights (for this base state)
(0.45000000000000007, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.040700000848968604, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 10:51:52 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 6.400000000000002E-8; running again
2020.06.26 10:51:51 [INFO] provingground.learning.HoTTBot.$anonfun:1272:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.45000000000000007

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.26 10:51:54 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 1.2800000000000004E-8; running again
2020.06.26 10:51:56 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.5600000000000007E-9; running again
2020.06.26 10:51:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 5.120000000000001E-10; running again
2020.06.26 10:52:00 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 1.0240000000000002E-10; running again
2020.06.26 10:52:02 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0480000000000003E-11; running again
2020.06.26 10:52:02 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 2.0480000000000003E-11
2020.06.26 10:52:03 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-169862204)
2020.06.26 10:52:03 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-169862204)
2020.06.26 10:52:03 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.26 10:52:03 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.26 10:52:43 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1577085446), content:
provingground.learning.ExpressionEval$$anon$2@5e006a06
2020.06.26 10:52:43 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1577085446)
2020.06.26 10:52:43 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 10:52:43 [INFO] provingground.learning.HoTTBot.expEvToFinalState:476:26 - computing final state
2020.06.26 10:52:43 [INFO] provingground.learning.ExprCalc.finalVec:662:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 10:52:43 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 10:52:43 [INFO] provingground.learning.ExprCalc.finalVec:663:22 - Number of equations: 14279
2020.06.26 10:52:46 [INFO] provingground.learning.ExprCalc.stableVec:644:46 - completed 2 steps
2020.06.26 10:52:49 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,209762951)
2020.06.26 10:52:49 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,209762951)
2020.06.26 10:52:49 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 10:52:49 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 10:52:49 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 10:52:49 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 10:53:03 [INFO] provingground.learning.ExprCalc.finalVec:662:22 - Computing final vector, with maximum time Some(60000), exponent: 0.5, decay: 1.0
2020.06.26 10:53:03 [INFO] provingground.learning.ExprCalc.finalVec:663:22 - Number of equations: 18676
2020.06.26 10:53:08 [INFO] provingground.learning.ExprCalc.stableVec:644:46 - completed 2 steps
2020.06.26 10:53:28 [INFO] provingground.learning.HoTTBot.$anonfun:380:26 - Results: 5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.565980368125865E-4; statement weight 1.871203887165631E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.5757607259762927E-4; statement weight 6.015493085387075E-8
Lemma: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best proof: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 3.6357335767957786E-6; statement weight 6.143877824764005E-8
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best proof: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 1.5966674388756185E-7; statement weight 2.2332562602499821E-10
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.5757607259762927E-4; statement weight 5.2078036146675147E-8
2020.06.26 10:53:32 [INFO] provingground.learning.HoTTBot.$anonfun:380:26 - Steps (in final state): 3
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best proof: trans with weight 0.05649437698358171; statement weight 5.944062904839253E-12
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best proof: (left-multiply) (((mul) (m)) (n)) with weight 0.005971859364160798; statement weight 4.561625690383875E-13
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best proof: (right-multiply) (m) with weight 0.005949184168104393; statement weight 4.5358737659944094E-13
2020.06.26 10:53:38 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-1173733910)
2020.06.26 10:53:38 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-1173733910)
2020.06.26 10:53:38 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.26 10:53:38 [INFO] provingground.learning.HoTTBot.$anonfun:906:24 - excluded lemmas:

2020.06.26 10:53:38 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (19,-334754299)
2020.06.26 10:53:38 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (20,-1514984774)
2020.06.26 10:53:38 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,1200301437)
2020.06.26 10:53:38 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,1200301437)
2020.06.26 10:53:38 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 10:53:57 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.26 10:53:57 [INFO] provingground.learning.HoTTBot.$anonfun:1014:22 - previous special init states are 2
2020.06.26 10:53:57 [INFO] provingground.learning.HoTTBot.$anonfun:1017:22 - Using 56147 equations for base states
2020.06.26 10:53:57 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.26 10:53:57 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 10:53:57 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 10:58:46 [INFO] provingground.learning.HoTTBot.baseState:946:16 - Computed expression evaluator
2020.06.26 10:58:46 [INFO] provingground.learning.ExprCalc.finalVec:662:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 10:58:46 [INFO] provingground.learning.ExprCalc.finalVec:663:22 - Number of equations: 57030
2020.06.26 10:58:46 [INFO] provingground.learning.HoTTBot.baseState:946:16 - Computed expression evaluator
2020.06.26 10:58:46 [INFO] provingground.learning.ExprCalc.finalVec:662:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 10:58:46 [INFO] provingground.learning.ExprCalc.finalVec:663:22 - Number of equations: 57034
2020.06.26 10:58:51 [INFO] provingground.learning.ExprCalc.stableVec:644:46 - completed 2 steps
2020.06.26 10:58:51 [INFO] provingground.learning.ExprCalc.stableVec:644:46 - completed 2 steps
2020.06.26 10:59:18 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (22,-667901732)
2020.06.26 10:59:18 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.26 10:59:22 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (23,1526556128)
2020.06.26 10:59:22 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.26 10:59:23 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435), content:
TangentBaseCompleted
2020.06.26 10:59:22 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435)
2020.06.26 10:59:23 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.26 10:59:23 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.26 10:59:25 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 10:59:25 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 10:59:25 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 10:59:26 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 10:59:28 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 10:59:30 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 4, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 10:59:30 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.26 10:59:35 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 4, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.26 10:59:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 7, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.26 10:59:41 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 6, less than the time limit 2 minutes, with cutoff 3.2000000000000006E-7; running again
2020.06.26 10:59:48 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 10, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.26 10:59:51 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 10, less than the time limit 2 minutes, with cutoff 6.400000000000002E-8; running again
2020.06.26 11:00:01 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 12, less than the time limit 2 minutes, with cutoff 3.2000000000000006E-7; running again
2020.06.26 11:00:02 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 10, less than the time limit 2 minutes, with cutoff 1.2800000000000004E-8; running again
2020.06.26 11:00:13 [INFO] provingground.learning.HoTTBot.$anonfun:1212:26 - generating equations with 2 base states and 294 lemmas (before pruning)
2020.06.26 11:00:13 [INFO] provingground.learning.HoTTBot.$anonfun:1220:26 - Tangent lemmas (used with bases below): 5
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.0019023250043913482)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),3.414132136422497E-5)
(((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))),5.049952416727228E-4)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)),7.517409716603833E-5)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),3.086374927356086E-5)
2020.06.26 11:00:13 [INFO] provingground.learning.HoTTBot.$anonfun:1234:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.014686056891822131
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.014686039470995445
2020.06.26 11:00:13 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Lemmas in base for mixin (used with tangents above): 5
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.009279700601667187
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0016839595707925838
Type: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best term: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 0.0052375041070770395
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best term: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 0.002315271469460844
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.0015809124953228364
2020.06.26 11:00:13 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 11, less than the time limit 2 minutes, with cutoff 2.5600000000000007E-9; running again
2020.06.26 11:00:13 [INFO] provingground.learning.HoTTBot.$anonfun:1253:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 5.049952416727228E-4, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 7.517409716603833E-5, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.014686056891822131, 0.0019023250043913482, 2.7937653241227126E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.014686039470995445, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 11:00:23 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 9, less than the time limit 2 minutes, with cutoff 5.120000000000001E-10; running again
2020.06.26 11:00:23 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 22, less than the time limit 2 minutes, with cutoff 6.400000000000002E-8; running again
2020.06.26 11:00:42 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 18, less than the time limit 2 minutes, with cutoff 1.0240000000000002E-10; running again
2020.06.26 11:00:51 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 27, less than the time limit 2 minutes, with cutoff 1.2800000000000004E-8; running again
2020.06.26 11:00:51 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 9, less than the time limit 2 minutes, with cutoff 2.0480000000000003E-11; running again
2020.06.26 11:01:11 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 19, less than the time limit 2 minutes, with cutoff 4.096E-12; running again
2020.06.26 11:01:18 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 27, less than the time limit 2 minutes, with cutoff 2.5600000000000007E-9; running again
2020.06.26 11:01:19 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 8, less than the time limit 2 minutes, with cutoff 8.192000000000001E-13; running again
2020.06.26 11:01:19 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 8.192000000000001E-13
2020.06.26 11:01:25 [INFO] provingground.learning.HoTTBot.$anonfun:1272:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.014686056891822131
P₁(((mul) (m)) (n) ∈ Terms) -> 0.09772534061444456
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.09772534061444456
P₁(n ∈ Terms) -> 0.09772534061444456
P₁(left-multiply ∈ Terms) -> 0.09772534061444456

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.014686039470995445
P₁(m ∈ Terms) -> 0.09772534061444456
P₁(right-multiply ∈ Terms) -> 0.09772534061444456


2020.06.26 11:01:25 [INFO] provingground.learning.HoTTBot.$anonfun:1234:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.4702136096817541
2020.06.26 11:01:25 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Lemmas in base for mixin (used with tangents above): 5
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.009886803589090623
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0017650959175670702
Type: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best term: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 0.005600152646471065
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best term: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 0.002475753732282355
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.0016903760099316201
2020.06.26 11:01:25 [INFO] provingground.learning.HoTTBot.$anonfun:1253:28 - Inference by unified applications, triples and weights (for this base state)
(0.4702136096817541, 5.049952416727228E-4, 2.3745563545904074E-4) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 7.517409716603833E-5, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0019023250043913482, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 11:01:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 19, less than the time limit 2 minutes, with cutoff 5.120000000000001E-10; running again
2020.06.26 11:01:39 [INFO] provingground.learning.HoTTBot.$anonfun:1272:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.4702136096817541

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.26 11:01:52 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 14, less than the time limit 2 minutes, with cutoff 1.0240000000000002E-10; running again
2020.06.26 11:02:05 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 13, less than the time limit 2 minutes, with cutoff 2.0480000000000003E-11; running again
2020.06.26 11:02:19 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 13, less than the time limit 2 minutes, with cutoff 4.096E-12; running again
2020.06.26 11:02:33 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 14, less than the time limit 2 minutes, with cutoff 8.192000000000001E-13; running again
2020.06.26 11:02:33 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 8.192000000000001E-13
2020.06.26 11:02:34 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (25,-4302043)
2020.06.26 11:02:34 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (25,-4302043)
2020.06.26 11:02:34 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.26 11:02:34 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.26 11:06:23 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (26,1440434217), content:
provingground.learning.ExpressionEval$$anon$2@55db4829
2020.06.26 11:06:23 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (26,1440434217)
2020.06.26 11:06:23 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 11:06:23 [INFO] provingground.learning.HoTTBot.expEvToFinalState:476:26 - computing final state
2020.06.26 11:06:23 [INFO] provingground.learning.ExprCalc.finalVec:662:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 11:06:23 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 11:06:23 [INFO] provingground.learning.ExprCalc.finalVec:663:22 - Number of equations: 55910
2020.06.26 11:06:34 [INFO] provingground.learning.ExprCalc.stableVec:644:46 - completed 2 steps
2020.06.26 11:06:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (27,495351226)
2020.06.26 11:06:53 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 11:06:53 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 11:06:53 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 11:06:53 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 11:06:53 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (27,495351226)
2020.06.26 11:08:15 [INFO] provingground.learning.ExprCalc.finalVec:662:22 - Computing final vector, with maximum time Some(60000), exponent: 0.5, decay: 1.0
2020.06.26 11:08:15 [INFO] provingground.learning.ExprCalc.finalVec:663:22 - Number of equations: 89893
2020.06.26 11:08:49 [INFO] provingground.learning.ExprCalc.stableVec:644:46 - completed 2 steps
2020.06.26 11:09:16 [ERROR] provingground.learning.ExprCalc.stableVec:641:25 - Timeout for stable vector after 15 steps
2020.06.26 11:10:44 [INFO] provingground.learning.HoTTBot.$anonfun:380:26 - Results: 5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.5608334347953203E-4; statement weight 1.8673979780399668E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.5705754331719667E-4; statement weight 5.992011857209685E-8
Lemma: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best proof: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 3.626481268514317E-6; statement weight 6.119576449417655E-8
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best proof: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 1.5904073068973297E-7; statement weight 2.2202862101333956E-10
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.5705754331719667E-4; statement weight 5.188292685458741E-8
2020.06.26 11:10:48 [INFO] provingground.learning.HoTTBot.$anonfun:380:26 - Steps (in final state): 4
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best proof: trans with weight 0.05648815690233422; statement weight 5.9495617142746624E-12
Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))); best proof: (`$alrhpco :  M) ↦ (((((trans) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$alrhpco)) ((((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)))) with weight 5.116846693820452E-8; statement weight 2.231605889160362E-13
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best proof: (left-multiply) (((mul) (m)) (n)) with weight 0.005967787740154664; statement weight 4.5190115957564127E-13
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best proof: (right-multiply) (m) with weight 0.005945170940484299; statement weight 4.4953694977448133E-13
2020.06.26 11:22:52 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (28,329518743)
2020.06.26 11:22:52 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (28,329518743)
2020.06.26 11:22:52 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.26 11:22:52 [INFO] provingground.learning.HoTTBot.$anonfun:906:24 - excluded lemmas:

2020.06.26 11:22:52 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (29,-1950297280)
2020.06.26 11:22:52 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (30,1126357868)
2020.06.26 11:22:52 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (31,1326820922)
2020.06.26 11:22:52 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (31,1326820922)
2020.06.26 11:22:52 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 11:24:38 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.26 11:24:38 [INFO] provingground.learning.HoTTBot.$anonfun:1014:22 - previous special init states are 2
2020.06.26 11:24:38 [INFO] provingground.learning.HoTTBot.$anonfun:1017:22 - Using 247754 equations for base states
2020.06.26 11:24:38 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.26 11:24:38 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 11:24:38 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 12:19:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TautologyInitState], id: (1,-384837536), content:
TautologyInitState(TermState([m : 0.14285714285714285, sym : 0.14285714285714285, ((mul) (m)) (n) : 0.14285714285714285, refl : 0.14285714285714285, mul : 0.14285714285714285, n : 0.14285714285714285, trans : 0.14285714285714285],[M : 1.0],Vector(),[],[],Empty))
2020.06.26 12:19:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (2,1588327529), content:
SpecialInitState(TermState([trans : 0.9, sym : 0.1],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.05,Some(TermGenParams(0.0,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.26 12:19:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (3,246182078), content:
SpecialInitState(TermState([left-multiply : 0.2, right-multiply : 0.2, ((mul) (m)) (n) : 0.2, m : 0.2, n : 0.2],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.5,Some(TermGenParams(0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.26 12:19:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.LocalProver], id: (4,582823858), content:
LocalProver(TermState([m : 0.08333333333333333, left-multiply : 0.08333333333333333, eqM : 0.08333333333333333, mul : 0.08333333333333333, n : 0.08333333333333333, trans : 0.08333333333333333, sym : 0.08333333333333333, ass1 : 0.08333333333333333, right-multiply : 0.08333333333333333, ass2 : 0.08333333333333333, refl : 0.08333333333333333, ((mul) (m)) (n) : 0.08333333333333333],[M : 1.0],Vector(),[],[((eqM) (((mul) (m)) (n))) (((mul) (n)) (m)) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0,Some(500000))
2020.06.26 12:19:09 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.LocalProver]
2020.06.26 12:19:22 [INFO] provingground.learning.ExpressionEval.initMap:116:23 - Computing initial map with 5805 atoms
2020.06.26 12:19:22 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (5,972198657), content:
provingground.learning.ExpressionEval$$anon$2@39f29301
2020.06.26 12:19:22 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 12:19:22 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 12:19:22 [INFO] provingground.learning.HoTTBot.expEvToFinalState:476:26 - computing final state
2020.06.26 12:19:22 [INFO] provingground.learning.ExprCalc.finalVec:664:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 12:19:22 [INFO] provingground.learning.ExprCalc.finalVec:665:22 - Number of equations: 4128
2020.06.26 12:19:24 [INFO] provingground.learning.ExprCalc.stableVec:646:46 - completed 2 steps
2020.06.26 12:19:24 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (6,-1664112044)
2020.06.26 12:19:24 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 12:19:24 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 12:19:24 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 12:19:26 [INFO] provingground.learning.HoTTBot.$anonfun:380:26 - Results: 3
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.666676177661691E-4; statement weight 4.922526522818089E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.6875890673843706E-4; statement weight 3.283350224245018E-7
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.6875890673843706E-4; statement weight 2.901648730630753E-7
2020.06.26 12:19:26 [INFO] provingground.learning.ExpressionEval.initMap:116:23 - Computing initial map with 3877 atoms
2020.06.26 12:19:26 [INFO] provingground.learning.ExprCalc.finalVec:664:22 - Computing final vector, with maximum time Some(60000), exponent: 0.5, decay: 1.0
2020.06.26 12:19:26 [INFO] provingground.learning.ExprCalc.finalVec:665:22 - Number of equations: 2882
2020.06.26 12:19:26 [INFO] provingground.learning.ExprCalc.stableVec:646:46 - completed 2 steps
2020.06.26 12:19:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (7,1645406931)
2020.06.26 12:19:28 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.26 12:19:28 [INFO] provingground.learning.HoTTBot.$anonfun:906:24 - excluded lemmas:

2020.06.26 12:19:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (8,-1445828818)
2020.06.26 12:19:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (9,-962844701)
2020.06.26 12:19:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (10,1833728595)
2020.06.26 12:19:28 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 12:19:30 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 12:19:30 [INFO] provingground.learning.ExpressionEval.initMap:116:23 - Computing initial map with 5210 atoms
2020.06.26 12:19:30 [INFO] provingground.learning.HoTTBot.baseState:946:16 - Computed expression evaluator
2020.06.26 12:19:30 [INFO] provingground.learning.ExprCalc.finalVec:664:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 12:19:30 [INFO] provingground.learning.ExprCalc.finalVec:665:22 - Number of equations: 3740
2020.06.26 12:19:30 [INFO] provingground.learning.ExprCalc.stableVec:646:46 - completed 2 steps
2020.06.26 12:19:32 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (11,-772975359)
2020.06.26 12:19:32 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 12:19:32 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.26 12:19:32 [INFO] provingground.learning.HoTTBot.$anonfun:1014:22 - previous special init states are 2
2020.06.26 12:19:34 [INFO] provingground.learning.HoTTBot.$anonfun:1017:22 - Using 6777 equation nodes for base states
2020.06.26 12:19:34 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.26 12:19:34 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 12:19:34 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 12:19:34 [INFO] provingground.learning.ExpressionEval.initMap:116:23 - Computing initial map with 5182 atoms
2020.06.26 12:19:34 [INFO] provingground.learning.ExpressionEval.initMap:116:23 - Computing initial map with 5182 atoms
2020.06.26 12:19:34 [INFO] provingground.learning.HoTTBot.baseState:946:16 - Computed expression evaluator
2020.06.26 12:19:34 [INFO] provingground.learning.ExprCalc.finalVec:664:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 12:19:34 [INFO] provingground.learning.ExprCalc.finalVec:665:22 - Number of equations: 3733
2020.06.26 12:19:34 [INFO] provingground.learning.HoTTBot.baseState:946:16 - Computed expression evaluator
2020.06.26 12:19:34 [INFO] provingground.learning.ExprCalc.finalVec:664:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 12:19:34 [INFO] provingground.learning.ExprCalc.finalVec:665:22 - Number of equations: 3733
2020.06.26 12:19:34 [INFO] provingground.learning.ExprCalc.stableVec:646:46 - completed 2 steps
2020.06.26 12:19:34 [INFO] provingground.learning.ExprCalc.stableVec:646:46 - completed 2 steps
2020.06.26 12:19:36 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (12,412426767)
2020.06.26 12:19:36 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.26 12:19:36 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (13,-1927624303)
2020.06.26 12:19:36 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.26 12:19:36 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (14,-1666923435), content:
TangentBaseCompleted
2020.06.26 12:19:36 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.26 12:19:36 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.26 12:19:36 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 12:19:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 12:19:36 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 12:19:36 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 12:19:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 12:19:38 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 12:19:38 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 12:19:38 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 4.0E-5
2020.06.26 12:19:39 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 12:19:40 [INFO] provingground.learning.HoTTBot.$anonfun:1212:26 - generating equations with 3 base states and 18 lemmas (before pruning)
2020.06.26 12:19:40 [INFO] provingground.learning.HoTTBot.$anonfun:1220:26 - Tangent lemmas (used with bases below): 3
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.040700000848968604)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),0.001214698356305945)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),0.001114032298292804)
2020.06.26 12:19:40 [INFO] provingground.learning.HoTTBot.$anonfun:1234:28 - Terms in base (used with tangents above): 3
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.04043963963974665
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.0054346766512649095
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.005406533658851866
2020.06.26 12:19:40 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.03816804361515053
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.008673894410700302
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.008367544069125507
2020.06.26 12:19:40 [INFO] provingground.learning.HoTTBot.$anonfun:1253:28 - Inference by unified applications, triples and weights (for this base state)
(0.04043963963974665, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0054346766512649095, 0.040700000848968604, 2.2119134432035167E-4) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.005406533658851866, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 12:19:41 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 12:19:43 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 4, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.26 12:19:44 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.26 12:19:47 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.26 12:19:47 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 1.6000000000000004E-6
2020.06.26 12:19:47 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 4, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.26 12:19:48 [INFO] provingground.learning.HoTTBot.$anonfun:1272:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.04043963963974665

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap((mul) (m)) ∈ Funcs))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0054346766512649095
P₁(((mul) (m)) (n) ∈ Terms) -> 0.04069521827206224
P₁((mul) (m) ∈ Terms) -> 0.005406533658851866
P₁(m ∈ Terms) -> 0.04043963963974665
P₁(n ∈ Terms) -> 0.04043963963974665
P₁(left-multiply ∈ Terms) -> 0.04043963963974665

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.005406533658851866
P₁(m ∈ Terms) -> 0.04043963963974665
P₁(right-multiply ∈ Terms) -> 0.04043963963974665


2020.06.26 12:19:48 [INFO] provingground.learning.HoTTBot.$anonfun:1234:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.05031952815190707
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.05031952815190707
2020.06.26 12:19:48 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.04862704546996386
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.010795741213063497
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.010402812080231564
2020.06.26 12:19:48 [INFO] provingground.learning.HoTTBot.$anonfun:1253:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.05031952815190707, 0.040700000848968604, 0.0020480048385023175) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.05031952815190707, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 12:19:50 [INFO] provingground.learning.HoTTBot.$anonfun:1272:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.05031952815190707
P₁(((mul) (m)) (n) ∈ Terms) -> 0.05335038946906504
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.05335038946906504
P₁(n ∈ Terms) -> 0.05335038946906504
P₁(left-multiply ∈ Terms) -> 0.05335038946906504

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.05031952815190707
P₁(m ∈ Terms) -> 0.05335038946906504
P₁(right-multiply ∈ Terms) -> 0.05335038946906504


2020.06.26 12:19:50 [INFO] provingground.learning.HoTTBot.$anonfun:1234:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.45000000000000007
2020.06.26 12:19:50 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.09114656135389602
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0202355433962171
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.019499036808838258
2020.06.26 12:19:50 [INFO] provingground.learning.HoTTBot.$anonfun:1253:28 - Inference by unified applications, triples and weights (for this base state)
(0.45000000000000007, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.040700000848968604, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 12:19:50 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 3.2000000000000006E-7; running again
2020.06.26 12:19:50 [INFO] provingground.learning.HoTTBot.$anonfun:1272:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.45000000000000007

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.26 12:19:52 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 6.400000000000002E-8; running again
2020.06.26 12:19:54 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 1.2800000000000004E-8; running again
2020.06.26 12:19:56 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.5600000000000007E-9; running again
2020.06.26 12:19:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 5.120000000000001E-10; running again
2020.06.26 12:19:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 5.120000000000001E-10
2020.06.26 12:20:00 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-72859733)
2020.06.26 12:20:00 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-72859733)
2020.06.26 12:20:00 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.26 12:20:00 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.26 12:20:38 [INFO] provingground.learning.ExpressionEval.initMap:116:23 - Computing initial map with 19563 atoms
2020.06.26 12:20:38 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,474599068), content:
provingground.learning.ExpressionEval$$anon$2@1c49ce9c
2020.06.26 12:20:38 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,474599068)
2020.06.26 12:20:38 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 12:20:38 [INFO] provingground.learning.HoTTBot.expEvToFinalState:476:26 - computing final state
2020.06.26 12:20:38 [INFO] provingground.learning.ExprCalc.finalVec:664:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 12:20:38 [INFO] provingground.learning.ExprCalc.finalVec:665:22 - Number of equations: 14279
2020.06.26 12:20:38 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 12:20:40 [INFO] provingground.learning.ExprCalc.stableVec:646:46 - completed 2 steps
2020.06.26 12:20:44 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,209762951)
2020.06.26 12:20:44 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,209762951)
2020.06.26 12:20:44 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 12:20:44 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 12:20:44 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 12:20:44 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 12:21:02 [INFO] provingground.learning.ExpressionEval.initMap:116:23 - Computing initial map with 25787 atoms
2020.06.26 12:21:02 [INFO] provingground.learning.ExprCalc.finalVec:664:22 - Computing final vector, with maximum time Some(60000), exponent: 0.5, decay: 1.0
2020.06.26 12:21:02 [INFO] provingground.learning.ExprCalc.finalVec:665:22 - Number of equations: 18676
2020.06.26 12:21:08 [INFO] provingground.learning.ExprCalc.stableVec:646:46 - completed 2 steps
2020.06.26 12:21:24 [INFO] provingground.learning.HoTTBot.$anonfun:380:26 - Steps (in final state): 3
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best proof: trans with weight 0.05649437698358171; statement weight 5.944062904839253E-12
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best proof: (left-multiply) (((mul) (m)) (n)) with weight 0.005971859364160798; statement weight 4.561625690383875E-13
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best proof: (right-multiply) (m) with weight 0.005949184168104393; statement weight 4.5358737659944094E-13
2020.06.26 12:21:24 [INFO] provingground.learning.HoTTBot.$anonfun:380:26 - Results: 5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.565980368125865E-4; statement weight 1.871203887165631E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.5757607259762927E-4; statement weight 6.015493085387075E-8
Lemma: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best proof: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 3.6357335767957786E-6; statement weight 6.143877824764005E-8
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best proof: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 1.5966674388756185E-7; statement weight 2.2332562602499821E-10
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.5757607259762927E-4; statement weight 5.2078036146675147E-8
2020.06.26 12:21:32 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-1173733910)
2020.06.26 12:21:32 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-1173733910)
2020.06.26 12:21:32 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.26 12:21:32 [INFO] provingground.learning.HoTTBot.$anonfun:906:24 - excluded lemmas:

2020.06.26 12:21:32 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (19,-334754299)
2020.06.26 12:21:32 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (20,-1514984774)
2020.06.26 12:21:32 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,1200301437)
2020.06.26 12:21:32 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,1200301437)
2020.06.26 12:21:32 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 12:21:51 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.26 12:21:51 [INFO] provingground.learning.HoTTBot.$anonfun:1014:22 - previous special init states are 2
2020.06.26 12:22:10 [INFO] provingground.learning.HoTTBot.$anonfun:1017:22 - Using 62570 equation nodes for base states
2020.06.26 12:22:10 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.26 12:22:10 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 12:22:10 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 12:22:17 [INFO] provingground.learning.ExpressionEval.initMap:116:23 - Computing initial map with 48587 atoms
2020.06.26 12:22:17 [INFO] provingground.learning.ExpressionEval.initMap:116:23 - Computing initial map with 48587 atoms
2020.06.26 12:26:54 [INFO] provingground.learning.HoTTBot.baseState:946:16 - Computed expression evaluator
2020.06.26 12:26:54 [INFO] provingground.learning.ExprCalc.finalVec:664:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 12:26:54 [INFO] provingground.learning.ExprCalc.finalVec:665:22 - Number of equations: 36994
2020.06.26 12:26:55 [INFO] provingground.learning.HoTTBot.baseState:946:16 - Computed expression evaluator
2020.06.26 12:26:55 [INFO] provingground.learning.ExprCalc.finalVec:664:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 12:26:55 [INFO] provingground.learning.ExprCalc.finalVec:665:22 - Number of equations: 36994
2020.06.26 12:26:57 [INFO] provingground.learning.ExprCalc.stableVec:646:46 - completed 2 steps
2020.06.26 12:26:59 [INFO] provingground.learning.ExprCalc.stableVec:646:46 - completed 2 steps
2020.06.26 12:27:24 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (22,2056196020)
2020.06.26 12:27:24 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.26 12:27:26 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (23,-643138261)
2020.06.26 12:27:26 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.26 12:27:26 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435), content:
TangentBaseCompleted
2020.06.26 12:27:26 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435)
2020.06.26 12:27:26 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.26 12:27:26 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.26 12:27:28 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 12:27:28 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 12:27:28 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 12:27:29 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 12:27:32 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 12:27:33 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 12:27:36 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.26 12:27:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 4, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.26 12:27:41 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 4, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.26 12:27:51 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 10, less than the time limit 2 minutes, with cutoff 3.2000000000000006E-7; running again
2020.06.26 12:27:53 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 16, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.26 12:28:03 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 11, less than the time limit 2 minutes, with cutoff 6.400000000000002E-8; running again
2020.06.26 12:28:10 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 7, less than the time limit 2 minutes, with cutoff 1.2800000000000004E-8; running again
2020.06.26 12:28:12 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 18, less than the time limit 2 minutes, with cutoff 3.2000000000000006E-7; running again
2020.06.26 12:28:19 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 7, less than the time limit 2 minutes, with cutoff 2.5600000000000007E-9; running again
2020.06.26 12:28:29 [INFO] provingground.learning.HoTTBot.$anonfun:1212:26 - generating equations with 2 base states and 294 lemmas (before pruning)
2020.06.26 12:28:29 [INFO] provingground.learning.HoTTBot.$anonfun:1220:26 - Tangent lemmas (used with bases below): 5
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.0019023250043913482)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),3.414132136422497E-5)
(((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))),5.049952416727228E-4)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)),7.517409716603833E-5)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),3.086374927356086E-5)
2020.06.26 12:28:29 [INFO] provingground.learning.HoTTBot.$anonfun:1234:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.03822070154308431
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.03822069025781412
2020.06.26 12:28:29 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Lemmas in base for mixin (used with tangents above): 5
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.006134890935102936
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0012142891670888945
Type: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best term: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 0.0033929877793663116
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best term: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 0.0014998914828880682
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.001168884035337544
2020.06.26 12:28:29 [INFO] provingground.learning.HoTTBot.$anonfun:1253:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 5.049952416727228E-4, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 7.517409716603833E-5, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.03822070154308431, 0.0019023250043913482, 7.270819623078827E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.03822069025781412, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 12:28:30 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 11, less than the time limit 2 minutes, with cutoff 5.120000000000001E-10; running again
2020.06.26 12:28:41 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 10, less than the time limit 2 minutes, with cutoff 1.0240000000000002E-10; running again
2020.06.26 12:28:46 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 34, less than the time limit 2 minutes, with cutoff 6.400000000000002E-8; running again
2020.06.26 12:28:51 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 10, less than the time limit 2 minutes, with cutoff 2.0480000000000003E-11; running again
2020.06.26 12:29:11 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 20, less than the time limit 2 minutes, with cutoff 4.096E-12; running again
2020.06.26 12:29:20 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 9, less than the time limit 2 minutes, with cutoff 8.192000000000001E-13; running again
2020.06.26 12:29:20 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 8.192000000000001E-13
2020.06.26 12:29:21 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 34, less than the time limit 2 minutes, with cutoff 1.2800000000000004E-8; running again
2020.06.26 12:29:38 [INFO] provingground.learning.HoTTBot.$anonfun:1272:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.03822070154308431
P₁(((mul) (m)) (n) ∈ Terms) -> 0.06330895015264633
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.06330895015264633
P₁(n ∈ Terms) -> 0.06330895015264633
P₁(left-multiply ∈ Terms) -> 0.06330895015264633

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.03822069025781412
P₁(m ∈ Terms) -> 0.06330895015264633
P₁(right-multiply ∈ Terms) -> 0.06330895015264633


2020.06.26 12:29:38 [INFO] provingground.learning.HoTTBot.$anonfun:1234:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.46525476060073123
2020.06.26 12:29:38 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Lemmas in base for mixin (used with tangents above): 5
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.009782537855639822
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0017464813047857245
Type: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best term: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 0.00563826527569029
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best term: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 0.0024497180713550742
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.0016725493895385912
2020.06.26 12:29:38 [INFO] provingground.learning.HoTTBot.$anonfun:1253:28 - Inference by unified applications, triples and weights (for this base state)
(0.46525476060073123, 5.049952416727228E-4, 2.3495144026895105E-4) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 7.517409716603833E-5, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0019023250043913482, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 12:29:45 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 23, less than the time limit 2 minutes, with cutoff 2.5600000000000007E-9; running again
2020.06.26 12:29:55 [INFO] provingground.learning.HoTTBot.$anonfun:1272:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.46525476060073123

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.26 12:30:05 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 20, less than the time limit 2 minutes, with cutoff 5.120000000000001E-10; running again
2020.06.26 12:30:23 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 18, less than the time limit 2 minutes, with cutoff 1.0240000000000002E-10; running again
2020.06.26 12:30:42 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 18, less than the time limit 2 minutes, with cutoff 2.0480000000000003E-11; running again
2020.06.26 12:31:00 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 17, less than the time limit 2 minutes, with cutoff 4.096E-12; running again
2020.06.26 12:31:17 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 17, less than the time limit 2 minutes, with cutoff 8.192000000000001E-13; running again
2020.06.26 12:31:17 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 8.192000000000001E-13
2020.06.26 12:31:19 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (25,129543120)
2020.06.26 12:31:19 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (25,129543120)
2020.06.26 12:31:19 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.26 12:31:19 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.26 12:34:59 [INFO] provingground.learning.ExpressionEval.initMap:116:23 - Computing initial map with 80063 atoms
2020.06.26 12:35:00 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (26,78470530), content:
provingground.learning.ExpressionEval$$anon$2@4ad5d82
2020.06.26 12:35:00 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (26,78470530)
2020.06.26 12:35:00 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 12:35:00 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 12:35:00 [INFO] provingground.learning.HoTTBot.expEvToFinalState:476:26 - computing final state
2020.06.26 12:35:00 [INFO] provingground.learning.ExprCalc.finalVec:664:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 12:35:00 [INFO] provingground.learning.ExprCalc.finalVec:665:22 - Number of equations: 58934
2020.06.26 12:35:11 [INFO] provingground.learning.ExprCalc.stableVec:646:46 - completed 2 steps
2020.06.26 12:35:31 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (27,-1491262918)
2020.06.26 12:35:31 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (27,-1491262918)
2020.06.26 12:35:31 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 12:35:31 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 12:35:31 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 12:35:31 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 12:36:35 [INFO] provingground.learning.ExpressionEval.initMap:116:23 - Computing initial map with 128151 atoms
2020.06.26 12:36:38 [INFO] provingground.learning.ExprCalc.finalVec:664:22 - Computing final vector, with maximum time Some(60000), exponent: 0.5, decay: 1.0
2020.06.26 12:36:38 [INFO] provingground.learning.ExprCalc.finalVec:665:22 - Number of equations: 93017
2020.06.26 12:37:12 [INFO] provingground.learning.ExprCalc.stableVec:646:46 - completed 2 steps
2020.06.26 12:37:39 [ERROR] provingground.learning.ExprCalc.stableVec:643:25 - Timeout for stable vector after 10 steps
2020.06.26 12:39:39 [INFO] provingground.learning.HoTTBot.$anonfun:380:26 - Results: 5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.5606711832388727E-4; statement weight 1.8671988322998133E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.5704119932820526E-4; statement weight 5.990984203730346E-8
Lemma: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best proof: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 3.626250332726503E-6; statement weight 6.118530615721884E-8
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best proof: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 1.590261411523737E-7; statement weight 2.219770551182139E-10
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.5704119932820526E-4; statement weight 5.187381498192234E-8
2020.06.26 12:39:49 [INFO] provingground.learning.HoTTBot.$anonfun:380:26 - Steps (in final state): 4
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best proof: trans with weight 0.05648760134876673; statement weight 5.949603040433638E-12
Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))); best proof: (`$amexpsf :  M) ↦ (((((trans) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$amexpsf)) ((((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)))) with weight 5.1165203070297326E-8; statement weight 2.2316213900836526E-13
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best proof: (left-multiply) (((mul) (m)) (n)) with weight 0.00596756840361327; statement weight 4.5190429851932467E-13
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best proof: (right-multiply) (m) with weight 0.005944953756011577; statement weight 4.495400722961635E-13
2020.06.26 12:52:21 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (28,1328572629)
2020.06.26 12:52:21 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.26 12:52:21 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (28,1328572629)
2020.06.26 12:52:21 [INFO] provingground.learning.HoTTBot.$anonfun:906:24 - excluded lemmas:

2020.06.26 12:52:21 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (29,-871589440)
2020.06.26 12:52:21 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (30,82871295)
2020.06.26 12:52:21 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (31,135349457)
2020.06.26 12:52:21 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (31,135349457)
2020.06.26 12:52:21 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 12:54:05 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.26 12:54:05 [INFO] provingground.learning.HoTTBot.$anonfun:1014:22 - previous special init states are 2
2020.06.26 12:56:20 [INFO] provingground.learning.HoTTBot.$anonfun:1017:22 - Using 251659 equation nodes for base states
2020.06.26 12:56:20 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.26 12:56:20 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 12:56:20 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 12:56:59 [INFO] provingground.learning.ExpressionEval.initMap:116:23 - Computing initial map with 192236 atoms
2020.06.26 12:56:59 [INFO] provingground.learning.ExpressionEval.initMap:116:23 - Computing initial map with 192236 atoms
2020.06.26 14:35:29 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TautologyInitState], id: (1,-384837536), content:
TautologyInitState(TermState([m : 0.14285714285714285, sym : 0.14285714285714285, ((mul) (m)) (n) : 0.14285714285714285, refl : 0.14285714285714285, mul : 0.14285714285714285, n : 0.14285714285714285, trans : 0.14285714285714285],[M : 1.0],Vector(),[],[],Empty))
2020.06.26 14:35:30 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (2,1588327529), content:
SpecialInitState(TermState([trans : 0.9, sym : 0.1],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.05,Some(TermGenParams(0.0,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.26 14:35:30 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (3,246182078), content:
SpecialInitState(TermState([left-multiply : 0.2, right-multiply : 0.2, ((mul) (m)) (n) : 0.2, m : 0.2, n : 0.2],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.5,Some(TermGenParams(0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.26 14:35:29 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.LocalProver], id: (4,582823858), content:
LocalProver(TermState([m : 0.08333333333333333, left-multiply : 0.08333333333333333, eqM : 0.08333333333333333, mul : 0.08333333333333333, n : 0.08333333333333333, trans : 0.08333333333333333, sym : 0.08333333333333333, ass1 : 0.08333333333333333, right-multiply : 0.08333333333333333, ass2 : 0.08333333333333333, refl : 0.08333333333333333, ((mul) (m)) (n) : 0.08333333333333333],[M : 1.0],Vector(),[],[((eqM) (((mul) (m)) (n))) (((mul) (n)) (m)) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0,Some(500000))
2020.06.26 14:35:30 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.LocalProver]
2020.06.26 14:35:44 [INFO] provingground.learning.ExpressionEval.initMap:117:24 - Computing initial map with 5805 atoms
2020.06.26 14:35:44 [INFO] provingground.learning.ExpressionEval.initMap:119:24 - Computed initial values
2020.06.26 14:35:44 [INFO] provingground.learning.ExpressionEval.initMap:121:24 - Computed vector for map, size 1068
2020.06.26 14:35:44 [INFO] provingground.learning.ExpressionEval.initMap:122:24 - Zero initial values are 4570
2020.06.26 14:35:44 [INFO] provingground.learning.ExpressionEval.initMap:124:24 - Computed map
2020.06.26 14:35:44 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (5,1405977443), content:
provingground.learning.ExpressionEval$$anon$2@53cd8363
2020.06.26 14:35:44 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 14:35:44 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 14:35:44 [INFO] provingground.learning.HoTTBot.expEvToFinalState:476:26 - computing final state
2020.06.26 14:35:44 [INFO] provingground.learning.ExprCalc.finalVec:673:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 14:35:44 [INFO] provingground.learning.ExprCalc.finalVec:674:22 - Number of equations: 4128
2020.06.26 14:35:45 [INFO] provingground.learning.ExprCalc.stableVec:655:46 - completed 2 steps
2020.06.26 14:35:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (6,-1664112044)
2020.06.26 14:35:45 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 14:35:45 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 14:35:45 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 14:35:47 [INFO] provingground.learning.ExpressionEval.initMap:117:24 - Computing initial map with 3877 atoms
2020.06.26 14:35:47 [INFO] provingground.learning.ExpressionEval.initMap:119:24 - Computed initial values
2020.06.26 14:35:47 [INFO] provingground.learning.ExpressionEval.initMap:121:24 - Computed vector for map, size 552
2020.06.26 14:35:47 [INFO] provingground.learning.ExpressionEval.initMap:122:24 - Zero initial values are 3147
2020.06.26 14:35:47 [INFO] provingground.learning.ExpressionEval.initMap:124:24 - Computed map
2020.06.26 14:35:47 [INFO] provingground.learning.ExprCalc.finalVec:673:22 - Computing final vector, with maximum time Some(60000), exponent: 0.5, decay: 1.0
2020.06.26 14:35:47 [INFO] provingground.learning.ExprCalc.finalVec:674:22 - Number of equations: 2882
2020.06.26 14:35:47 [INFO] provingground.learning.ExprCalc.stableVec:655:46 - completed 2 steps
2020.06.26 14:35:48 [INFO] provingground.learning.HoTTBot.$anonfun:380:26 - Results: 3
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.666676177661691E-4; statement weight 4.922526522818089E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.6875890673843706E-4; statement weight 3.283350224245018E-7
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.6875890673843706E-4; statement weight 2.901648730630753E-7
2020.06.26 14:35:49 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (7,1645406931)
2020.06.26 14:35:48 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.26 14:35:48 [INFO] provingground.learning.HoTTBot.$anonfun:906:24 - excluded lemmas:

2020.06.26 14:35:48 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (8,-1445828818)
2020.06.26 14:35:48 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (9,-962844701)
2020.06.26 14:35:48 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (10,1833728595)
2020.06.26 14:35:49 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 14:35:51 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 14:35:51 [INFO] provingground.learning.ExpressionEval.initMap:117:24 - Computing initial map with 5210 atoms
2020.06.26 14:35:51 [INFO] provingground.learning.ExpressionEval.initMap:119:24 - Computed initial values
2020.06.26 14:35:51 [INFO] provingground.learning.ExpressionEval.initMap:121:24 - Computed vector for map, size 742
2020.06.26 14:35:51 [INFO] provingground.learning.ExpressionEval.initMap:122:24 - Zero initial values are 4066
2020.06.26 14:35:51 [INFO] provingground.learning.ExpressionEval.initMap:124:24 - Computed map
2020.06.26 14:35:51 [INFO] provingground.learning.HoTTBot.baseState:946:16 - Computed expression evaluator
2020.06.26 14:35:51 [INFO] provingground.learning.ExprCalc.finalVec:673:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 14:35:51 [INFO] provingground.learning.ExprCalc.finalVec:674:22 - Number of equations: 3740
2020.06.26 14:35:51 [INFO] provingground.learning.ExprCalc.stableVec:655:46 - completed 2 steps
2020.06.26 14:35:53 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (11,-772975359)
2020.06.26 14:35:53 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 14:35:53 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.26 14:35:53 [INFO] provingground.learning.HoTTBot.$anonfun:1014:22 - previous special init states are 2
2020.06.26 14:35:55 [INFO] provingground.learning.HoTTBot.$anonfun:1017:22 - Using 6777 equation nodes for base states
2020.06.26 14:35:55 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.26 14:35:55 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 14:35:55 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 14:35:55 [INFO] provingground.learning.ExpressionEval.initMap:117:24 - Computing initial map with 5182 atoms
2020.06.26 14:35:55 [INFO] provingground.learning.ExpressionEval.initMap:117:24 - Computing initial map with 5182 atoms
2020.06.26 14:35:55 [INFO] provingground.learning.ExpressionEval.initMap:119:24 - Computed initial values
2020.06.26 14:35:55 [INFO] provingground.learning.ExpressionEval.initMap:119:24 - Computed initial values
2020.06.26 14:35:55 [INFO] provingground.learning.ExpressionEval.initMap:121:24 - Computed vector for map, size 705
2020.06.26 14:35:55 [INFO] provingground.learning.ExpressionEval.initMap:121:24 - Computed vector for map, size 698
2020.06.26 14:35:55 [INFO] provingground.learning.ExpressionEval.initMap:122:24 - Zero initial values are 4060
2020.06.26 14:35:55 [INFO] provingground.learning.ExpressionEval.initMap:122:24 - Zero initial values are 4061
2020.06.26 14:35:55 [INFO] provingground.learning.ExpressionEval.initMap:124:24 - Computed map
2020.06.26 14:35:55 [INFO] provingground.learning.ExpressionEval.initMap:124:24 - Computed map
2020.06.26 14:35:55 [INFO] provingground.learning.HoTTBot.baseState:946:16 - Computed expression evaluator
2020.06.26 14:35:55 [INFO] provingground.learning.HoTTBot.baseState:946:16 - Computed expression evaluator
2020.06.26 14:35:55 [INFO] provingground.learning.ExprCalc.finalVec:673:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 14:35:55 [INFO] provingground.learning.ExprCalc.finalVec:673:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 14:35:55 [INFO] provingground.learning.ExprCalc.finalVec:674:22 - Number of equations: 3733
2020.06.26 14:35:55 [INFO] provingground.learning.ExprCalc.finalVec:674:22 - Number of equations: 3733
2020.06.26 14:35:55 [INFO] provingground.learning.ExprCalc.stableVec:655:46 - completed 2 steps
2020.06.26 14:35:55 [INFO] provingground.learning.ExprCalc.stableVec:655:46 - completed 2 steps
2020.06.26 14:35:56 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (12,412426767)
2020.06.26 14:35:56 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.26 14:35:57 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (13,-1927624303)
2020.06.26 14:35:57 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.26 14:35:57 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (14,-1666923435), content:
TangentBaseCompleted
2020.06.26 14:35:57 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.26 14:35:57 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.26 14:35:57 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 14:35:57 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 14:35:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.26 14:35:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 14:35:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 14:35:59 [INFO] provingground.learning.HoTTBot.$anonfun:1212:26 - generating equations with 3 base states and 18 lemmas (before pruning)
2020.06.26 14:35:59 [INFO] provingground.learning.HoTTBot.$anonfun:1220:26 - Tangent lemmas (used with bases below): 3
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.040700000848968604)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),0.001214698356305945)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),0.001114032298292804)
2020.06.26 14:35:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.26 14:35:59 [INFO] provingground.learning.HoTTBot.$anonfun:1234:28 - Terms in base (used with tangents above): 3
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.04043963963974665
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.0054346766512649095
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.005406533658851866
2020.06.26 14:35:59 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.03816804361515053
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.008673894410700302
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.008367544069125507
2020.06.26 14:35:59 [INFO] provingground.learning.HoTTBot.$anonfun:1253:28 - Inference by unified applications, triples and weights (for this base state)
(0.04043963963974665, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0054346766512649095, 0.040700000848968604, 2.2119134432035167E-4) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.005406533658851866, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 14:36:00 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 14:36:01 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 14:36:01 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 4.0E-5
2020.06.26 14:36:01 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.26 14:36:05 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 4, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.26 14:36:06 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 4, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.26 14:36:06 [INFO] provingground.learning.HoTTBot.$anonfun:1272:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.04043963963974665

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap((mul) (m)) ∈ Funcs))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0054346766512649095
P₁(((mul) (m)) (n) ∈ Terms) -> 0.04069521827206224
P₁((mul) (m) ∈ Terms) -> 0.005406533658851866
P₁(m ∈ Terms) -> 0.04043963963974665
P₁(n ∈ Terms) -> 0.04043963963974665
P₁(left-multiply ∈ Terms) -> 0.04043963963974665

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.005406533658851866
P₁(m ∈ Terms) -> 0.04043963963974665
P₁(right-multiply ∈ Terms) -> 0.04043963963974665


2020.06.26 14:36:06 [INFO] provingground.learning.HoTTBot.$anonfun:1234:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.05031952815190707
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.05031952815190707
2020.06.26 14:36:06 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.04862704546996386
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.010795741213063497
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.010402812080231564
2020.06.26 14:36:06 [INFO] provingground.learning.HoTTBot.$anonfun:1253:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.05031952815190707, 0.040700000848968604, 0.0020480048385023175) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.05031952815190707, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 14:36:08 [INFO] provingground.learning.HoTTBot.$anonfun:1272:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.05031952815190707
P₁(((mul) (m)) (n) ∈ Terms) -> 0.05335038946906504
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.05335038946906504
P₁(n ∈ Terms) -> 0.05335038946906504
P₁(left-multiply ∈ Terms) -> 0.05335038946906504

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.05031952815190707
P₁(m ∈ Terms) -> 0.05335038946906504
P₁(right-multiply ∈ Terms) -> 0.05335038946906504


2020.06.26 14:36:08 [INFO] provingground.learning.HoTTBot.$anonfun:1234:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.45000000000000007
2020.06.26 14:36:08 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.09114656135389602
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0202355433962171
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.019499036808838258
2020.06.26 14:36:08 [INFO] provingground.learning.HoTTBot.$anonfun:1253:28 - Inference by unified applications, triples and weights (for this base state)
(0.45000000000000007, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.040700000848968604, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.26 14:36:09 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 4, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.26 14:36:09 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.26 14:36:09 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 1.6000000000000004E-6
2020.06.26 14:36:08 [INFO] provingground.learning.HoTTBot.$anonfun:1272:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.45000000000000007

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.26 14:36:11 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 3.2000000000000006E-7; running again
2020.06.26 14:36:13 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 6.400000000000002E-8; running again
2020.06.26 14:36:15 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 1.2800000000000004E-8; running again
2020.06.26 14:36:17 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.5600000000000007E-9; running again
2020.06.26 14:36:19 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 5.120000000000001E-10; running again
2020.06.26 14:36:19 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 5.120000000000001E-10
2020.06.26 14:36:21 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,1141163507)
2020.06.26 14:36:21 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,1141163507)
2020.06.26 14:36:21 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.26 14:36:21 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.26 14:36:58 [INFO] provingground.learning.ExpressionEval.initMap:117:24 - Computing initial map with 19563 atoms
2020.06.26 14:36:58 [INFO] provingground.learning.ExpressionEval.initMap:119:24 - Computed initial values
2020.06.26 14:36:58 [INFO] provingground.learning.ExpressionEval.initMap:121:24 - Computed vector for map, size 2761
2020.06.26 14:36:58 [INFO] provingground.learning.ExpressionEval.initMap:122:24 - Zero initial values are 15326
2020.06.26 14:36:58 [INFO] provingground.learning.ExpressionEval.initMap:124:24 - Computed map
2020.06.26 14:36:58 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1576663133), content:
provingground.learning.ExpressionEval$$anon$2@5df9f85d
2020.06.26 14:36:58 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1576663133)
2020.06.26 14:36:58 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 14:36:58 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.26 14:36:58 [INFO] provingground.learning.HoTTBot.expEvToFinalState:476:26 - computing final state
2020.06.26 14:36:58 [INFO] provingground.learning.ExprCalc.finalVec:673:22 - Computing final vector, with maximum time Some(500000), exponent: 0.5, decay: 1.0
2020.06.26 14:36:58 [INFO] provingground.learning.ExprCalc.finalVec:674:22 - Number of equations: 14279
2020.06.26 14:37:00 [INFO] provingground.learning.ExprCalc.stableVec:655:46 - completed 2 steps
2020.06.26 14:37:04 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,581236972)
2020.06.26 14:37:04 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,581236972)
2020.06.26 14:37:04 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 14:37:04 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 14:37:04 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 14:37:04 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.26 14:37:23 [INFO] provingground.learning.ExpressionEval.initMap:117:24 - Computing initial map with 25787 atoms
2020.06.26 14:37:23 [INFO] provingground.learning.ExpressionEval.initMap:119:24 - Computed initial values
2020.06.26 14:37:23 [INFO] provingground.learning.ExpressionEval.initMap:121:24 - Computed vector for map, size 4080
2020.06.26 14:37:23 [INFO] provingground.learning.ExpressionEval.initMap:122:24 - Zero initial values are 20220
2020.06.26 14:37:23 [INFO] provingground.learning.ExpressionEval.initMap:124:24 - Computed map
2020.06.26 14:37:23 [INFO] provingground.learning.ExprCalc.finalVec:673:22 - Computing final vector, with maximum time Some(60000), exponent: 0.5, decay: 1.0
2020.06.26 14:37:23 [INFO] provingground.learning.ExprCalc.finalVec:674:22 - Number of equations: 18676
2020.06.26 14:37:29 [INFO] provingground.learning.ExprCalc.stableVec:655:46 - completed 2 steps
2020.06.26 14:37:42 [INFO] provingground.learning.HoTTBot.$anonfun:380:26 - Steps (in final state): 3
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best proof: trans with weight 0.05649437698358171; statement weight 5.944062904839253E-12
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best proof: (left-multiply) (((mul) (m)) (n)) with weight 0.005971859364160798; statement weight 4.561625690383875E-13
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best proof: (right-multiply) (m) with weight 0.005949184168104393; statement weight 4.5358737659944094E-13
2020.06.26 14:37:42 [INFO] provingground.learning.HoTTBot.$anonfun:380:26 - Results: 5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.565980368125865E-4; statement weight 1.871203887165631E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.5757607259762927E-4; statement weight 6.015493085387075E-8
Lemma: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best proof: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 3.6357335767957786E-6; statement weight 6.143877824764005E-8
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best proof: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 1.5966674388756185E-7; statement weight 2.2332562602499821E-10
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.5757607259762927E-4; statement weight 5.2078036146675147E-8
2020.06.26 14:37:52 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-1173733910)
2020.06.26 14:37:52 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.26 14:37:52 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-1173733910)
2020.06.26 14:37:52 [INFO] provingground.learning.HoTTBot.$anonfun:906:24 - excluded lemmas:

2020.06.26 14:37:52 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (19,-334754299)
2020.06.26 14:37:52 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (20,-1514984774)
2020.06.26 14:37:52 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,1200301437)
2020.06.26 14:37:52 [INFO] provingground.learning.HoTTBot.scribeLog:1947:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,1200301437)
2020.06.26 14:37:52 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.26 14:38:11 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.26 14:38:11 [INFO] provingground.learning.HoTTBot.$anonfun:1014:22 - previous special init states are 2
2020.06.26 14:38:30 [INFO] provingground.learning.HoTTBot.$anonfun:1017:22 - Using 62570 equation nodes for base states
2020.06.26 14:38:30 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.26 14:38:30 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 14:38:30 [INFO] provingground.learning.HoTTBot.baseState:934:16 - Computing base state
2020.06.26 14:38:37 [INFO] provingground.learning.ExpressionEval.initMap:117:24 - Computing initial map with 48587 atoms
2020.06.26 14:38:37 [INFO] provingground.learning.ExpressionEval.initMap:117:24 - Computing initial map with 48587 atoms

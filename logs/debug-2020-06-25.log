2020.06.25 06:22:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TautologyInitState], id: (1,-384837536), content:
TautologyInitState(TermState([m : 0.14285714285714285, sym : 0.14285714285714285, ((mul) (m)) (n) : 0.14285714285714285, refl : 0.14285714285714285, mul : 0.14285714285714285, n : 0.14285714285714285, trans : 0.14285714285714285],[M : 1.0],Vector(),[],[],Empty))
2020.06.25 06:22:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (2,1588327529), content:
SpecialInitState(TermState([trans : 0.9, sym : 0.1],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.05,Some(TermGenParams(0.0,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 06:22:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (3,246182078), content:
SpecialInitState(TermState([left-multiply : 0.2, right-multiply : 0.2, ((mul) (m)) (n) : 0.2, m : 0.2, n : 0.2],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.5,Some(TermGenParams(0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 06:22:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.LocalProver], id: (4,582823858), content:
LocalProver(TermState([m : 0.08333333333333333, left-multiply : 0.08333333333333333, eqM : 0.08333333333333333, mul : 0.08333333333333333, n : 0.08333333333333333, trans : 0.08333333333333333, sym : 0.08333333333333333, ass1 : 0.08333333333333333, right-multiply : 0.08333333333333333, ass2 : 0.08333333333333333, refl : 0.08333333333333333, ((mul) (m)) (n) : 0.08333333333333333],[M : 1.0],Vector(),[],[((eqM) (((mul) (m)) (n))) (((mul) (n)) (m)) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0,Some(500000))
2020.06.25 06:22:12 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.LocalProver]
2020.06.25 06:22:27 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (5,741125421), content:
provingground.learning.ExpressionEval$$anon$2@2c2cad2d
2020.06.25 06:22:27 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 06:22:28 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 06:22:29 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (6,-1664112044)
2020.06.25 06:22:29 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 06:22:29 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 06:22:29 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 06:22:31 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 3
()
()
()
2020.06.25 06:22:32 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (7,1645406931)
2020.06.25 06:22:32 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 06:22:32 [INFO] provingground.learning.HoTTBot.$anonfun:898:24 - excluded lemmas:

2020.06.25 06:22:32 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (8,-1445828818)
2020.06.25 06:22:32 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (9,-962844701)
2020.06.25 06:22:32 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (10,1833728595)
2020.06.25 06:22:32 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 06:22:35 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (11,368099790)
2020.06.25 06:22:35 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 06:22:35 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 06:22:35 [INFO] provingground.learning.HoTTBot.$anonfun:1005:22 - previous special init states are 2
2020.06.25 06:22:35 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 06:22:38 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (12,412426767)
2020.06.25 06:22:38 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 06:22:38 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (13,-2086306360)
2020.06.25 06:22:38 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 06:22:38 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (14,-1666923435), content:
TangentBaseCompleted
2020.06.25 06:22:38 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 06:22:38 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 06:22:42 [INFO] provingground.learning.HoTTBot.$anonfun:1201:26 - generating equations with 3 base states and 18 lemmas (before pruning)
2020.06.25 06:22:42 [INFO] provingground.learning.HoTTBot.$anonfun:1209:26 - Tangent lemmas (used with bases below): 3
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.040700000848968604)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),0.001214698356305945)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),0.001114032298292804)
2020.06.25 06:22:42 [INFO] provingground.learning.HoTTBot.$anonfun:1223:28 - Terms in base (used with tangents above): 3
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.053326178457998585
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.002437424090839206
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.002437424090839206
2020.06.25 06:22:42 [INFO] provingground.learning.HoTTBot.$anonfun:1235:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.050046293108537594
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.011126917673166644
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.010695179485308265
2020.06.25 06:22:42 [INFO] provingground.learning.HoTTBot.$anonfun:1242:28 - Inference by unified applications, triples and weights (for this base state)
(0.053326178457998585, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.040700000848968604, 9.920316256645221E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 06:22:43 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.0E-6
2020.06.25 06:22:43 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.0E-6
2020.06.25 06:22:45 [INFO] provingground.learning.HoTTBot.$anonfun:1261:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.053326178457998585

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap((mul) (m)) ∈ Funcs))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.002437424090839206
P₁(((mul) (m)) (n) ∈ Terms) -> 0.053326178457998585
P₁((mul) (m) ∈ Terms) -> 0.001286599861208855
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(n ∈ Terms) -> 0.053326178457998585
P₁(left-multiply ∈ Terms) -> 0.053326178457998585

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.002437424090839206
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(right-multiply ∈ Terms) -> 0.053326178457998585


2020.06.25 06:22:45 [INFO] provingground.learning.HoTTBot.$anonfun:1223:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.016270597645731934
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.016270597645731934
2020.06.25 06:22:45 [INFO] provingground.learning.HoTTBot.$anonfun:1235:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.08055093331491427
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.017883196935657784
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.01723230794846274
2020.06.25 06:22:45 [INFO] provingground.learning.HoTTBot.$anonfun:1242:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.040700000848968604, 6.622133379945163E-4) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 06:22:48 [INFO] provingground.learning.HoTTBot.$anonfun:1261:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.016270597645731934
P₁(((mul) (m)) (n) ∈ Terms) -> 0.08837517523251155
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(n ∈ Terms) -> 0.08837517523251155
P₁(left-multiply ∈ Terms) -> 0.08837517523251155

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.016270597645731934
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(right-multiply ∈ Terms) -> 0.08837517523251155


2020.06.25 06:22:48 [INFO] provingground.learning.HoTTBot.$anonfun:1223:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.45000000000000007
2020.06.25 06:22:48 [INFO] provingground.learning.HoTTBot.$anonfun:1235:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.09114656135389602
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0202355433962171
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.019499036808838258
2020.06.25 06:22:48 [INFO] provingground.learning.HoTTBot.$anonfun:1242:28 - Inference by unified applications, triples and weights (for this base state)
(0.45000000000000007, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.040700000848968604, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 06:22:48 [INFO] provingground.learning.HoTTBot.$anonfun:1261:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.45000000000000007

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 06:22:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.52587890625E-11
2020.06.25 06:23:00 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-406838919)
2020.06.25 06:23:00 [INFO] provingground.learning.HoTTBot.scribeLog:1936:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-406838919)
2020.06.25 06:23:00 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 06:23:00 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 06:23:35 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1809209328), content:
provingground.learning.ExpressionEval$$anon$2@6bd657f0
2020.06.25 06:23:35 [INFO] provingground.learning.HoTTBot.scribeLog:1936:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1809209328)
2020.06.25 06:23:35 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 06:23:35 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 08:08:22 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TautologyInitState], id: (1,-384837536), content:
TautologyInitState(TermState([m : 0.14285714285714285, sym : 0.14285714285714285, ((mul) (m)) (n) : 0.14285714285714285, refl : 0.14285714285714285, mul : 0.14285714285714285, n : 0.14285714285714285, trans : 0.14285714285714285],[M : 1.0],Vector(),[],[],Empty))
2020.06.25 08:08:22 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (2,1588327529), content:
SpecialInitState(TermState([trans : 0.9, sym : 0.1],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.05,Some(TermGenParams(0.0,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 08:08:22 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (3,246182078), content:
SpecialInitState(TermState([left-multiply : 0.2, right-multiply : 0.2, ((mul) (m)) (n) : 0.2, m : 0.2, n : 0.2],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.5,Some(TermGenParams(0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 08:08:22 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.LocalProver], id: (4,582823858), content:
LocalProver(TermState([m : 0.08333333333333333, left-multiply : 0.08333333333333333, eqM : 0.08333333333333333, mul : 0.08333333333333333, n : 0.08333333333333333, trans : 0.08333333333333333, sym : 0.08333333333333333, ass1 : 0.08333333333333333, right-multiply : 0.08333333333333333, ass2 : 0.08333333333333333, refl : 0.08333333333333333, ((mul) (m)) (n) : 0.08333333333333333],[M : 1.0],Vector(),[],[((eqM) (((mul) (m)) (n))) (((mul) (n)) (m)) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0,Some(500000))
2020.06.25 08:08:22 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.LocalProver]
2020.06.25 08:08:38 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (5,420427892), content:
provingground.learning.ExpressionEval$$anon$2@190f3874
2020.06.25 08:08:38 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 08:08:38 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 08:08:38 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 08:08:39 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 08:08:39 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (6,-1664112044)
2020.06.25 08:08:39 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 08:08:39 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 08:08:39 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 08:08:42 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 3
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.666676177661691E-4; statement weight 4.922526522818089E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.6875890673843706E-4; statement weight 3.283350224245018E-7
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.6875890673843706E-4; statement weight 2.901648730630753E-7
2020.06.25 08:08:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 08:08:43 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (7,1645406931)
2020.06.25 08:08:42 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 08:08:43 [INFO] provingground.learning.HoTTBot.$anonfun:901:24 - excluded lemmas:

2020.06.25 08:08:43 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (8,-1445828818)
2020.06.25 08:08:43 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (9,-962844701)
2020.06.25 08:08:43 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (10,1833728595)
2020.06.25 08:08:43 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 08:08:45 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 08:08:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (11,368099790)
2020.06.25 08:08:46 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 08:08:47 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 08:08:47 [INFO] provingground.learning.HoTTBot.$anonfun:1008:22 - previous special init states are 2
2020.06.25 08:08:47 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 08:08:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 08:08:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 08:08:49 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (12,412426767)
2020.06.25 08:08:49 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 08:08:49 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (13,-2086306360)
2020.06.25 08:08:49 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 08:08:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (14,-1666923435), content:
TangentBaseCompleted
2020.06.25 08:08:49 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 08:08:49 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 08:08:52 [INFO] provingground.learning.HoTTBot.$anonfun:1204:26 - generating equations with 3 base states and 18 lemmas (before pruning)
2020.06.25 08:08:52 [INFO] provingground.learning.HoTTBot.$anonfun:1212:26 - Tangent lemmas (used with bases below): 3
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.040700000848968604)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),0.001214698356305945)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),0.001114032298292804)
2020.06.25 08:08:53 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.0E-6
2020.06.25 08:08:52 [INFO] provingground.learning.HoTTBot.$anonfun:1226:28 - Terms in base (used with tangents above): 3
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.053326178457998585
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.002437424090839206
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.002437424090839206
2020.06.25 08:08:52 [INFO] provingground.learning.HoTTBot.$anonfun:1238:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.050046293108537594
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.011126917673166644
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.010695179485308265
2020.06.25 08:08:52 [INFO] provingground.learning.HoTTBot.$anonfun:1245:28 - Inference by unified applications, triples and weights (for this base state)
(0.053326178457998585, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.040700000848968604, 9.920316256645221E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 08:08:53 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.0E-6
2020.06.25 08:08:57 [INFO] provingground.learning.HoTTBot.$anonfun:1264:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.053326178457998585

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap((mul) (m)) ∈ Funcs))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.002437424090839206
P₁(((mul) (m)) (n) ∈ Terms) -> 0.053326178457998585
P₁((mul) (m) ∈ Terms) -> 0.001286599861208855
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(n ∈ Terms) -> 0.053326178457998585
P₁(left-multiply ∈ Terms) -> 0.053326178457998585

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.002437424090839206
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(right-multiply ∈ Terms) -> 0.053326178457998585


2020.06.25 08:08:57 [INFO] provingground.learning.HoTTBot.$anonfun:1226:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.016270597645731934
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.016270597645731934
2020.06.25 08:08:57 [INFO] provingground.learning.HoTTBot.$anonfun:1238:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.08055093331491427
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.017883196935657784
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.01723230794846274
2020.06.25 08:08:57 [INFO] provingground.learning.HoTTBot.$anonfun:1245:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.040700000848968604, 6.622133379945163E-4) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 08:08:58 [INFO] provingground.learning.HoTTBot.$anonfun:1264:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.016270597645731934
P₁(((mul) (m)) (n) ∈ Terms) -> 0.08837517523251155
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(n ∈ Terms) -> 0.08837517523251155
P₁(left-multiply ∈ Terms) -> 0.08837517523251155

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.016270597645731934
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(right-multiply ∈ Terms) -> 0.08837517523251155


2020.06.25 08:08:58 [INFO] provingground.learning.HoTTBot.$anonfun:1226:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.45000000000000007
2020.06.25 08:08:58 [INFO] provingground.learning.HoTTBot.$anonfun:1238:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.09114656135389602
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0202355433962171
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.019499036808838258
2020.06.25 08:08:58 [INFO] provingground.learning.HoTTBot.$anonfun:1245:28 - Inference by unified applications, triples and weights (for this base state)
(0.45000000000000007, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.040700000848968604, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 08:08:58 [INFO] provingground.learning.HoTTBot.$anonfun:1264:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.45000000000000007

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 08:09:08 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.52587890625E-11
2020.06.25 08:09:09 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-1492985030)
2020.06.25 08:09:09 [INFO] provingground.learning.HoTTBot.scribeLog:1939:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-1492985030)
2020.06.25 08:09:09 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 08:09:09 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 08:09:44 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1010987595), content:
provingground.learning.ExpressionEval$$anon$2@3c42724b
2020.06.25 08:09:44 [INFO] provingground.learning.HoTTBot.scribeLog:1939:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1010987595)
2020.06.25 08:09:44 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 08:09:44 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 08:09:44 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 08:09:46 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 08:09:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 102 steps
2020.06.25 08:10:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 202 steps
2020.06.25 08:10:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 302 steps
2020.06.25 08:10:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 402 steps
2020.06.25 08:10:20 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 502 steps
2020.06.25 08:10:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 602 steps
2020.06.25 08:10:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 702 steps
2020.06.25 08:10:40 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 802 steps
2020.06.25 08:10:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 902 steps
2020.06.25 08:10:53 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1002 steps
2020.06.25 08:11:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1102 steps
2020.06.25 08:11:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1202 steps
2020.06.25 08:11:13 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1302 steps
2020.06.25 08:11:20 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1402 steps
2020.06.25 08:11:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1502 steps
2020.06.25 08:11:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1602 steps
2020.06.25 08:11:40 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1702 steps
2020.06.25 08:11:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1802 steps
2020.06.25 08:11:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1902 steps
2020.06.25 08:12:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2002 steps
2020.06.25 08:12:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2102 steps
2020.06.25 08:12:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2202 steps
2020.06.25 08:12:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2302 steps
2020.06.25 08:12:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2402 steps
2020.06.25 08:12:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2502 steps
2020.06.25 08:12:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2602 steps
2020.06.25 08:12:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2702 steps
2020.06.25 08:12:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2802 steps
2020.06.25 08:13:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2902 steps
2020.06.25 08:13:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3002 steps
2020.06.25 08:13:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3102 steps
2020.06.25 08:13:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3202 steps
2020.06.25 08:13:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3302 steps
2020.06.25 08:13:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3402 steps
2020.06.25 08:13:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3502 steps
2020.06.25 08:13:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3602 steps
2020.06.25 08:13:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3702 steps
2020.06.25 08:14:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3802 steps
2020.06.25 08:14:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3902 steps
2020.06.25 08:14:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4002 steps
2020.06.25 08:14:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4102 steps
2020.06.25 08:14:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4202 steps
2020.06.25 08:14:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4302 steps
2020.06.25 08:14:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4402 steps
2020.06.25 08:14:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4502 steps
2020.06.25 08:14:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4602 steps
2020.06.25 08:15:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4702 steps
2020.06.25 08:15:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4802 steps
2020.06.25 08:15:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4902 steps
2020.06.25 08:15:22 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5002 steps
2020.06.25 08:15:29 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5102 steps
2020.06.25 08:15:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5202 steps
2020.06.25 08:15:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5302 steps
2020.06.25 08:15:49 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5402 steps
2020.06.25 08:15:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5502 steps
2020.06.25 08:16:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5602 steps
2020.06.25 08:16:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5702 steps
2020.06.25 08:16:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5802 steps
2020.06.25 08:16:22 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5902 steps
2020.06.25 08:16:29 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6002 steps
2020.06.25 08:16:36 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6102 steps
2020.06.25 08:16:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6202 steps
2020.06.25 08:16:49 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6302 steps
2020.06.25 08:16:56 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6402 steps
2020.06.25 08:17:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6502 steps
2020.06.25 08:17:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6602 steps
2020.06.25 08:17:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6702 steps
2020.06.25 08:17:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6802 steps
2020.06.25 08:17:29 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6902 steps
2020.06.25 08:17:36 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7002 steps
2020.06.25 08:17:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7102 steps
2020.06.25 08:17:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7202 steps
2020.06.25 08:17:56 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7302 steps
2020.06.25 08:18:03 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7402 steps
2020.06.25 08:18:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7502 steps
2020.06.25 08:18:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7602 steps
2020.06.25 08:18:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7702 steps
2020.06.25 08:18:30 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7802 steps
2020.06.25 08:18:37 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7902 steps
2020.06.25 08:18:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8002 steps
2020.06.25 08:18:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8102 steps
2020.06.25 08:18:57 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8202 steps
2020.06.25 08:19:04 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8302 steps
2020.06.25 08:19:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8402 steps
2020.06.25 08:19:17 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8502 steps
2020.06.25 08:19:24 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8602 steps
2020.06.25 08:19:31 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8702 steps
2020.06.25 08:19:38 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8802 steps
2020.06.25 08:19:44 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8902 steps
2020.06.25 08:19:51 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 9002 steps
2020.06.25 08:19:58 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 9102 steps

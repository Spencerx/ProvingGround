2020.06.25 06:22:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TautologyInitState], id: (1,-384837536), content:
TautologyInitState(TermState([m : 0.14285714285714285, sym : 0.14285714285714285, ((mul) (m)) (n) : 0.14285714285714285, refl : 0.14285714285714285, mul : 0.14285714285714285, n : 0.14285714285714285, trans : 0.14285714285714285],[M : 1.0],Vector(),[],[],Empty))
2020.06.25 06:22:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (2,1588327529), content:
SpecialInitState(TermState([trans : 0.9, sym : 0.1],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.05,Some(TermGenParams(0.0,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 06:22:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (3,246182078), content:
SpecialInitState(TermState([left-multiply : 0.2, right-multiply : 0.2, ((mul) (m)) (n) : 0.2, m : 0.2, n : 0.2],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.5,Some(TermGenParams(0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 06:22:12 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.LocalProver], id: (4,582823858), content:
LocalProver(TermState([m : 0.08333333333333333, left-multiply : 0.08333333333333333, eqM : 0.08333333333333333, mul : 0.08333333333333333, n : 0.08333333333333333, trans : 0.08333333333333333, sym : 0.08333333333333333, ass1 : 0.08333333333333333, right-multiply : 0.08333333333333333, ass2 : 0.08333333333333333, refl : 0.08333333333333333, ((mul) (m)) (n) : 0.08333333333333333],[M : 1.0],Vector(),[],[((eqM) (((mul) (m)) (n))) (((mul) (n)) (m)) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0,Some(500000))
2020.06.25 06:22:12 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.LocalProver]
2020.06.25 06:22:27 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (5,741125421), content:
provingground.learning.ExpressionEval$$anon$2@2c2cad2d
2020.06.25 06:22:27 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 06:22:28 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 06:22:29 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (6,-1664112044)
2020.06.25 06:22:29 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 06:22:29 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 06:22:29 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 06:22:31 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 3
()
()
()
2020.06.25 06:22:32 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (7,1645406931)
2020.06.25 06:22:32 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 06:22:32 [INFO] provingground.learning.HoTTBot.$anonfun:898:24 - excluded lemmas:

2020.06.25 06:22:32 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (8,-1445828818)
2020.06.25 06:22:32 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (9,-962844701)
2020.06.25 06:22:32 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (10,1833728595)
2020.06.25 06:22:32 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 06:22:35 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (11,368099790)
2020.06.25 06:22:35 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 06:22:35 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 06:22:35 [INFO] provingground.learning.HoTTBot.$anonfun:1005:22 - previous special init states are 2
2020.06.25 06:22:35 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 06:22:38 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (12,412426767)
2020.06.25 06:22:38 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 06:22:38 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (13,-2086306360)
2020.06.25 06:22:38 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 06:22:38 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (14,-1666923435), content:
TangentBaseCompleted
2020.06.25 06:22:38 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 06:22:38 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 06:22:42 [INFO] provingground.learning.HoTTBot.$anonfun:1201:26 - generating equations with 3 base states and 18 lemmas (before pruning)
2020.06.25 06:22:42 [INFO] provingground.learning.HoTTBot.$anonfun:1209:26 - Tangent lemmas (used with bases below): 3
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.040700000848968604)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),0.001214698356305945)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),0.001114032298292804)
2020.06.25 06:22:42 [INFO] provingground.learning.HoTTBot.$anonfun:1223:28 - Terms in base (used with tangents above): 3
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.053326178457998585
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.002437424090839206
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.002437424090839206
2020.06.25 06:22:42 [INFO] provingground.learning.HoTTBot.$anonfun:1235:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.050046293108537594
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.011126917673166644
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.010695179485308265
2020.06.25 06:22:42 [INFO] provingground.learning.HoTTBot.$anonfun:1242:28 - Inference by unified applications, triples and weights (for this base state)
(0.053326178457998585, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.040700000848968604, 9.920316256645221E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 06:22:43 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.0E-6
2020.06.25 06:22:43 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.0E-6
2020.06.25 06:22:45 [INFO] provingground.learning.HoTTBot.$anonfun:1261:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.053326178457998585

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap((mul) (m)) ∈ Funcs))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.002437424090839206
P₁(((mul) (m)) (n) ∈ Terms) -> 0.053326178457998585
P₁((mul) (m) ∈ Terms) -> 0.001286599861208855
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(n ∈ Terms) -> 0.053326178457998585
P₁(left-multiply ∈ Terms) -> 0.053326178457998585

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.002437424090839206
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(right-multiply ∈ Terms) -> 0.053326178457998585


2020.06.25 06:22:45 [INFO] provingground.learning.HoTTBot.$anonfun:1223:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.016270597645731934
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.016270597645731934
2020.06.25 06:22:45 [INFO] provingground.learning.HoTTBot.$anonfun:1235:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.08055093331491427
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.017883196935657784
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.01723230794846274
2020.06.25 06:22:45 [INFO] provingground.learning.HoTTBot.$anonfun:1242:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.040700000848968604, 6.622133379945163E-4) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 06:22:48 [INFO] provingground.learning.HoTTBot.$anonfun:1261:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.016270597645731934
P₁(((mul) (m)) (n) ∈ Terms) -> 0.08837517523251155
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(n ∈ Terms) -> 0.08837517523251155
P₁(left-multiply ∈ Terms) -> 0.08837517523251155

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.016270597645731934
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(right-multiply ∈ Terms) -> 0.08837517523251155


2020.06.25 06:22:48 [INFO] provingground.learning.HoTTBot.$anonfun:1223:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.45000000000000007
2020.06.25 06:22:48 [INFO] provingground.learning.HoTTBot.$anonfun:1235:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.09114656135389602
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0202355433962171
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.019499036808838258
2020.06.25 06:22:48 [INFO] provingground.learning.HoTTBot.$anonfun:1242:28 - Inference by unified applications, triples and weights (for this base state)
(0.45000000000000007, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.040700000848968604, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 06:22:48 [INFO] provingground.learning.HoTTBot.$anonfun:1261:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.45000000000000007

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 06:22:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.52587890625E-11
2020.06.25 06:23:00 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-406838919)
2020.06.25 06:23:00 [INFO] provingground.learning.HoTTBot.scribeLog:1936:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-406838919)
2020.06.25 06:23:00 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 06:23:00 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 06:23:35 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1809209328), content:
provingground.learning.ExpressionEval$$anon$2@6bd657f0
2020.06.25 06:23:35 [INFO] provingground.learning.HoTTBot.scribeLog:1936:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1809209328)
2020.06.25 06:23:35 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 06:23:35 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 08:08:22 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TautologyInitState], id: (1,-384837536), content:
TautologyInitState(TermState([m : 0.14285714285714285, sym : 0.14285714285714285, ((mul) (m)) (n) : 0.14285714285714285, refl : 0.14285714285714285, mul : 0.14285714285714285, n : 0.14285714285714285, trans : 0.14285714285714285],[M : 1.0],Vector(),[],[],Empty))
2020.06.25 08:08:22 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (2,1588327529), content:
SpecialInitState(TermState([trans : 0.9, sym : 0.1],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.05,Some(TermGenParams(0.0,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 08:08:22 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (3,246182078), content:
SpecialInitState(TermState([left-multiply : 0.2, right-multiply : 0.2, ((mul) (m)) (n) : 0.2, m : 0.2, n : 0.2],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.5,Some(TermGenParams(0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 08:08:22 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.LocalProver], id: (4,582823858), content:
LocalProver(TermState([m : 0.08333333333333333, left-multiply : 0.08333333333333333, eqM : 0.08333333333333333, mul : 0.08333333333333333, n : 0.08333333333333333, trans : 0.08333333333333333, sym : 0.08333333333333333, ass1 : 0.08333333333333333, right-multiply : 0.08333333333333333, ass2 : 0.08333333333333333, refl : 0.08333333333333333, ((mul) (m)) (n) : 0.08333333333333333],[M : 1.0],Vector(),[],[((eqM) (((mul) (m)) (n))) (((mul) (n)) (m)) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0,Some(500000))
2020.06.25 08:08:22 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.LocalProver]
2020.06.25 08:08:38 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (5,420427892), content:
provingground.learning.ExpressionEval$$anon$2@190f3874
2020.06.25 08:08:38 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 08:08:38 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 08:08:38 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 08:08:39 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 08:08:39 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (6,-1664112044)
2020.06.25 08:08:39 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 08:08:39 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 08:08:39 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 08:08:42 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 3
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.666676177661691E-4; statement weight 4.922526522818089E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.6875890673843706E-4; statement weight 3.283350224245018E-7
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.6875890673843706E-4; statement weight 2.901648730630753E-7
2020.06.25 08:08:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 08:08:43 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (7,1645406931)
2020.06.25 08:08:42 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 08:08:43 [INFO] provingground.learning.HoTTBot.$anonfun:901:24 - excluded lemmas:

2020.06.25 08:08:43 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (8,-1445828818)
2020.06.25 08:08:43 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (9,-962844701)
2020.06.25 08:08:43 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (10,1833728595)
2020.06.25 08:08:43 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 08:08:45 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 08:08:46 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (11,368099790)
2020.06.25 08:08:46 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 08:08:47 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 08:08:47 [INFO] provingground.learning.HoTTBot.$anonfun:1008:22 - previous special init states are 2
2020.06.25 08:08:47 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 08:08:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 08:08:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 08:08:49 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (12,412426767)
2020.06.25 08:08:49 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 08:08:49 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (13,-2086306360)
2020.06.25 08:08:49 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 08:08:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (14,-1666923435), content:
TangentBaseCompleted
2020.06.25 08:08:49 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 08:08:49 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 08:08:52 [INFO] provingground.learning.HoTTBot.$anonfun:1204:26 - generating equations with 3 base states and 18 lemmas (before pruning)
2020.06.25 08:08:52 [INFO] provingground.learning.HoTTBot.$anonfun:1212:26 - Tangent lemmas (used with bases below): 3
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.040700000848968604)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),0.001214698356305945)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),0.001114032298292804)
2020.06.25 08:08:53 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.0E-6
2020.06.25 08:08:52 [INFO] provingground.learning.HoTTBot.$anonfun:1226:28 - Terms in base (used with tangents above): 3
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.053326178457998585
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.002437424090839206
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.002437424090839206
2020.06.25 08:08:52 [INFO] provingground.learning.HoTTBot.$anonfun:1238:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.050046293108537594
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.011126917673166644
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.010695179485308265
2020.06.25 08:08:52 [INFO] provingground.learning.HoTTBot.$anonfun:1245:28 - Inference by unified applications, triples and weights (for this base state)
(0.053326178457998585, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.040700000848968604, 9.920316256645221E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 08:08:53 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.0E-6
2020.06.25 08:08:57 [INFO] provingground.learning.HoTTBot.$anonfun:1264:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.053326178457998585

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap((mul) (m)) ∈ Funcs))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.002437424090839206
P₁(((mul) (m)) (n) ∈ Terms) -> 0.053326178457998585
P₁((mul) (m) ∈ Terms) -> 0.001286599861208855
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(n ∈ Terms) -> 0.053326178457998585
P₁(left-multiply ∈ Terms) -> 0.053326178457998585

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.002437424090839206
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(right-multiply ∈ Terms) -> 0.053326178457998585


2020.06.25 08:08:57 [INFO] provingground.learning.HoTTBot.$anonfun:1226:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.016270597645731934
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.016270597645731934
2020.06.25 08:08:57 [INFO] provingground.learning.HoTTBot.$anonfun:1238:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.08055093331491427
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.017883196935657784
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.01723230794846274
2020.06.25 08:08:57 [INFO] provingground.learning.HoTTBot.$anonfun:1245:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.040700000848968604, 6.622133379945163E-4) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 08:08:58 [INFO] provingground.learning.HoTTBot.$anonfun:1264:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.016270597645731934
P₁(((mul) (m)) (n) ∈ Terms) -> 0.08837517523251155
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(n ∈ Terms) -> 0.08837517523251155
P₁(left-multiply ∈ Terms) -> 0.08837517523251155

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.016270597645731934
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(right-multiply ∈ Terms) -> 0.08837517523251155


2020.06.25 08:08:58 [INFO] provingground.learning.HoTTBot.$anonfun:1226:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.45000000000000007
2020.06.25 08:08:58 [INFO] provingground.learning.HoTTBot.$anonfun:1238:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.09114656135389602
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0202355433962171
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.019499036808838258
2020.06.25 08:08:58 [INFO] provingground.learning.HoTTBot.$anonfun:1245:28 - Inference by unified applications, triples and weights (for this base state)
(0.45000000000000007, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.040700000848968604, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 08:08:58 [INFO] provingground.learning.HoTTBot.$anonfun:1264:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.45000000000000007

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 08:09:08 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.52587890625E-11
2020.06.25 08:09:09 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-1492985030)
2020.06.25 08:09:09 [INFO] provingground.learning.HoTTBot.scribeLog:1939:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-1492985030)
2020.06.25 08:09:09 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 08:09:09 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 08:09:44 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1010987595), content:
provingground.learning.ExpressionEval$$anon$2@3c42724b
2020.06.25 08:09:44 [INFO] provingground.learning.HoTTBot.scribeLog:1939:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1010987595)
2020.06.25 08:09:44 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 08:09:44 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 08:09:44 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 08:09:46 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 08:09:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 102 steps
2020.06.25 08:10:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 202 steps
2020.06.25 08:10:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 302 steps
2020.06.25 08:10:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 402 steps
2020.06.25 08:10:20 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 502 steps
2020.06.25 08:10:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 602 steps
2020.06.25 08:10:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 702 steps
2020.06.25 08:10:40 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 802 steps
2020.06.25 08:10:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 902 steps
2020.06.25 08:10:53 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1002 steps
2020.06.25 08:11:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1102 steps
2020.06.25 08:11:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1202 steps
2020.06.25 08:11:13 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1302 steps
2020.06.25 08:11:20 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1402 steps
2020.06.25 08:11:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1502 steps
2020.06.25 08:11:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1602 steps
2020.06.25 08:11:40 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1702 steps
2020.06.25 08:11:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1802 steps
2020.06.25 08:11:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1902 steps
2020.06.25 08:12:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2002 steps
2020.06.25 08:12:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2102 steps
2020.06.25 08:12:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2202 steps
2020.06.25 08:12:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2302 steps
2020.06.25 08:12:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2402 steps
2020.06.25 08:12:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2502 steps
2020.06.25 08:12:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2602 steps
2020.06.25 08:12:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2702 steps
2020.06.25 08:12:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2802 steps
2020.06.25 08:13:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2902 steps
2020.06.25 08:13:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3002 steps
2020.06.25 08:13:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3102 steps
2020.06.25 08:13:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3202 steps
2020.06.25 08:13:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3302 steps
2020.06.25 08:13:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3402 steps
2020.06.25 08:13:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3502 steps
2020.06.25 08:13:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3602 steps
2020.06.25 08:13:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3702 steps
2020.06.25 08:14:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3802 steps
2020.06.25 08:14:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3902 steps
2020.06.25 08:14:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4002 steps
2020.06.25 08:14:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4102 steps
2020.06.25 08:14:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4202 steps
2020.06.25 08:14:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4302 steps
2020.06.25 08:14:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4402 steps
2020.06.25 08:14:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4502 steps
2020.06.25 08:14:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4602 steps
2020.06.25 08:15:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4702 steps
2020.06.25 08:15:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4802 steps
2020.06.25 08:15:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4902 steps
2020.06.25 08:15:22 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5002 steps
2020.06.25 08:15:29 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5102 steps
2020.06.25 08:15:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5202 steps
2020.06.25 08:15:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5302 steps
2020.06.25 08:15:49 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5402 steps
2020.06.25 08:15:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5502 steps
2020.06.25 08:16:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5602 steps
2020.06.25 08:16:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5702 steps
2020.06.25 08:16:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5802 steps
2020.06.25 08:16:22 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5902 steps
2020.06.25 08:16:29 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6002 steps
2020.06.25 08:16:36 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6102 steps
2020.06.25 08:16:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6202 steps
2020.06.25 08:16:49 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6302 steps
2020.06.25 08:16:56 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6402 steps
2020.06.25 08:17:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6502 steps
2020.06.25 08:17:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6602 steps
2020.06.25 08:17:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6702 steps
2020.06.25 08:17:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6802 steps
2020.06.25 08:17:29 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6902 steps
2020.06.25 08:17:36 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7002 steps
2020.06.25 08:17:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7102 steps
2020.06.25 08:17:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7202 steps
2020.06.25 08:17:56 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7302 steps
2020.06.25 08:18:03 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7402 steps
2020.06.25 08:18:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7502 steps
2020.06.25 08:18:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7602 steps
2020.06.25 08:18:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7702 steps
2020.06.25 08:18:30 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7802 steps
2020.06.25 08:18:37 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7902 steps
2020.06.25 08:18:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8002 steps
2020.06.25 08:18:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8102 steps
2020.06.25 08:18:57 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8202 steps
2020.06.25 08:19:04 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8302 steps
2020.06.25 08:19:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8402 steps
2020.06.25 08:19:17 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8502 steps
2020.06.25 08:19:24 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8602 steps
2020.06.25 08:19:31 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8702 steps
2020.06.25 08:19:38 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8802 steps
2020.06.25 08:19:44 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 8902 steps
2020.06.25 08:19:51 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 9002 steps
2020.06.25 08:19:58 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 9102 steps
2020.06.25 08:20:05 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 9202 steps
2020.06.25 08:20:12 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 9302 steps
2020.06.25 08:20:18 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 9402 steps
2020.06.25 08:20:25 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 9502 steps
2020.06.25 08:20:32 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 9602 steps
2020.06.25 08:20:38 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 9702 steps
2020.06.25 08:20:45 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 9802 steps
2020.06.25 08:20:52 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 9902 steps
2020.06.25 08:20:59 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 10002 steps
2020.06.25 08:21:06 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 10102 steps
2020.06.25 08:21:13 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 10202 steps
2020.06.25 08:21:19 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 10302 steps
2020.06.25 08:21:26 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 10402 steps
2020.06.25 08:21:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 10502 steps
2020.06.25 08:21:40 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 10602 steps
2020.06.25 08:21:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 10702 steps
2020.06.25 08:21:53 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 10802 steps
2020.06.25 08:22:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 10902 steps
2020.06.25 08:22:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 11002 steps
2020.06.25 08:22:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 11102 steps
2020.06.25 08:22:20 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 11202 steps
2020.06.25 08:22:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 11302 steps
2020.06.25 08:22:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 11402 steps
2020.06.25 08:22:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 11502 steps
2020.06.25 08:22:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 11602 steps
2020.06.25 08:22:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 11702 steps
2020.06.25 08:23:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 11802 steps
2020.06.25 08:23:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 11902 steps
2020.06.25 08:23:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 12002 steps
2020.06.25 08:23:22 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 12102 steps
2020.06.25 08:23:29 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 12202 steps
2020.06.25 08:23:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 12302 steps
2020.06.25 08:23:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 12402 steps
2020.06.25 08:23:49 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 12502 steps
2020.06.25 08:23:56 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 12602 steps
2020.06.25 08:24:03 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 12702 steps
2020.06.25 08:24:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 12802 steps
2020.06.25 08:24:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 12902 steps
2020.06.25 08:24:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 13002 steps
2020.06.25 08:24:30 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 13102 steps
2020.06.25 08:24:37 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 13202 steps
2020.06.25 08:24:44 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 13302 steps
2020.06.25 08:24:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 13402 steps
2020.06.25 08:24:57 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 13502 steps
2020.06.25 08:25:04 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 13602 steps
2020.06.25 08:25:11 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 13702 steps
2020.06.25 08:25:18 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 13802 steps
2020.06.25 08:25:25 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 13902 steps
2020.06.25 08:25:31 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 14002 steps
2020.06.25 08:25:38 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 14102 steps
2020.06.25 08:25:45 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 14202 steps
2020.06.25 08:25:52 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 14302 steps
2020.06.25 08:25:59 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 14402 steps
2020.06.25 08:26:06 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 14502 steps
2020.06.25 08:26:12 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 14602 steps
2020.06.25 08:26:19 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 14702 steps
2020.06.25 08:26:26 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 14802 steps
2020.06.25 08:26:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 14902 steps
2020.06.25 08:26:39 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 15002 steps
2020.06.25 08:26:46 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 15102 steps
2020.06.25 08:26:53 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 15202 steps
2020.06.25 08:27:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 15302 steps
2020.06.25 08:27:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 15402 steps
2020.06.25 08:27:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 15502 steps
2020.06.25 08:27:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 15602 steps
2020.06.25 08:27:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 15702 steps
2020.06.25 08:27:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 15802 steps
2020.06.25 08:27:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 15902 steps
2020.06.25 08:27:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 16002 steps
2020.06.25 08:27:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 16102 steps
2020.06.25 08:28:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 16202 steps
2020.06.25 08:28:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 16302 steps
2020.06.25 08:28:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 16402 steps
2020.06.25 08:28:22 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 16502 steps
2020.06.25 08:28:29 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 16602 steps
2020.06.25 08:28:36 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 16702 steps
2020.06.25 08:28:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 16802 steps
2020.06.25 08:28:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 16902 steps
2020.06.25 08:28:56 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 17002 steps
2020.06.25 08:29:03 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 17102 steps
2020.06.25 08:29:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 17202 steps
2020.06.25 08:29:17 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 17302 steps
2020.06.25 08:29:24 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 17402 steps
2020.06.25 08:29:31 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 17502 steps
2020.06.25 08:29:38 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 17602 steps
2020.06.25 08:29:45 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 17702 steps
2020.06.25 08:29:52 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 17802 steps
2020.06.25 08:29:58 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 17902 steps
2020.06.25 08:30:05 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 18002 steps
2020.06.25 08:30:12 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 18102 steps
2020.06.25 08:30:19 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 18202 steps
2020.06.25 08:30:26 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 18302 steps
2020.06.25 08:30:32 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 18402 steps
2020.06.25 08:30:39 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 18502 steps
2020.06.25 08:30:46 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 18602 steps
2020.06.25 08:30:53 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 18702 steps
2020.06.25 08:31:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 18802 steps
2020.06.25 08:31:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 18902 steps
2020.06.25 08:31:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 19002 steps
2020.06.25 08:31:20 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 19102 steps
2020.06.25 08:31:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 19202 steps
2020.06.25 08:31:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 19302 steps
2020.06.25 08:31:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 19402 steps
2020.06.25 08:31:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 19502 steps
2020.06.25 08:31:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 19602 steps
2020.06.25 08:32:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 19702 steps
2020.06.25 08:32:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 19802 steps
2020.06.25 08:32:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 19902 steps
2020.06.25 08:32:22 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 20002 steps
2020.06.25 08:32:29 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 20102 steps
2020.06.25 08:32:37 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 20202 steps
2020.06.25 08:32:44 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 20302 steps
2020.06.25 08:32:51 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 20402 steps
2020.06.25 08:32:58 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 20502 steps
2020.06.25 08:33:05 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 20602 steps
2020.06.25 08:33:12 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 20702 steps
2020.06.25 08:33:19 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 20802 steps
2020.06.25 08:33:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 20902 steps
2020.06.25 08:33:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 21002 steps
2020.06.25 08:33:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 21102 steps
2020.06.25 08:33:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 21202 steps
2020.06.25 08:33:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 21302 steps
2020.06.25 08:34:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 21402 steps
2020.06.25 08:34:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 21502 steps
2020.06.25 08:34:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 21602 steps
2020.06.25 08:34:24 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 21702 steps
2020.06.25 08:34:31 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 21802 steps
2020.06.25 08:34:38 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 21902 steps
2020.06.25 08:34:45 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 22002 steps
2020.06.25 08:34:52 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 22102 steps
2020.06.25 08:34:59 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 22202 steps
2020.06.25 08:35:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 22302 steps
2020.06.25 08:35:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 22402 steps
2020.06.25 08:35:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 22502 steps
2020.06.25 08:35:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 22602 steps
2020.06.25 08:35:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 22702 steps
2020.06.25 08:35:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 22802 steps
2020.06.25 08:35:49 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 22902 steps
2020.06.25 08:35:57 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 23002 steps
2020.06.25 08:36:04 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 23102 steps
2020.06.25 08:36:11 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 23202 steps
2020.06.25 08:36:18 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 23302 steps
2020.06.25 08:36:25 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 23402 steps
2020.06.25 08:36:32 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 23502 steps
2020.06.25 08:36:40 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 23602 steps
2020.06.25 08:36:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 23702 steps
2020.06.25 08:36:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 23802 steps
2020.06.25 08:37:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 23902 steps
2020.06.25 08:37:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 24002 steps
2020.06.25 08:37:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 24102 steps
2020.06.25 08:37:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 24202 steps
2020.06.25 08:37:30 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 24302 steps
2020.06.25 08:37:37 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 24402 steps
2020.06.25 08:37:45 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 24502 steps
2020.06.25 08:37:52 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 24602 steps
2020.06.25 08:37:59 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 24702 steps
2020.06.25 08:38:06 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 24802 steps
2020.06.25 08:38:13 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 24902 steps
2020.06.25 08:38:20 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 25002 steps
2020.06.25 08:38:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 25102 steps
2020.06.25 08:38:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 25202 steps
2020.06.25 08:38:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 25302 steps
2020.06.25 08:38:49 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 25402 steps
2020.06.25 08:38:56 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 25502 steps
2020.06.25 08:39:03 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 25602 steps
2020.06.25 08:39:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 25702 steps
2020.06.25 08:39:17 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 25802 steps
2020.06.25 08:39:24 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 25902 steps
2020.06.25 08:39:32 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 26002 steps
2020.06.25 08:39:39 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 26102 steps
2020.06.25 08:39:46 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 26202 steps
2020.06.25 08:39:53 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 26302 steps
2020.06.25 08:40:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 26402 steps
2020.06.25 08:40:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 26502 steps
2020.06.25 08:40:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 26602 steps
2020.06.25 08:40:22 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 26702 steps
2020.06.25 08:40:29 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 26802 steps
2020.06.25 08:40:36 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 26902 steps
2020.06.25 08:40:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 27002 steps
2020.06.25 08:40:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 27102 steps
2020.06.25 08:40:57 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 27202 steps
2020.06.25 08:41:05 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 27302 steps
2020.06.25 08:41:12 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 27402 steps
2020.06.25 08:41:19 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 27502 steps
2020.06.25 08:41:26 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 27602 steps
2020.06.25 08:41:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 27702 steps
2020.06.25 08:41:40 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 27802 steps
2020.06.25 08:41:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 27902 steps
2020.06.25 08:41:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 28002 steps
2020.06.25 08:42:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 28102 steps
2020.06.25 08:42:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 28202 steps
2020.06.25 08:42:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 28302 steps
2020.06.25 08:42:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 28402 steps
2020.06.25 08:42:30 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 28502 steps
2020.06.25 08:42:37 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 28602 steps
2020.06.25 08:42:45 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 28702 steps
2020.06.25 08:42:52 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 28802 steps
2020.06.25 08:42:59 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 28902 steps
2020.06.25 08:43:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 29002 steps
2020.06.25 08:43:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 29102 steps
2020.06.25 08:43:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 29202 steps
2020.06.25 08:43:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 29302 steps
2020.06.25 08:43:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 29402 steps
2020.06.25 08:43:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 29502 steps
2020.06.25 08:43:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 29602 steps
2020.06.25 08:43:57 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 29702 steps
2020.06.25 08:44:04 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 29802 steps
2020.06.25 08:44:11 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 29902 steps
2020.06.25 08:44:18 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 30002 steps
2020.06.25 08:44:25 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 30102 steps
2020.06.25 08:44:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 30202 steps
2020.06.25 08:44:40 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 30302 steps
2020.06.25 08:44:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 30402 steps
2020.06.25 08:44:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 30502 steps
2020.06.25 08:45:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 30602 steps
2020.06.25 08:45:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 30702 steps
2020.06.25 08:45:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 30802 steps
2020.06.25 08:45:22 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 30902 steps
2020.06.25 08:45:30 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 31002 steps
2020.06.25 08:45:37 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 31102 steps
2020.06.25 08:45:44 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 31202 steps
2020.06.25 08:45:51 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 31302 steps
2020.06.25 08:45:58 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 31402 steps
2020.06.25 08:46:05 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 31502 steps
2020.06.25 08:46:12 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 31602 steps
2020.06.25 08:46:19 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 31702 steps
2020.06.25 08:46:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 31802 steps
2020.06.25 08:46:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 31902 steps
2020.06.25 08:46:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 32002 steps
2020.06.25 08:46:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 32102 steps
2020.06.25 08:46:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 32202 steps
2020.06.25 08:47:03 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 32302 steps
2020.06.25 08:47:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 32402 steps
2020.06.25 08:47:17 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 32502 steps
2020.06.25 08:47:24 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 32602 steps
2020.06.25 08:47:31 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 32702 steps
2020.06.25 08:47:39 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 32802 steps
2020.06.25 08:47:46 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 32902 steps
2020.06.25 08:47:53 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 33002 steps
2020.06.25 08:48:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 33102 steps
2020.06.25 08:48:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 33202 steps
2020.06.25 08:48:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 33302 steps
2020.06.25 08:48:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 33402 steps
2020.06.25 08:48:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 33502 steps
2020.06.25 08:48:36 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 33602 steps
2020.06.25 08:48:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 33702 steps
2020.06.25 08:48:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 33802 steps
2020.06.25 08:48:57 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 33902 steps
2020.06.25 08:49:04 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 34002 steps
2020.06.25 08:49:11 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 34102 steps
2020.06.25 08:49:18 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 34202 steps
2020.06.25 08:49:26 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 34302 steps
2020.06.25 08:49:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 34402 steps
2020.06.25 08:49:40 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 34502 steps
2020.06.25 08:49:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 34602 steps
2020.06.25 08:49:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 34702 steps
2020.06.25 08:50:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 34802 steps
2020.06.25 08:50:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 34902 steps
2020.06.25 08:50:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 35002 steps
2020.06.25 08:50:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 35102 steps
2020.06.25 08:50:30 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 35202 steps
2020.06.25 08:50:37 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 35302 steps
2020.06.25 08:50:44 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 35402 steps
2020.06.25 08:50:51 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 35502 steps
2020.06.25 08:50:58 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 35602 steps
2020.06.25 08:51:06 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 35702 steps
2020.06.25 08:51:13 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 35802 steps
2020.06.25 08:51:20 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 35902 steps
2020.06.25 08:51:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 36002 steps
2020.06.25 08:51:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 36102 steps
2020.06.25 08:51:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 36202 steps
2020.06.25 08:51:49 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 36302 steps
2020.06.25 08:51:56 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 36402 steps
2020.06.25 08:52:03 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 36502 steps
2020.06.25 08:52:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 36602 steps
2020.06.25 08:52:17 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 36702 steps
2020.06.25 08:52:25 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 36802 steps
2020.06.25 08:52:32 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 36902 steps
2020.06.25 08:52:39 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 37002 steps
2020.06.25 08:52:46 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 37102 steps
2020.06.25 08:52:53 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 37202 steps
2020.06.25 08:53:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 37302 steps
2020.06.25 08:53:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 37402 steps
2020.06.25 08:53:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 37502 steps
2020.06.25 08:53:22 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 37602 steps
2020.06.25 08:53:29 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 37702 steps
2020.06.25 08:53:36 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 37802 steps
2020.06.25 08:53:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 37902 steps
2020.06.25 08:53:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 38002 steps
2020.06.25 08:53:57 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 38102 steps
2020.06.25 08:54:04 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 38202 steps
2020.06.25 08:54:12 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 38302 steps
2020.06.25 08:54:19 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 38402 steps
2020.06.25 08:54:26 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 38502 steps
2020.06.25 08:54:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 38602 steps
2020.06.25 08:54:40 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 38702 steps
2020.06.25 08:54:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 38802 steps
2020.06.25 08:54:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 38902 steps
2020.06.25 08:55:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 39002 steps
2020.06.25 08:55:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 39102 steps
2020.06.25 08:55:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 39202 steps
2020.06.25 08:55:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 39302 steps
2020.06.25 08:55:30 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 39402 steps
2020.06.25 08:55:37 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 39502 steps
2020.06.25 08:55:44 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 39602 steps
2020.06.25 08:55:51 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 39702 steps
2020.06.25 08:55:59 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 39802 steps
2020.06.25 08:56:06 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 39902 steps
2020.06.25 08:56:13 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 40002 steps
2020.06.25 08:56:20 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 40102 steps
2020.06.25 08:56:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 40202 steps
2020.06.25 08:56:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 40302 steps
2020.06.25 08:56:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 40402 steps
2020.06.25 08:56:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 40502 steps
2020.06.25 08:56:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 40602 steps
2020.06.25 08:57:03 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 40702 steps
2020.06.25 08:57:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 40802 steps
2020.06.25 08:57:17 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 40902 steps
2020.06.25 08:57:24 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 41002 steps
2020.06.25 08:57:31 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 41102 steps
2020.06.25 08:57:38 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 41202 steps
2020.06.25 08:57:46 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 41302 steps
2020.06.25 08:57:53 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 41402 steps
2020.06.25 08:58:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 41502 steps
2020.06.25 08:58:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 41602 steps
2020.06.25 08:58:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 41702 steps
2020.06.25 08:58:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 41802 steps
2020.06.25 08:58:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 41902 steps
2020.06.25 08:58:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 42002 steps
2020.06.25 08:58:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 42102 steps
2020.06.25 08:58:49 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 42202 steps
2020.06.25 08:58:57 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 42302 steps
2020.06.25 08:59:04 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 42402 steps
2020.06.25 08:59:11 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 42502 steps
2020.06.25 08:59:18 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 42602 steps
2020.06.25 08:59:26 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 42702 steps
2020.06.25 08:59:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 42802 steps
2020.06.25 08:59:40 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 42902 steps
2020.06.25 08:59:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 43002 steps
2020.06.25 08:59:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 43102 steps
2020.06.25 09:00:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 43202 steps
2020.06.25 09:00:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 43302 steps
2020.06.25 09:00:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 43402 steps
2020.06.25 09:00:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 43502 steps
2020.06.25 09:00:30 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 43602 steps
2020.06.25 09:00:38 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 43702 steps
2020.06.25 09:00:45 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 43802 steps
2020.06.25 09:00:52 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 43902 steps
2020.06.25 09:00:59 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 44002 steps
2020.06.25 09:01:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 44102 steps
2020.06.25 09:01:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 44202 steps
2020.06.25 09:01:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 44302 steps
2020.06.25 09:01:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 44402 steps
2020.06.25 09:01:36 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 44502 steps
2020.06.25 09:01:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 44602 steps
2020.06.25 09:01:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 44702 steps
2020.06.25 09:01:57 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 44802 steps
2020.06.25 09:02:04 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 44902 steps
2020.06.25 09:02:11 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 45002 steps
2020.06.25 09:02:19 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 45102 steps
2020.06.25 09:02:26 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 45202 steps
2020.06.25 09:02:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 45302 steps
2020.06.25 09:02:40 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 45402 steps
2020.06.25 09:02:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 45502 steps
2020.06.25 09:02:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 45602 steps
2020.06.25 09:03:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 45702 steps
2020.06.25 09:03:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 45802 steps
2020.06.25 09:03:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 45902 steps
2020.06.25 09:03:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 46002 steps
2020.06.25 09:03:30 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 46102 steps
2020.06.25 09:03:38 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 46202 steps
2020.06.25 09:03:45 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 46302 steps
2020.06.25 09:03:52 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 46402 steps
2020.06.25 09:03:59 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 46502 steps
2020.06.25 09:04:06 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 46602 steps
2020.06.25 09:04:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 46702 steps
2020.06.25 09:04:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 46802 steps
2020.06.25 09:04:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 46902 steps
2020.06.25 09:04:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 47002 steps
2020.06.25 09:04:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 47102 steps
2020.06.25 09:04:49 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 47202 steps
2020.06.25 09:04:56 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 47302 steps
2020.06.25 09:05:03 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 47402 steps
2020.06.25 09:05:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 47502 steps
2020.06.25 09:05:17 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 47602 steps
2020.06.25 09:05:25 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 47702 steps
2020.06.25 09:05:32 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 47802 steps
2020.06.25 09:05:39 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 47902 steps
2020.06.25 09:05:46 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 48002 steps
2020.06.25 09:05:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 48102 steps
2020.06.25 09:06:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 48202 steps
2020.06.25 09:06:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 48302 steps
2020.06.25 09:06:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 48402 steps
2020.06.25 09:06:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 48502 steps
2020.06.25 09:06:30 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 48602 steps
2020.06.25 09:06:37 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 48702 steps
2020.06.25 09:06:45 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 48802 steps
2020.06.25 09:06:52 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 48902 steps
2020.06.25 09:06:59 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 49002 steps
2020.06.25 09:07:06 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 49102 steps
2020.06.25 09:07:13 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 49202 steps
2020.06.25 09:07:20 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 49302 steps
2020.06.25 09:07:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 49402 steps
2020.06.25 09:10:45 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TautologyInitState], id: (1,-384837536), content:
TautologyInitState(TermState([m : 0.14285714285714285, sym : 0.14285714285714285, ((mul) (m)) (n) : 0.14285714285714285, refl : 0.14285714285714285, mul : 0.14285714285714285, n : 0.14285714285714285, trans : 0.14285714285714285],[M : 1.0],Vector(),[],[],Empty))
2020.06.25 09:10:45 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (2,1588327529), content:
SpecialInitState(TermState([trans : 0.9, sym : 0.1],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.05,Some(TermGenParams(0.0,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 09:10:45 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (3,246182078), content:
SpecialInitState(TermState([left-multiply : 0.2, right-multiply : 0.2, ((mul) (m)) (n) : 0.2, m : 0.2, n : 0.2],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.5,Some(TermGenParams(0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 09:10:45 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.LocalProver], id: (4,582823858), content:
LocalProver(TermState([m : 0.08333333333333333, left-multiply : 0.08333333333333333, eqM : 0.08333333333333333, mul : 0.08333333333333333, n : 0.08333333333333333, trans : 0.08333333333333333, sym : 0.08333333333333333, ass1 : 0.08333333333333333, right-multiply : 0.08333333333333333, ass2 : 0.08333333333333333, refl : 0.08333333333333333, ((mul) (m)) (n) : 0.08333333333333333],[M : 1.0],Vector(),[],[((eqM) (((mul) (m)) (n))) (((mul) (n)) (m)) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0,Some(500000))
2020.06.25 09:10:45 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.LocalProver]
2020.06.25 09:10:59 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (5,712500644), content:
provingground.learning.ExpressionEval$$anon$2@2a77e5a4
2020.06.25 09:10:59 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 09:10:59 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 09:10:59 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 09:11:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 09:11:01 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (6,-1664112044)
2020.06.25 09:11:01 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 09:11:00 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 09:11:01 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 09:11:03 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 3
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.666676177661691E-4; statement weight 4.922526522818089E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.6875890673843706E-4; statement weight 3.283350224245018E-7
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.6875890673843706E-4; statement weight 2.901648730630753E-7
2020.06.25 09:11:03 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 09:11:05 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (7,1645406931)
2020.06.25 09:11:05 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 09:11:05 [INFO] provingground.learning.HoTTBot.$anonfun:902:24 - excluded lemmas:

2020.06.25 09:11:05 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (8,-1445828818)
2020.06.25 09:11:05 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (9,-962844701)
2020.06.25 09:11:05 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (10,1833728595)
2020.06.25 09:11:05 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 09:11:06 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 09:11:08 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (11,368099790)
2020.06.25 09:11:08 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 09:11:08 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 09:11:08 [INFO] provingground.learning.HoTTBot.$anonfun:1009:22 - previous special init states are 2
2020.06.25 09:11:08 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 09:11:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 09:11:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 09:11:09 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (12,412426767)
2020.06.25 09:11:09 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 09:11:10 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (13,-2086306360)
2020.06.25 09:11:10 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 09:11:10 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (14,-1666923435), content:
TangentBaseCompleted
2020.06.25 09:11:10 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 09:11:10 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 09:11:13 [INFO] provingground.learning.HoTTBot.$anonfun:1205:26 - generating equations with 3 base states and 18 lemmas (before pruning)
2020.06.25 09:11:13 [INFO] provingground.learning.HoTTBot.$anonfun:1213:26 - Tangent lemmas (used with bases below): 3
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.040700000848968604)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),0.001214698356305945)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),0.001114032298292804)
2020.06.25 09:11:13 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 3
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.053326178457998585
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.002437424090839206
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.002437424090839206
2020.06.25 09:11:13 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.050046293108537594
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.011126917673166644
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.010695179485308265
2020.06.25 09:11:13 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.053326178457998585, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.040700000848968604, 9.920316256645221E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 09:11:14 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.0E-6
2020.06.25 09:11:14 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.0E-6
2020.06.25 09:11:17 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.053326178457998585

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap((mul) (m)) ∈ Funcs))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.002437424090839206
P₁(((mul) (m)) (n) ∈ Terms) -> 0.053326178457998585
P₁((mul) (m) ∈ Terms) -> 0.001286599861208855
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(n ∈ Terms) -> 0.053326178457998585
P₁(left-multiply ∈ Terms) -> 0.053326178457998585

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.002437424090839206
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(right-multiply ∈ Terms) -> 0.053326178457998585


2020.06.25 09:11:17 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.016270597645731934
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.016270597645731934
2020.06.25 09:11:17 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.08055093331491427
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.017883196935657784
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.01723230794846274
2020.06.25 09:11:17 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.040700000848968604, 6.622133379945163E-4) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 09:11:19 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.016270597645731934
P₁(((mul) (m)) (n) ∈ Terms) -> 0.08837517523251155
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(n ∈ Terms) -> 0.08837517523251155
P₁(left-multiply ∈ Terms) -> 0.08837517523251155

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.016270597645731934
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(right-multiply ∈ Terms) -> 0.08837517523251155


2020.06.25 09:11:19 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.45000000000000007
2020.06.25 09:11:19 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.09114656135389602
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0202355433962171
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.019499036808838258
2020.06.25 09:11:19 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.45000000000000007, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.040700000848968604, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 09:11:19 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.45000000000000007

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 09:11:29 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:143:54 - all pairs considered with cutoff 1.52587890625E-11
2020.06.25 09:11:31 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-2035321527)
2020.06.25 09:11:31 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-2035321527)
2020.06.25 09:11:31 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 09:11:31 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 09:12:05 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1171346948), content:
provingground.learning.ExpressionEval$$anon$2@45d15604
2020.06.25 09:12:05 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1171346948)
2020.06.25 09:12:05 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 09:12:05 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 09:12:05 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 09:12:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 09:12:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 102 steps
2020.06.25 09:12:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 202 steps
2020.06.25 09:12:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 302 steps
2020.06.25 09:12:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 402 steps
2020.06.25 09:12:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 502 steps
2020.06.25 09:12:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 602 steps
2020.06.25 09:12:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 702 steps
2020.06.25 09:13:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 802 steps
2020.06.25 09:13:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 902 steps
2020.06.25 09:13:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1002 steps
2020.06.25 09:13:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1102 steps
2020.06.25 09:13:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1202 steps
2020.06.25 09:13:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1302 steps
2020.06.25 09:13:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1402 steps
2020.06.25 09:13:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1502 steps
2020.06.25 09:13:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1602 steps
2020.06.25 09:14:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1702 steps
2020.06.25 09:14:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1802 steps
2020.06.25 09:14:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1902 steps
2020.06.25 09:14:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2002 steps
2020.06.25 09:14:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2102 steps
2020.06.25 09:14:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2202 steps
2020.06.25 09:14:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2302 steps
2020.06.25 09:14:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2402 steps
2020.06.25 09:14:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2502 steps
2020.06.25 09:15:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2602 steps
2020.06.25 09:15:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2702 steps
2020.06.25 09:15:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2802 steps
2020.06.25 09:15:22 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2902 steps
2020.06.25 09:15:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3002 steps
2020.06.25 09:15:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3102 steps
2020.06.25 09:15:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3202 steps
2020.06.25 09:15:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3302 steps
2020.06.25 09:15:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3402 steps
2020.06.25 09:16:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3502 steps
2020.06.25 09:16:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3602 steps
2020.06.25 09:16:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3702 steps
2020.06.25 09:16:22 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3802 steps
2020.06.25 09:16:29 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3902 steps
2020.06.25 09:16:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4002 steps
2020.06.25 09:16:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4102 steps
2020.06.25 09:16:49 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4202 steps
2020.06.25 09:16:56 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4302 steps
2020.06.25 09:17:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4402 steps
2020.06.25 09:17:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4502 steps
2020.06.25 09:17:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4602 steps
2020.06.25 09:17:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4702 steps
2020.06.25 09:17:29 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4802 steps
2020.06.25 09:17:36 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4902 steps
2020.06.25 09:17:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5002 steps
2020.06.25 09:17:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5102 steps
2020.06.25 09:17:56 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5202 steps
2020.06.25 09:18:03 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5302 steps
2020.06.25 09:18:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5402 steps
2020.06.25 09:18:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5502 steps
2020.06.25 09:18:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5602 steps
2020.06.25 09:18:30 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5702 steps
2020.06.25 09:18:37 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5802 steps
2020.06.25 09:18:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5902 steps
2020.06.25 09:18:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6002 steps
2020.06.25 09:18:57 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6102 steps
2020.06.25 09:19:03 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6202 steps
2020.06.25 09:19:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6302 steps
2020.06.25 09:19:17 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6402 steps
2020.06.25 09:19:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6502 steps
2020.06.25 09:19:30 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6602 steps
2020.06.25 09:19:37 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6702 steps
2020.06.25 09:19:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6802 steps
2020.06.25 09:19:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 6902 steps
2020.06.25 09:19:57 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7002 steps
2020.06.25 09:20:04 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7102 steps
2020.06.25 09:20:11 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7202 steps
2020.06.25 09:20:17 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7302 steps
2020.06.25 09:20:24 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 7402 steps
2020.06.25 09:20:25 [ERROR] provingground.learning.ExprCalc.stableVec:599:25 - Timeout for stable vector after 7418 steps
2020.06.25 09:20:25 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,1363916898)
2020.06.25 09:20:25 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 09:20:25 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 09:20:25 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 09:20:25 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 09:20:25 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,1363916898)
2020.06.25 09:20:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 09:20:58 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-2126491084)
2020.06.25 09:21:00 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 09:21:00 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-2126491084)
2020.06.25 09:21:01 [INFO] provingground.learning.HoTTBot.$anonfun:902:24 - excluded lemmas:

2020.06.25 09:21:01 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Steps (in final state): 3
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best proof: trans with weight 0.05649641766035221; statement weight NaN
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best proof: (left-multiply) (((mul) (m)) (n)) with weight 0.005972213461657846; statement weight NaN
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best proof: (right-multiply) (m) with weight 0.0059495358194578876; statement weight NaN
2020.06.25 09:21:01 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (19,-2126491084)
2020.06.25 09:21:01 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (20,-2126491084)
2020.06.25 09:21:01 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,-2126491084)
2020.06.25 09:21:01 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 09:21:01 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,-2126491084)
2020.06.25 09:21:01 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.566186373291756E-4; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.575967818123402E-4; statement weight NaN
Lemma: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best proof: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 2.1247139872016576E-10; statement weight 0.0
Vanising Lemma: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))
Traced back equations:

Weights of terms and types:
P₁(((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) ∈ Typs) -> 0.0

Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best proof: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 2.861311556360241E-9; statement weight 0.0
Vanising Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m))
Traced back equations:

Weights of terms and types:
P₁(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)) ∈ Typs) -> 0.0

Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.575967818123402E-4; statement weight NaN
2020.06.25 09:21:18 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 09:21:18 [INFO] provingground.learning.HoTTBot.$anonfun:1009:22 - previous special init states are 2
2020.06.25 09:21:18 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 09:21:26 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 09:21:26 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 09:21:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (22,-809265120)
2020.06.25 09:21:45 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 09:21:49 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (23,1294617878)
2020.06.25 09:21:49 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 09:21:49 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435), content:
TangentBaseCompleted
2020.06.25 09:21:49 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435)
2020.06.25 09:21:49 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 09:21:49 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 09:22:07 [INFO] provingground.learning.HoTTBot.$anonfun:1205:26 - generating equations with 2 base states and 0 lemmas (before pruning)
2020.06.25 09:22:07 [INFO] provingground.learning.HoTTBot.$anonfun:1213:26 - Tangent lemmas (used with bases below): 0

2020.06.25 09:22:07 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.02915229238589741
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.02915229238589741
2020.06.25 09:22:07 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 0

2020.06.25 09:22:07 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.02915229238589741, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.02915229238589741, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 09:22:13 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.02915229238589741
P₁(((mul) (m)) (n) ∈ Terms) -> 0.15834322771228476
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.15834322771228476
P₁(n ∈ Terms) -> 0.15834322771228476
P₁(left-multiply ∈ Terms) -> 0.15834322771228476

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.02915229238589741
P₁(m ∈ Terms) -> 0.15834322771228476
P₁(right-multiply ∈ Terms) -> 0.15834322771228476


2020.06.25 09:22:13 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.8999999999999999
2020.06.25 09:22:13 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 0

2020.06.25 09:22:13 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.8999999999999999, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 09:22:19 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.8999999999999999

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 10:01:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TautologyInitState], id: (1,-384837536), content:
TautologyInitState(TermState([m : 0.14285714285714285, sym : 0.14285714285714285, ((mul) (m)) (n) : 0.14285714285714285, refl : 0.14285714285714285, mul : 0.14285714285714285, n : 0.14285714285714285, trans : 0.14285714285714285],[M : 1.0],Vector(),[],[],Empty))
2020.06.25 10:01:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (2,1588327529), content:
SpecialInitState(TermState([trans : 0.9, sym : 0.1],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.05,Some(TermGenParams(0.0,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 10:01:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (3,246182078), content:
SpecialInitState(TermState([left-multiply : 0.2, right-multiply : 0.2, ((mul) (m)) (n) : 0.2, m : 0.2, n : 0.2],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.5,Some(TermGenParams(0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 10:01:41 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.LocalProver], id: (4,582823858), content:
LocalProver(TermState([m : 0.08333333333333333, left-multiply : 0.08333333333333333, eqM : 0.08333333333333333, mul : 0.08333333333333333, n : 0.08333333333333333, trans : 0.08333333333333333, sym : 0.08333333333333333, ass1 : 0.08333333333333333, right-multiply : 0.08333333333333333, ass2 : 0.08333333333333333, refl : 0.08333333333333333, ((mul) (m)) (n) : 0.08333333333333333],[M : 1.0],Vector(),[],[((eqM) (((mul) (m)) (n))) (((mul) (n)) (m)) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0,Some(500000))
2020.06.25 10:01:41 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.LocalProver]
2020.06.25 10:01:55 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (5,1002773221), content:
provingground.learning.ExpressionEval$$anon$2@3bc51ae5
2020.06.25 10:01:55 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 10:01:56 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 10:01:55 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 10:01:56 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 10:01:56 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (6,-1664112044)
2020.06.25 10:01:56 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 10:01:57 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 10:01:57 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 10:01:59 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 3
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.666676177661691E-4; statement weight 4.922526522818089E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.6875890673843706E-4; statement weight 3.283350224245018E-7
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.6875890673843706E-4; statement weight 2.901648730630753E-7
2020.06.25 10:01:59 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 10:01:59 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (7,1645406931)
2020.06.25 10:01:59 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 10:01:59 [INFO] provingground.learning.HoTTBot.$anonfun:902:24 - excluded lemmas:

2020.06.25 10:01:59 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (8,-1445828818)
2020.06.25 10:02:00 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (9,-962844701)
2020.06.25 10:02:00 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (10,1833728595)
2020.06.25 10:02:00 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 10:02:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 10:02:03 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (11,368099790)
2020.06.25 10:02:03 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 10:02:03 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 10:02:03 [INFO] provingground.learning.HoTTBot.$anonfun:1009:22 - previous special init states are 2
2020.06.25 10:02:03 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 10:02:05 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 10:02:05 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 10:02:05 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (12,412426767)
2020.06.25 10:02:05 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 10:02:06 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (13,-2086306360)
2020.06.25 10:02:06 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 10:02:06 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (14,-1666923435), content:
TangentBaseCompleted
2020.06.25 10:02:06 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 10:02:06 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 10:02:10 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:179:30 - all pairs considered with cutoff 1.0E-6
2020.06.25 10:02:11 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:179:30 - all pairs considered with cutoff 1.0E-6
2020.06.25 10:02:12 [INFO] provingground.learning.HoTTBot.$anonfun:1205:26 - generating equations with 3 base states and 18 lemmas (before pruning)
2020.06.25 10:02:12 [INFO] provingground.learning.HoTTBot.$anonfun:1213:26 - Tangent lemmas (used with bases below): 3
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.040700000848968604)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),0.001214698356305945)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),0.001114032298292804)
2020.06.25 10:02:12 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 3
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.053326178457998585
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.002437424090839206
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.002437424090839206
2020.06.25 10:02:12 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.050046293108537594
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.011126917673166644
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.010695179485308265
2020.06.25 10:02:12 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.053326178457998585, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.040700000848968604, 9.920316256645221E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 10:02:15 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.053326178457998585

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap((mul) (m)) ∈ Funcs))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.002437424090839206
P₁(((mul) (m)) (n) ∈ Terms) -> 0.053326178457998585
P₁((mul) (m) ∈ Terms) -> 0.001286599861208855
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(n ∈ Terms) -> 0.053326178457998585
P₁(left-multiply ∈ Terms) -> 0.053326178457998585

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.002437424090839206
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(right-multiply ∈ Terms) -> 0.053326178457998585


2020.06.25 10:02:15 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.016270597645731934
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.016270597645731934
2020.06.25 10:02:15 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.08055093331491427
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.017883196935657784
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.01723230794846274
2020.06.25 10:02:15 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.040700000848968604, 6.622133379945163E-4) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 10:02:16 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.016270597645731934
P₁(((mul) (m)) (n) ∈ Terms) -> 0.08837517523251155
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(n ∈ Terms) -> 0.08837517523251155
P₁(left-multiply ∈ Terms) -> 0.08837517523251155

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.016270597645731934
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(right-multiply ∈ Terms) -> 0.08837517523251155


2020.06.25 10:02:16 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.45000000000000007
2020.06.25 10:02:16 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.09114656135389602
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0202355433962171
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.019499036808838258
2020.06.25 10:02:16 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.45000000000000007, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.040700000848968604, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 10:02:18 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.45000000000000007

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 10:02:28 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:179:30 - all pairs considered with cutoff 1.52587890625E-11
2020.06.25 10:02:29 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,573084459)
2020.06.25 10:02:29 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,573084459)
2020.06.25 10:02:29 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 10:02:29 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 10:03:06 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1617259334), content:
provingground.learning.ExpressionEval$$anon$2@60656b46
2020.06.25 10:03:06 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1617259334)
2020.06.25 10:03:06 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 10:03:06 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 10:03:06 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 10:03:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 10:03:19 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 102 steps
2020.06.25 10:03:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 202 steps
2020.06.25 10:03:36 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 302 steps
2020.06.25 10:03:44 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 402 steps
2020.06.25 10:03:53 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 502 steps
2020.06.25 10:04:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 602 steps
2020.06.25 10:04:11 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 702 steps
2020.06.25 10:04:20 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 802 steps
2020.06.25 10:04:29 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 902 steps
2020.06.25 10:04:38 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1002 steps
2020.06.25 10:04:47 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1102 steps
2020.06.25 10:04:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1202 steps
2020.06.25 10:05:04 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1302 steps
2020.06.25 10:05:13 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1402 steps
2020.06.25 10:05:22 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1502 steps
2020.06.25 10:05:31 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1602 steps
2020.06.25 10:05:40 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1702 steps
2020.06.25 10:05:49 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1802 steps
2020.06.25 10:05:57 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1902 steps
2020.06.25 10:06:06 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2002 steps
2020.06.25 10:06:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2102 steps
2020.06.25 10:06:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2202 steps
2020.06.25 10:06:32 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2302 steps
2020.06.25 10:06:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2402 steps
2020.06.25 10:06:49 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2502 steps
2020.06.25 10:06:58 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2602 steps
2020.06.25 10:07:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2702 steps
2020.06.25 10:07:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2802 steps
2020.06.25 10:07:24 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2902 steps
2020.06.25 10:07:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3002 steps
2020.06.25 10:07:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3102 steps
2020.06.25 10:07:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3202 steps
2020.06.25 10:07:59 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3302 steps
2020.06.25 10:08:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3402 steps
2020.06.25 10:08:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3502 steps
2020.06.25 10:08:25 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3602 steps
2020.06.25 10:08:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3702 steps
2020.06.25 10:08:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3802 steps
2020.06.25 10:08:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3902 steps
2020.06.25 10:08:59 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4002 steps
2020.06.25 10:09:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4102 steps
2020.06.25 10:09:16 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4202 steps
2020.06.25 10:09:25 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4302 steps
2020.06.25 10:09:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4402 steps
2020.06.25 10:09:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4502 steps
2020.06.25 10:09:51 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4602 steps
2020.06.25 10:10:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4702 steps
2020.06.25 10:10:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4802 steps
2020.06.25 10:10:17 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4902 steps
2020.06.25 10:10:26 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5002 steps
2020.06.25 10:10:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5102 steps
2020.06.25 10:10:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5202 steps
2020.06.25 10:10:52 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5302 steps
2020.06.25 10:11:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5402 steps
2020.06.25 10:11:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5502 steps
2020.06.25 10:11:18 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5602 steps
2020.06.25 10:11:27 [ERROR] provingground.learning.ExprCalc.stableVec:599:25 - Timeout for stable vector after 5701 steps
2020.06.25 10:11:27 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,-1074986345)
2020.06.25 10:11:27 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 10:11:27 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 10:11:27 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 10:11:27 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 10:11:27 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,-1074986345)
2020.06.25 10:11:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 10:12:05 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-2126491084)
2020.06.25 10:12:05 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.565338001850545E-4; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.575115748418282E-4; statement weight NaN
Lemma: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best proof: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 3.634828069026364E-6; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best proof: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 1.596273572121328E-7; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.575115748418282E-4; statement weight NaN
2020.06.25 10:12:05 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 10:12:05 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-2126491084)
2020.06.25 10:12:05 [INFO] provingground.learning.HoTTBot.$anonfun:902:24 - excluded lemmas:

2020.06.25 10:12:05 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (19,-2126491084)
2020.06.25 10:12:05 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (20,-2126491084)
2020.06.25 10:12:05 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,-2126491084)
2020.06.25 10:12:05 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 10:12:05 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,-2126491084)
2020.06.25 10:12:07 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Steps (in final state): 3
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best proof: trans with weight 0.05648014431528924; statement weight NaN
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best proof: (left-multiply) (((mul) (m)) (n)) with weight 0.005970353792916322; statement weight NaN
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best proof: (right-multiply) (m) with weight 0.00594768428520867; statement weight NaN
2020.06.25 10:12:25 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 10:12:25 [INFO] provingground.learning.HoTTBot.$anonfun:1009:22 - previous special init states are 2
2020.06.25 10:12:25 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 10:12:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 10:12:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 10:12:52 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (22,-809265120)
2020.06.25 10:12:52 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 10:12:56 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (23,1294617878)
2020.06.25 10:12:56 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 10:12:56 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435), content:
TangentBaseCompleted
2020.06.25 10:12:56 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435)
2020.06.25 10:12:56 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 10:12:56 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 10:13:15 [INFO] provingground.learning.HoTTBot.$anonfun:1205:26 - generating equations with 2 base states and 0 lemmas (before pruning)
2020.06.25 10:13:15 [INFO] provingground.learning.HoTTBot.$anonfun:1213:26 - Tangent lemmas (used with bases below): 0

2020.06.25 10:13:15 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.02915229238589741
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.02915229238589741
2020.06.25 10:13:15 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 0

2020.06.25 10:13:15 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.02915229238589741, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.02915229238589741, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 10:13:22 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.02915229238589741
P₁(((mul) (m)) (n) ∈ Terms) -> 0.15834322771228476
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.15834322771228476
P₁(n ∈ Terms) -> 0.15834322771228476
P₁(left-multiply ∈ Terms) -> 0.15834322771228476

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.02915229238589741
P₁(m ∈ Terms) -> 0.15834322771228476
P₁(right-multiply ∈ Terms) -> 0.15834322771228476


2020.06.25 10:13:22 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.8999999999999999
2020.06.25 10:13:22 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 0

2020.06.25 10:13:22 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.8999999999999999, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 10:13:27 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.8999999999999999

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 11:17:10 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TautologyInitState], id: (1,-384837536), content:
TautologyInitState(TermState([m : 0.14285714285714285, sym : 0.14285714285714285, ((mul) (m)) (n) : 0.14285714285714285, refl : 0.14285714285714285, mul : 0.14285714285714285, n : 0.14285714285714285, trans : 0.14285714285714285],[M : 1.0],Vector(),[],[],Empty))
2020.06.25 11:17:10 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (2,1588327529), content:
SpecialInitState(TermState([trans : 0.9, sym : 0.1],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.05,Some(TermGenParams(0.0,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 11:17:10 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (3,246182078), content:
SpecialInitState(TermState([left-multiply : 0.2, right-multiply : 0.2, ((mul) (m)) (n) : 0.2, m : 0.2, n : 0.2],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.5,Some(TermGenParams(0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 11:17:10 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.LocalProver], id: (4,582823858), content:
LocalProver(TermState([m : 0.08333333333333333, left-multiply : 0.08333333333333333, eqM : 0.08333333333333333, mul : 0.08333333333333333, n : 0.08333333333333333, trans : 0.08333333333333333, sym : 0.08333333333333333, ass1 : 0.08333333333333333, right-multiply : 0.08333333333333333, ass2 : 0.08333333333333333, refl : 0.08333333333333333, ((mul) (m)) (n) : 0.08333333333333333],[M : 1.0],Vector(),[],[((eqM) (((mul) (m)) (n))) (((mul) (n)) (m)) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0,Some(500000))
2020.06.25 11:17:10 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.LocalProver]
2020.06.25 11:17:24 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (5,1450737975), content:
provingground.learning.ExpressionEval$$anon$2@56788137
2020.06.25 11:17:24 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 11:17:25 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 11:17:24 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 11:17:25 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 11:17:26 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (6,-1664112044)
2020.06.25 11:17:26 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 11:17:25 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 11:17:26 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 11:17:28 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 3
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.666676177661691E-4; statement weight 4.922526522818089E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.6875890673843706E-4; statement weight 3.283350224245018E-7
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.6875890673843706E-4; statement weight 2.901648730630753E-7
2020.06.25 11:17:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 11:17:29 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (7,1645406931)
2020.06.25 11:17:29 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 11:17:29 [INFO] provingground.learning.HoTTBot.$anonfun:902:24 - excluded lemmas:

2020.06.25 11:17:29 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (8,-1445828818)
2020.06.25 11:17:29 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (9,-962844701)
2020.06.25 11:17:29 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (10,1833728595)
2020.06.25 11:17:29 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 11:17:32 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 11:17:33 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (11,368099790)
2020.06.25 11:17:33 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 11:17:34 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 11:17:34 [INFO] provingground.learning.HoTTBot.$anonfun:1009:22 - previous special init states are 2
2020.06.25 11:17:34 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 11:17:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 11:17:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 11:17:35 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (12,412426767)
2020.06.25 11:17:35 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 11:17:35 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (13,-2086306360)
2020.06.25 11:17:35 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 11:17:35 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (14,-1666923435), content:
TangentBaseCompleted
2020.06.25 11:17:35 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 11:17:35 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 11:17:36 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.25 11:17:36 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.25 11:17:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.25 11:17:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.25 11:17:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.25 11:17:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.25 11:17:39 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.25 11:17:39 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 4.0E-5
2020.06.25 11:17:40 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.25 11:17:39 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.25 11:17:41 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.25 11:17:41 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.25 11:17:43 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.25 11:17:43 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 1.6000000000000004E-6
2020.06.25 11:17:44 [INFO] provingground.learning.HoTTBot.$anonfun:1205:26 - generating equations with 3 base states and 18 lemmas (before pruning)
2020.06.25 11:17:44 [INFO] provingground.learning.HoTTBot.$anonfun:1213:26 - Tangent lemmas (used with bases below): 3
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.040700000848968604)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),0.001214698356305945)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),0.001114032298292804)
2020.06.25 11:17:44 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 3
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.053326178457998585
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.002437424090839206
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.002437424090839206
2020.06.25 11:17:44 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.050046293108537594
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.011126917673166644
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.010695179485308265
2020.06.25 11:17:44 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.053326178457998585, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.040700000848968604, 9.920316256645221E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 11:17:45 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.25 11:17:47 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.053326178457998585

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap((mul) (m)) ∈ Funcs))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.002437424090839206
P₁(((mul) (m)) (n) ∈ Terms) -> 0.053326178457998585
P₁((mul) (m) ∈ Terms) -> 0.001286599861208855
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(n ∈ Terms) -> 0.053326178457998585
P₁(left-multiply ∈ Terms) -> 0.053326178457998585

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.002437424090839206
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(right-multiply ∈ Terms) -> 0.053326178457998585


2020.06.25 11:17:47 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.016270597645731934
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.016270597645731934
2020.06.25 11:17:47 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.08055093331491427
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.017883196935657784
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.01723230794846274
2020.06.25 11:17:47 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.040700000848968604, 6.622133379945163E-4) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 11:17:48 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 3.2000000000000006E-7; running again
2020.06.25 11:17:49 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.016270597645731934
P₁(((mul) (m)) (n) ∈ Terms) -> 0.08837517523251155
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(n ∈ Terms) -> 0.08837517523251155
P₁(left-multiply ∈ Terms) -> 0.08837517523251155

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.016270597645731934
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(right-multiply ∈ Terms) -> 0.08837517523251155


2020.06.25 11:17:49 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.45000000000000007
2020.06.25 11:17:49 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.09114656135389602
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0202355433962171
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.019499036808838258
2020.06.25 11:17:49 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.45000000000000007, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.040700000848968604, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 11:17:50 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.45000000000000007

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 11:17:51 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 6.400000000000002E-8; running again
2020.06.25 11:17:53 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 1.2800000000000004E-8; running again
2020.06.25 11:17:55 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.5600000000000007E-9; running again
2020.06.25 11:17:56 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 5.120000000000001E-10; running again
2020.06.25 11:17:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 1.0240000000000002E-10; running again
2020.06.25 11:18:00 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0480000000000003E-11; running again
2020.06.25 11:18:00 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 2.0480000000000003E-11
2020.06.25 11:18:02 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,78433618)
2020.06.25 11:18:02 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,78433618)
2020.06.25 11:18:02 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 11:18:02 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 11:18:38 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1094046513), content:
provingground.learning.ExpressionEval$$anon$2@4135d331
2020.06.25 11:18:38 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1094046513)
2020.06.25 11:18:38 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 11:18:38 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 11:18:38 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 11:18:41 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 11:18:51 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 102 steps
2020.06.25 11:18:59 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 202 steps
2020.06.25 11:19:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 302 steps
2020.06.25 11:19:17 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 402 steps
2020.06.25 11:19:26 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 502 steps
2020.06.25 11:19:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 602 steps
2020.06.25 11:19:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 702 steps
2020.06.25 11:19:52 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 802 steps
2020.06.25 11:20:01 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 902 steps
2020.06.25 11:20:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1002 steps
2020.06.25 11:20:19 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1102 steps
2020.06.25 11:20:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1202 steps
2020.06.25 11:20:37 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1302 steps
2020.06.25 11:20:46 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1402 steps
2020.06.25 11:20:55 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1502 steps
2020.06.25 11:21:04 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1602 steps
2020.06.25 11:21:13 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1702 steps
2020.06.25 11:21:21 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1802 steps
2020.06.25 11:21:30 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 1902 steps
2020.06.25 11:21:39 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2002 steps
2020.06.25 11:21:48 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2102 steps
2020.06.25 11:21:57 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2202 steps
2020.06.25 11:22:05 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2302 steps
2020.06.25 11:22:14 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2402 steps
2020.06.25 11:22:23 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2502 steps
2020.06.25 11:22:32 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2602 steps
2020.06.25 11:22:40 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2702 steps
2020.06.25 11:22:49 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2802 steps
2020.06.25 11:22:58 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2902 steps
2020.06.25 11:23:07 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3002 steps
2020.06.25 11:23:15 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3102 steps
2020.06.25 11:23:24 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3202 steps
2020.06.25 11:23:33 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3302 steps
2020.06.25 11:23:42 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3402 steps
2020.06.25 11:23:50 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3502 steps
2020.06.25 11:23:59 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3602 steps
2020.06.25 11:24:08 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3702 steps
2020.06.25 11:24:17 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3802 steps
2020.06.25 11:24:25 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 3902 steps
2020.06.25 11:24:34 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4002 steps
2020.06.25 11:24:43 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4102 steps
2020.06.25 11:24:52 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4202 steps
2020.06.25 11:25:00 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4302 steps
2020.06.25 11:25:09 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4402 steps
2020.06.25 11:25:18 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4502 steps
2020.06.25 11:25:27 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4602 steps
2020.06.25 11:25:35 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4702 steps
2020.06.25 11:25:44 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4802 steps
2020.06.25 11:25:53 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 4902 steps
2020.06.25 11:26:02 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5002 steps
2020.06.25 11:26:10 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5102 steps
2020.06.25 11:26:19 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5202 steps
2020.06.25 11:26:28 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5302 steps
2020.06.25 11:26:37 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5402 steps
2020.06.25 11:26:45 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5502 steps
2020.06.25 11:26:54 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 5602 steps
2020.06.25 11:26:59 [ERROR] provingground.learning.ExprCalc.stableVec:599:25 - Timeout for stable vector after 5653 steps
2020.06.25 11:26:59 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,1795408539)
2020.06.25 11:26:59 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 11:26:59 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 11:26:59 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 11:26:59 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 11:26:59 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,1795408539)
2020.06.25 11:27:26 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 11:27:37 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.565338001850545E-4; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.575115748418282E-4; statement weight NaN
Lemma: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best proof: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 3.634828069026364E-6; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best proof: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 1.596273572121328E-7; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.575115748418282E-4; statement weight NaN
2020.06.25 11:27:37 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Steps (in final state): 3
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best proof: trans with weight 0.05648014431528924; statement weight NaN
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best proof: (left-multiply) (((mul) (m)) (n)) with weight 0.005970353792916322; statement weight NaN
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best proof: (right-multiply) (m) with weight 0.00594768428520867; statement weight NaN
2020.06.25 11:27:37 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-2126491084)
2020.06.25 11:27:37 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-2126491084)
2020.06.25 11:27:37 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 11:27:37 [INFO] provingground.learning.HoTTBot.$anonfun:902:24 - excluded lemmas:

2020.06.25 11:27:37 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (19,-2126491084)
2020.06.25 11:27:37 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (20,-2126491084)
2020.06.25 11:27:37 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,-2126491084)
2020.06.25 11:27:37 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 11:27:37 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,-2126491084)
2020.06.25 11:27:56 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 11:27:56 [INFO] provingground.learning.HoTTBot.$anonfun:1009:22 - previous special init states are 2
2020.06.25 11:27:56 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 11:28:04 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 11:28:04 [INFO] provingground.learning.ExprCalc.stableVec:602:46 - completed 2 steps
2020.06.25 11:28:23 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (22,-809265120)
2020.06.25 11:28:23 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 11:28:28 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (23,1294617878)
2020.06.25 11:28:28 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 11:28:28 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435), content:
TangentBaseCompleted
2020.06.25 11:28:28 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435)
2020.06.25 11:28:28 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 11:28:28 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 11:28:46 [INFO] provingground.learning.HoTTBot.$anonfun:1205:26 - generating equations with 2 base states and 0 lemmas (before pruning)
2020.06.25 11:28:46 [INFO] provingground.learning.HoTTBot.$anonfun:1213:26 - Tangent lemmas (used with bases below): 0

2020.06.25 11:28:46 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.02915229238589741
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.02915229238589741
2020.06.25 11:28:46 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 0

2020.06.25 11:28:46 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.02915229238589741, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.02915229238589741, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 11:28:52 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.02915229238589741
P₁(((mul) (m)) (n) ∈ Terms) -> 0.15834322771228476
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.15834322771228476
P₁(n ∈ Terms) -> 0.15834322771228476
P₁(left-multiply ∈ Terms) -> 0.15834322771228476

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.02915229238589741
P₁(m ∈ Terms) -> 0.15834322771228476
P₁(right-multiply ∈ Terms) -> 0.15834322771228476


2020.06.25 11:28:52 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.8999999999999999
2020.06.25 11:28:52 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 0

2020.06.25 11:28:52 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.8999999999999999, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 11:28:56 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.8999999999999999

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 13:22:53 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TautologyInitState], id: (1,-384837536), content:
TautologyInitState(TermState([m : 0.14285714285714285, sym : 0.14285714285714285, ((mul) (m)) (n) : 0.14285714285714285, refl : 0.14285714285714285, mul : 0.14285714285714285, n : 0.14285714285714285, trans : 0.14285714285714285],[M : 1.0],Vector(),[],[],Empty))
2020.06.25 13:22:53 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (2,1588327529), content:
SpecialInitState(TermState([trans : 0.9, sym : 0.1],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.05,Some(TermGenParams(0.0,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 13:22:53 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (3,246182078), content:
SpecialInitState(TermState([left-multiply : 0.2, right-multiply : 0.2, ((mul) (m)) (n) : 0.2, m : 0.2, n : 0.2],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.5,Some(TermGenParams(0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 13:22:53 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.LocalProver], id: (4,582823858), content:
LocalProver(TermState([m : 0.08333333333333333, left-multiply : 0.08333333333333333, eqM : 0.08333333333333333, mul : 0.08333333333333333, n : 0.08333333333333333, trans : 0.08333333333333333, sym : 0.08333333333333333, ass1 : 0.08333333333333333, right-multiply : 0.08333333333333333, ass2 : 0.08333333333333333, refl : 0.08333333333333333, ((mul) (m)) (n) : 0.08333333333333333],[M : 1.0],Vector(),[],[((eqM) (((mul) (m)) (n))) (((mul) (n)) (m)) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0,Some(500000))
2020.06.25 13:22:53 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.LocalProver]
2020.06.25 13:23:07 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (5,1961087255), content:
provingground.learning.ExpressionEval$$anon$2@74e3d117
2020.06.25 13:23:07 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 13:23:07 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 13:23:07 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 13:23:08 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:23:09 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (6,-1664112044)
2020.06.25 13:23:08 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 13:23:09 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 13:23:09 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 13:23:11 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 3
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.666676177661691E-4; statement weight 4.922526522818089E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.6875890673843706E-4; statement weight 3.283350224245018E-7
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.6875890673843706E-4; statement weight 2.901648730630753E-7
2020.06.25 13:23:11 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:23:12 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (7,1645406931)
2020.06.25 13:23:12 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 13:23:12 [INFO] provingground.learning.HoTTBot.$anonfun:902:24 - excluded lemmas:

2020.06.25 13:23:12 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (8,-1445828818)
2020.06.25 13:23:11 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (9,-962844701)
2020.06.25 13:23:11 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (10,1833728595)
2020.06.25 13:23:12 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 13:23:14 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:23:15 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (11,368099790)
2020.06.25 13:23:15 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 13:23:15 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 13:23:15 [INFO] provingground.learning.HoTTBot.$anonfun:1009:22 - previous special init states are 2
2020.06.25 13:23:15 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 13:23:17 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:23:17 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:23:17 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (12,412426767)
2020.06.25 13:23:17 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 13:23:18 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (13,-2086306360)
2020.06.25 13:23:18 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 13:23:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (14,-1666923435), content:
TangentBaseCompleted
2020.06.25 13:23:18 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 13:23:18 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 13:23:18 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.25 13:23:18 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.25 13:23:19 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.25 13:23:19 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.25 13:23:20 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.25 13:23:20 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.25 13:23:21 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.25 13:23:21 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.25 13:23:21 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 4.0E-5
2020.06.25 13:23:22 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.25 13:23:23 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.25 13:23:25 [INFO] provingground.learning.HoTTBot.$anonfun:1205:26 - generating equations with 3 base states and 18 lemmas (before pruning)
2020.06.25 13:23:25 [INFO] provingground.learning.HoTTBot.$anonfun:1213:26 - Tangent lemmas (used with bases below): 3
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.040700000848968604)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),0.001214698356305945)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),0.001114032298292804)
2020.06.25 13:23:25 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 3
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.053326178457998585
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.002437424090839206
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.002437424090839206
2020.06.25 13:23:25 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.050046293108537594
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.011126917673166644
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.010695179485308265
2020.06.25 13:23:25 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.053326178457998585, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.040700000848968604, 9.920316256645221E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 13:23:25 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.25 13:23:26 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.25 13:23:28 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.25 13:23:28 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 1.6000000000000004E-6
2020.06.25 13:23:29 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 3.2000000000000006E-7; running again
2020.06.25 13:23:30 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.053326178457998585

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap((mul) (m)) ∈ Funcs))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.002437424090839206
P₁(((mul) (m)) (n) ∈ Terms) -> 0.053326178457998585
P₁((mul) (m) ∈ Terms) -> 0.001286599861208855
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(n ∈ Terms) -> 0.053326178457998585
P₁(left-multiply ∈ Terms) -> 0.053326178457998585

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.002437424090839206
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(right-multiply ∈ Terms) -> 0.053326178457998585


2020.06.25 13:23:30 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.016270597645731934
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.016270597645731934
2020.06.25 13:23:30 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.08055093331491427
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.017883196935657784
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.01723230794846274
2020.06.25 13:23:30 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.040700000848968604, 6.622133379945163E-4) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 13:23:32 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.016270597645731934
P₁(((mul) (m)) (n) ∈ Terms) -> 0.08837517523251155
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(n ∈ Terms) -> 0.08837517523251155
P₁(left-multiply ∈ Terms) -> 0.08837517523251155

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.016270597645731934
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(right-multiply ∈ Terms) -> 0.08837517523251155


2020.06.25 13:23:32 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.45000000000000007
2020.06.25 13:23:32 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.09114656135389602
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0202355433962171
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.019499036808838258
2020.06.25 13:23:32 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.45000000000000007, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.040700000848968604, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 13:23:32 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 6.400000000000002E-8; running again
2020.06.25 13:23:34 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.45000000000000007

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 13:23:35 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 1.2800000000000004E-8; running again
2020.06.25 13:23:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.5600000000000007E-9; running again
2020.06.25 13:23:39 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 5.120000000000001E-10; running again
2020.06.25 13:23:40 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 1.0240000000000002E-10; running again
2020.06.25 13:23:42 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0480000000000003E-11; running again
2020.06.25 13:23:42 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 2.0480000000000003E-11
2020.06.25 13:23:44 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-1028037712)
2020.06.25 13:23:44 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-1028037712)
2020.06.25 13:23:44 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 13:23:44 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 13:24:21 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,653577131), content:
provingground.learning.ExpressionEval$$anon$2@26f4cbab
2020.06.25 13:24:21 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,653577131)
2020.06.25 13:24:21 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 13:24:21 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 13:24:21 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 13:24:23 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:24:34 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 102 steps
2020.06.25 13:24:42 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 202 steps
2020.06.25 13:24:51 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 302 steps
2020.06.25 13:25:00 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 402 steps
2020.06.25 13:25:09 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 502 steps
2020.06.25 13:25:18 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 602 steps
2020.06.25 13:25:27 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 702 steps
2020.06.25 13:25:35 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 802 steps
2020.06.25 13:25:44 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 902 steps
2020.06.25 13:25:53 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1002 steps
2020.06.25 13:26:02 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1102 steps
2020.06.25 13:26:11 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1202 steps
2020.06.25 13:26:20 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1302 steps
2020.06.25 13:26:29 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1402 steps
2020.06.25 13:26:38 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1502 steps
2020.06.25 13:26:46 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1602 steps
2020.06.25 13:26:55 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1702 steps
2020.06.25 13:27:04 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1802 steps
2020.06.25 13:27:13 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1902 steps
2020.06.25 13:27:22 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2002 steps
2020.06.25 13:27:30 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2102 steps
2020.06.25 13:27:39 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2202 steps
2020.06.25 13:27:48 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2302 steps
2020.06.25 13:27:57 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2402 steps
2020.06.25 13:28:06 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2502 steps
2020.06.25 13:28:14 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2602 steps
2020.06.25 13:28:23 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2702 steps
2020.06.25 13:28:32 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2802 steps
2020.06.25 13:28:41 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2902 steps
2020.06.25 13:28:50 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3002 steps
2020.06.25 13:28:58 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3102 steps
2020.06.25 13:29:07 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3202 steps
2020.06.25 13:29:16 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3302 steps
2020.06.25 13:29:25 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3402 steps
2020.06.25 13:29:33 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3502 steps
2020.06.25 13:29:42 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3602 steps
2020.06.25 13:29:51 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3702 steps
2020.06.25 13:30:00 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3802 steps
2020.06.25 13:30:09 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3902 steps
2020.06.25 13:30:18 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4002 steps
2020.06.25 13:30:26 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4102 steps
2020.06.25 13:30:35 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4202 steps
2020.06.25 13:30:44 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4302 steps
2020.06.25 13:30:53 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4402 steps
2020.06.25 13:31:02 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4502 steps
2020.06.25 13:31:10 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4602 steps
2020.06.25 13:31:19 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4702 steps
2020.06.25 13:31:28 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4802 steps
2020.06.25 13:31:37 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4902 steps
2020.06.25 13:31:46 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 5002 steps
2020.06.25 13:31:54 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 5102 steps
2020.06.25 13:32:03 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 5202 steps
2020.06.25 13:32:12 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 5302 steps
2020.06.25 13:32:21 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 5402 steps
2020.06.25 13:32:29 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 5502 steps
2020.06.25 13:32:38 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 5602 steps
2020.06.25 13:32:41 [ERROR] provingground.learning.ExprCalc.stableVec:607:25 - Timeout for stable vector after 5636 steps
2020.06.25 13:32:41 [ERROR] provingground.learning.ExpressionEval.GenerateTyps.finalTyps:343:27 - NaN for some types before normalizing
2020.06.25 13:32:41 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,616560766)
2020.06.25 13:32:41 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 13:32:41 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 13:32:41 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 13:32:41 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 13:32:41 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,616560766)
2020.06.25 13:33:10 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:33:19 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.565338001850545E-4; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.575115748418282E-4; statement weight NaN
Lemma: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best proof: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 3.634828069026364E-6; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best proof: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 1.596273572121328E-7; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.575115748418282E-4; statement weight NaN
2020.06.25 13:33:20 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-2126491084)
2020.06.25 13:33:20 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 13:33:20 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-2126491084)
2020.06.25 13:33:20 [INFO] provingground.learning.HoTTBot.$anonfun:902:24 - excluded lemmas:

2020.06.25 13:33:20 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (19,-2126491084)
2020.06.25 13:33:20 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (20,-2126491084)
2020.06.25 13:33:20 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,-2126491084)
2020.06.25 13:33:20 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 13:33:20 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,-2126491084)
2020.06.25 13:33:21 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Steps (in final state): 3
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best proof: trans with weight 0.05648014431528924; statement weight NaN
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best proof: (left-multiply) (((mul) (m)) (n)) with weight 0.005970353792916322; statement weight NaN
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best proof: (right-multiply) (m) with weight 0.00594768428520867; statement weight NaN
2020.06.25 13:33:39 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 13:33:39 [INFO] provingground.learning.HoTTBot.$anonfun:1009:22 - previous special init states are 2
2020.06.25 13:33:39 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 13:33:47 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:33:47 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:34:06 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (22,-809265120)
2020.06.25 13:34:06 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 13:34:11 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (23,1294617878)
2020.06.25 13:34:11 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 13:34:11 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435), content:
TangentBaseCompleted
2020.06.25 13:34:11 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435)
2020.06.25 13:34:11 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 13:34:11 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 13:34:29 [INFO] provingground.learning.HoTTBot.$anonfun:1205:26 - generating equations with 2 base states and 0 lemmas (before pruning)
2020.06.25 13:34:29 [INFO] provingground.learning.HoTTBot.$anonfun:1213:26 - Tangent lemmas (used with bases below): 0

2020.06.25 13:34:29 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.02915229238589741
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.02915229238589741
2020.06.25 13:34:29 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 0

2020.06.25 13:34:29 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.02915229238589741, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.02915229238589741, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 13:34:36 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.02915229238589741
P₁(((mul) (m)) (n) ∈ Terms) -> 0.15834322771228476
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.15834322771228476
P₁(n ∈ Terms) -> 0.15834322771228476
P₁(left-multiply ∈ Terms) -> 0.15834322771228476

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.02915229238589741
P₁(m ∈ Terms) -> 0.15834322771228476
P₁(right-multiply ∈ Terms) -> 0.15834322771228476


2020.06.25 13:34:36 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.8999999999999999
2020.06.25 13:34:36 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 0

2020.06.25 13:34:36 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.8999999999999999, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 13:34:41 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.8999999999999999

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 13:51:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TautologyInitState], id: (1,-384837536), content:
TautologyInitState(TermState([m : 0.14285714285714285, sym : 0.14285714285714285, ((mul) (m)) (n) : 0.14285714285714285, refl : 0.14285714285714285, mul : 0.14285714285714285, n : 0.14285714285714285, trans : 0.14285714285714285],[M : 1.0],Vector(),[],[],Empty))
2020.06.25 13:51:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (2,1588327529), content:
SpecialInitState(TermState([trans : 0.9, sym : 0.1],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.05,Some(TermGenParams(0.0,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 13:51:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (3,246182078), content:
SpecialInitState(TermState([left-multiply : 0.2, right-multiply : 0.2, ((mul) (m)) (n) : 0.2, m : 0.2, n : 0.2],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.5,Some(TermGenParams(0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 13:51:18 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.LocalProver], id: (4,582823858), content:
LocalProver(TermState([m : 0.08333333333333333, left-multiply : 0.08333333333333333, eqM : 0.08333333333333333, mul : 0.08333333333333333, n : 0.08333333333333333, trans : 0.08333333333333333, sym : 0.08333333333333333, ass1 : 0.08333333333333333, right-multiply : 0.08333333333333333, ass2 : 0.08333333333333333, refl : 0.08333333333333333, ((mul) (m)) (n) : 0.08333333333333333],[M : 1.0],Vector(),[],[((eqM) (((mul) (m)) (n))) (((mul) (n)) (m)) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0,Some(500000))
2020.06.25 13:51:18 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.LocalProver]
2020.06.25 13:51:34 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (5,1638178307), content:
provingground.learning.ExpressionEval$$anon$2@61a49e03
2020.06.25 13:51:34 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 13:51:34 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 13:51:34 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 13:51:35 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:51:35 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (6,-1664112044)
2020.06.25 13:51:35 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 13:51:35 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 13:51:35 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 13:51:37 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 3
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.666676177661691E-4; statement weight 4.922526522818089E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.6875890673843706E-4; statement weight 3.283350224245018E-7
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.6875890673843706E-4; statement weight 2.901648730630753E-7
2020.06.25 13:51:37 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:51:37 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (7,1645406931)
2020.06.25 13:51:37 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 13:51:37 [INFO] provingground.learning.HoTTBot.$anonfun:902:24 - excluded lemmas:

2020.06.25 13:51:38 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (8,-1445828818)
2020.06.25 13:51:38 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (9,-962844701)
2020.06.25 13:51:38 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (10,1833728595)
2020.06.25 13:51:37 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 13:51:41 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:51:42 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (11,368099790)
2020.06.25 13:51:42 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 13:51:42 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 13:51:42 [INFO] provingground.learning.HoTTBot.$anonfun:1009:22 - previous special init states are 2
2020.06.25 13:51:42 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 13:51:44 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:51:44 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:51:44 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (12,412426767)
2020.06.25 13:51:44 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 13:51:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (13,-2086306360)
2020.06.25 13:51:45 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 13:51:45 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (14,-1666923435), content:
TangentBaseCompleted
2020.06.25 13:51:45 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 13:51:45 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 13:51:45 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.25 13:51:45 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.25 13:51:46 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.25 13:51:46 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.25 13:51:47 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.25 13:51:46 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.25 13:51:47 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.25 13:51:48 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.25 13:51:48 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 4.0E-5
2020.06.25 13:51:49 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.25 13:51:50 [INFO] provingground.learning.HoTTBot.$anonfun:1205:26 - generating equations with 3 base states and 18 lemmas (before pruning)
2020.06.25 13:51:50 [INFO] provingground.learning.HoTTBot.$anonfun:1213:26 - Tangent lemmas (used with bases below): 3
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.040700000848968604)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),0.001214698356305945)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),0.001114032298292804)
2020.06.25 13:51:50 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 3
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.053326178457998585
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.002437424090839206
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.002437424090839206
2020.06.25 13:51:50 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.050046293108537594
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.011126917673166644
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.010695179485308265
2020.06.25 13:51:50 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.053326178457998585, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.040700000848968604, 9.920316256645221E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 13:51:49 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.25 13:51:52 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.25 13:51:55 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 4, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.25 13:51:55 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.053326178457998585

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap((mul) (m)) ∈ Funcs))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.002437424090839206
P₁(((mul) (m)) (n) ∈ Terms) -> 0.053326178457998585
P₁((mul) (m) ∈ Terms) -> 0.001286599861208855
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(n ∈ Terms) -> 0.053326178457998585
P₁(left-multiply ∈ Terms) -> 0.053326178457998585

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.002437424090839206
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(right-multiply ∈ Terms) -> 0.053326178457998585


2020.06.25 13:51:55 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.016270597645731934
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.016270597645731934
2020.06.25 13:51:55 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.08055093331491427
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.017883196935657784
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.01723230794846274
2020.06.25 13:51:55 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.040700000848968604, 6.622133379945163E-4) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 13:51:55 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.25 13:51:55 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 1.6000000000000004E-6
2020.06.25 13:51:57 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.016270597645731934
P₁(((mul) (m)) (n) ∈ Terms) -> 0.08837517523251155
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(n ∈ Terms) -> 0.08837517523251155
P₁(left-multiply ∈ Terms) -> 0.08837517523251155

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.016270597645731934
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(right-multiply ∈ Terms) -> 0.08837517523251155


2020.06.25 13:51:57 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.45000000000000007
2020.06.25 13:51:57 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.09114656135389602
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0202355433962171
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.019499036808838258
2020.06.25 13:51:57 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.45000000000000007, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.040700000848968604, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 13:51:58 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 3.2000000000000006E-7; running again
2020.06.25 13:51:59 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.45000000000000007

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 13:51:59 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 6.400000000000002E-8; running again
2020.06.25 13:52:02 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 1.2800000000000004E-8; running again
2020.06.25 13:52:04 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.5600000000000007E-9; running again
2020.06.25 13:52:06 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 5.120000000000001E-10; running again
2020.06.25 13:52:08 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 1.0240000000000002E-10; running again
2020.06.25 13:52:10 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0480000000000003E-11; running again
2020.06.25 13:52:10 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 2.0480000000000003E-11
2020.06.25 13:52:11 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-76024273)
2020.06.25 13:52:11 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,-76024273)
2020.06.25 13:52:11 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 13:52:11 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 13:52:48 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,388078373), content:
provingground.learning.ExpressionEval$$anon$2@17219b25
2020.06.25 13:52:48 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,388078373)
2020.06.25 13:52:48 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 13:52:48 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 13:52:48 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 13:52:50 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 13:53:01 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 102 steps
2020.06.25 13:53:09 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 202 steps
2020.06.25 13:53:18 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 302 steps
2020.06.25 13:53:26 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 402 steps
2020.06.25 13:53:35 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 502 steps
2020.06.25 13:53:44 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 602 steps
2020.06.25 13:53:53 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 702 steps
2020.06.25 13:54:02 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 802 steps
2020.06.25 13:54:11 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 902 steps
2020.06.25 13:54:19 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1002 steps
2020.06.25 13:54:28 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1102 steps
2020.06.25 13:54:37 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1202 steps
2020.06.25 13:54:46 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1302 steps
2020.06.25 13:54:55 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1402 steps
2020.06.25 13:55:04 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1502 steps
2020.06.25 13:55:13 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1602 steps
2020.06.25 13:55:21 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1702 steps
2020.06.25 13:55:30 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1802 steps
2020.06.25 13:55:39 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 1902 steps
2020.06.25 13:55:48 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2002 steps
2020.06.25 13:55:56 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2102 steps
2020.06.25 13:56:05 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2202 steps
2020.06.25 13:56:14 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2302 steps
2020.06.25 13:56:23 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2402 steps
2020.06.25 13:56:32 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2502 steps
2020.06.25 13:56:40 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2602 steps
2020.06.25 13:56:49 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2702 steps
2020.06.25 13:56:58 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2802 steps
2020.06.25 13:57:07 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2902 steps
2020.06.25 13:57:16 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3002 steps
2020.06.25 13:57:24 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3102 steps
2020.06.25 13:57:33 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3202 steps
2020.06.25 13:57:42 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3302 steps
2020.06.25 13:57:51 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3402 steps
2020.06.25 13:58:00 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3502 steps
2020.06.25 13:58:08 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3602 steps
2020.06.25 13:58:17 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3702 steps
2020.06.25 13:58:26 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3802 steps
2020.06.25 13:58:35 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 3902 steps
2020.06.25 13:58:44 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4002 steps
2020.06.25 13:58:52 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4102 steps
2020.06.25 13:59:01 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4202 steps
2020.06.25 13:59:10 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4302 steps
2020.06.25 13:59:19 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4402 steps
2020.06.25 13:59:28 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4502 steps
2020.06.25 13:59:36 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4602 steps
2020.06.25 13:59:45 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4702 steps
2020.06.25 13:59:54 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4802 steps
2020.06.25 14:00:03 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 4902 steps
2020.06.25 14:00:12 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 5002 steps
2020.06.25 14:00:21 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 5102 steps
2020.06.25 14:00:30 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 5202 steps
2020.06.25 14:00:38 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 5302 steps
2020.06.25 14:00:47 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 5402 steps
2020.06.25 14:00:56 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 5502 steps
2020.06.25 14:01:05 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 5602 steps
2020.06.25 14:01:08 [ERROR] provingground.learning.ExprCalc.stableVec:607:25 - Timeout for stable vector after 5641 steps
2020.06.25 14:01:08 [ERROR] provingground.learning.ExpressionEval.GenerateTyps.finalTyps:343:27 - NaN for some types before normalizing
2020.06.25 14:01:08 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,-731335603)
2020.06.25 14:01:08 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 14:01:08 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 14:01:08 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 14:01:08 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 14:01:08 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,-731335603)
2020.06.25 14:01:36 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 14:01:47 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-2126491084)
2020.06.25 14:01:47 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.565338001850545E-4; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.575115748418282E-4; statement weight NaN
Lemma: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best proof: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 3.634828069026364E-6; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best proof: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 1.596273572121328E-7; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.575115748418282E-4; statement weight NaN
2020.06.25 14:01:47 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 14:01:47 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-2126491084)
2020.06.25 14:01:47 [INFO] provingground.learning.HoTTBot.$anonfun:902:24 - excluded lemmas:

2020.06.25 14:01:47 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (19,-2126491084)
2020.06.25 14:01:47 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (20,-2126491084)
2020.06.25 14:01:47 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,-2126491084)
2020.06.25 14:01:47 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 14:01:47 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,-2126491084)
2020.06.25 14:01:48 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Steps (in final state): 3
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best proof: trans with weight 0.05648014431528924; statement weight NaN
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best proof: (left-multiply) (((mul) (m)) (n)) with weight 0.005970353792916322; statement weight NaN
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best proof: (right-multiply) (m) with weight 0.00594768428520867; statement weight NaN
2020.06.25 14:02:06 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 14:02:06 [INFO] provingground.learning.HoTTBot.$anonfun:1009:22 - previous special init states are 2
2020.06.25 14:02:06 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 14:02:14 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 14:02:14 [INFO] provingground.learning.ExprCalc.stableVec:610:46 - completed 2 steps
2020.06.25 14:02:33 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (22,-809265120)
2020.06.25 14:02:33 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 14:02:38 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (23,1294617878)
2020.06.25 14:02:38 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 14:02:38 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435), content:
TangentBaseCompleted
2020.06.25 14:02:38 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435)
2020.06.25 14:02:38 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 14:02:38 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 14:02:56 [INFO] provingground.learning.HoTTBot.$anonfun:1205:26 - generating equations with 2 base states and 0 lemmas (before pruning)
2020.06.25 14:02:56 [INFO] provingground.learning.HoTTBot.$anonfun:1213:26 - Tangent lemmas (used with bases below): 0

2020.06.25 14:02:56 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.02915229238589741
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.02915229238589741
2020.06.25 14:02:56 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 0

2020.06.25 14:02:56 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.02915229238589741, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.02915229238589741, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 14:03:01 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.02915229238589741
P₁(((mul) (m)) (n) ∈ Terms) -> 0.15834322771228476
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.15834322771228476
P₁(n ∈ Terms) -> 0.15834322771228476
P₁(left-multiply ∈ Terms) -> 0.15834322771228476

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.02915229238589741
P₁(m ∈ Terms) -> 0.15834322771228476
P₁(right-multiply ∈ Terms) -> 0.15834322771228476


2020.06.25 14:03:01 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.8999999999999999
2020.06.25 14:03:01 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 0

2020.06.25 14:03:01 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.8999999999999999, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 14:03:05 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.8999999999999999

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 15:32:54 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TautologyInitState], id: (1,-384837536), content:
TautologyInitState(TermState([m : 0.14285714285714285, sym : 0.14285714285714285, ((mul) (m)) (n) : 0.14285714285714285, refl : 0.14285714285714285, mul : 0.14285714285714285, n : 0.14285714285714285, trans : 0.14285714285714285],[M : 1.0],Vector(),[],[],Empty))
2020.06.25 15:32:54 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (2,1588327529), content:
SpecialInitState(TermState([trans : 0.9, sym : 0.1],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.05,Some(TermGenParams(0.0,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 15:32:54 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.SpecialInitState], id: (3,246182078), content:
SpecialInitState(TermState([left-multiply : 0.2, right-multiply : 0.2, ((mul) (m)) (n) : 0.2, m : 0.2, n : 0.2],[M : 1.0],Vector(),[],[],Empty),0.001,0.5,0.5,Some(TermGenParams(0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>)),Some(2))
2020.06.25 15:32:54 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.LocalProver], id: (4,582823858), content:
LocalProver(TermState([m : 0.08333333333333333, left-multiply : 0.08333333333333333, eqM : 0.08333333333333333, mul : 0.08333333333333333, n : 0.08333333333333333, trans : 0.08333333333333333, sym : 0.08333333333333333, ass1 : 0.08333333333333333, right-multiply : 0.08333333333333333, ass2 : 0.08333333333333333, refl : 0.08333333333333333, ((mul) (m)) (n) : 0.08333333333333333],[M : 1.0],Vector(),[],[((eqM) (((mul) (m)) (n))) (((mul) (n)) (m)) : 1.0],Empty),TermGenParams(0.1,0.1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.3,0.7,0.5,0.0,0.0,0.0,<function1>),1.0E-4,None,12 minutes,1.01,1.0,10000,10,1.0,1.0,None,false,false,0.5,1.0,Some(500000))
2020.06.25 15:32:54 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.LocalProver]
2020.06.25 15:33:09 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (5,1518440590), content:
provingground.learning.ExpressionEval$$anon$2@5a81908e
2020.06.25 15:33:09 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 15:33:09 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 15:33:09 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 15:33:10 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2 steps
2020.06.25 15:33:10 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (6,-1664112044)
2020.06.25 15:33:10 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 15:33:11 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 15:33:11 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 15:33:12 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 3
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.666676177661691E-4; statement weight 4.922526522818089E-5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.6875890673843706E-4; statement weight 3.283350224245018E-7
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.6875890673843706E-4; statement weight 2.901648730630753E-7
2020.06.25 15:33:12 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2 steps
2020.06.25 15:33:14 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (7,1645406931)
2020.06.25 15:33:14 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 15:33:14 [INFO] provingground.learning.HoTTBot.$anonfun:902:24 - excluded lemmas:

2020.06.25 15:33:14 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (8,-1445828818)
2020.06.25 15:33:14 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (9,-962844701)
2020.06.25 15:33:14 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (10,1833728595)
2020.06.25 15:33:14 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 15:33:16 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2 steps
2020.06.25 15:33:17 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (11,368099790)
2020.06.25 15:33:17 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 15:33:18 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 15:33:18 [INFO] provingground.learning.HoTTBot.$anonfun:1009:22 - previous special init states are 2
2020.06.25 15:33:18 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 15:33:19 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2 steps
2020.06.25 15:33:18 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2 steps
2020.06.25 15:33:20 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (12,412426767)
2020.06.25 15:33:20 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 15:33:20 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (13,-2086306360)
2020.06.25 15:33:20 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 15:33:20 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (14,-1666923435), content:
TangentBaseCompleted
2020.06.25 15:33:20 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 15:33:20 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 15:33:20 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.25 15:33:20 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.25 15:33:21 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 0.001; running again
2020.06.25 15:33:21 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 0, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.25 15:33:22 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.25 15:33:22 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.0E-4; running again
2020.06.25 15:33:23 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.25 15:33:24 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.25 15:33:24 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 4.0E-5
2020.06.25 15:33:25 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 4.0E-5; running again
2020.06.25 15:33:24 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.25 15:33:27 [INFO] provingground.learning.HoTTBot.$anonfun:1205:26 - generating equations with 3 base states and 18 lemmas (before pruning)
2020.06.25 15:33:27 [INFO] provingground.learning.HoTTBot.$anonfun:1213:26 - Tangent lemmas (used with bases below): 3
(((eqM) (((mul) (((mul) (m)) (n))) (n))) (m),0.040700000848968604)
(((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n),0.001214698356305945)
(((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)),0.001114032298292804)
2020.06.25 15:33:27 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 3
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.053326178457998585
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.002437424090839206
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.002437424090839206
2020.06.25 15:33:27 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.050046293108537594
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.011126917673166644
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.010695179485308265
2020.06.25 15:33:27 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.053326178457998585, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.040700000848968604, 9.920316256645221E-5) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.002437424090839206, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 15:33:28 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 8.000000000000001E-6; running again
2020.06.25 15:33:29 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.25 15:33:30 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 1.6000000000000004E-6; running again
2020.06.25 15:33:30 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 1.6000000000000004E-6
2020.06.25 15:33:32 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.053326178457998585

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap((mul) (m)) ∈ Funcs))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.002437424090839206
P₁(((mul) (m)) (n) ∈ Terms) -> 0.053326178457998585
P₁((mul) (m) ∈ Terms) -> 0.001286599861208855
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(n ∈ Terms) -> 0.053326178457998585
P₁(left-multiply ∈ Terms) -> 0.053326178457998585

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.002437424090839206
P₁(m ∈ Terms) -> 0.053326178457998585
P₁(right-multiply ∈ Terms) -> 0.053326178457998585


2020.06.25 15:33:32 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.016270597645731934
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.016270597645731934
2020.06.25 15:33:32 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.08055093331491427
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.017883196935657784
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.01723230794846274
2020.06.25 15:33:32 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.040700000848968604, 6.622133379945163E-4) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.016270597645731934, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 15:33:32 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 3, less than the time limit 2 minutes, with cutoff 3.2000000000000006E-7; running again
2020.06.25 15:33:34 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.016270597645731934
P₁(((mul) (m)) (n) ∈ Terms) -> 0.08837517523251155
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(n ∈ Terms) -> 0.08837517523251155
P₁(left-multiply ∈ Terms) -> 0.08837517523251155

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.016270597645731934
P₁(m ∈ Terms) -> 0.08837517523251155
P₁(right-multiply ∈ Terms) -> 0.08837517523251155


2020.06.25 15:33:34 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.45000000000000007
2020.06.25 15:33:34 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 3
Type: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best term: ((ass1) (m)) (n) with weight 0.09114656135389602
Type: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best term: ((ass2) (((mul) (m)) (n))) (n) with weight 0.0202355433962171
Type: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best term: ((ass1) (((mul) (m)) (n))) (m) with weight 0.019499036808838258
2020.06.25 15:33:34 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.45000000000000007, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.040700000848968604, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 15:33:35 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.45000000000000007

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0


2020.06.25 15:33:35 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 6.400000000000002E-8; running again
2020.06.25 15:33:37 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 1.2800000000000004E-8; running again
2020.06.25 15:33:39 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 1, less than the time limit 2 minutes, with cutoff 2.5600000000000007E-9; running again
2020.06.25 15:33:41 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 5.120000000000001E-10; running again
2020.06.25 15:33:43 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 1.0240000000000002E-10; running again
2020.06.25 15:33:45 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:178:30 - ran for time 2, less than the time limit 2 minutes, with cutoff 2.0480000000000003E-11; running again
2020.06.25 15:33:45 [INFO] provingground.learning.SimpleEquations.timedUnAppEquations:182:30 - all pairs considered with cutoff 2.0480000000000003E-11
2020.06.25 15:33:47 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,941528725)
2020.06.25 15:33:47 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes], id: (15,941528725)
2020.06.25 15:33:47 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.ExpressionEval] to posts of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 15:33:47 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes]
2020.06.25 15:34:25 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1570993492), content:
provingground.learning.ExpressionEval$$anon$2@5da37554
2020.06.25 15:34:25 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.ExpressionEval], id: (16,1570993492)
2020.06.25 15:34:25 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.FinalState] to posts of type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 15:34:25 [INFO] provingground.learning.HoTTBot.expEvToFinalState:472:26 - computing final state
2020.06.25 15:34:25 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.ExpressionEval]
2020.06.25 15:34:27 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2 steps
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -1.4000000000000044 and 0.030624999999999993 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -1.4000000000000044 and 0.030624999999999993 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -1.4000000000000044 and 0.030624999999999993 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -1.4000000000000044 and 0.030624999999999993 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -1.4000000000000044 and 0.030624999999999993 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -1.4000000000000044 and 0.030624999999999993 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.021749999999999825 and 0.0580947501931115 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -1.4000000000000046 and 0.021437499999999995 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.005240277777777764 and 0.021437499999999995 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -1.4000000000000046 and 0.021437499999999995 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.005240277777777764 and 0.021437499999999995 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.08311326313320588 and 0.04547007599012631 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -1.4000000000000046 and 0.021437499999999995 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.06362837006567315 and 0.08944921252510825 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -1.4000000000000046 and 0.021437499999999995 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.01522499999999985 and 0.040666325135178115 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -1.4000000000000046 and 0.021437499999999995 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -1.4000000000000046 and 0.021437499999999995 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.07448437604861598 and 0.060877768093709046 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.003668194444444429 and 0.015006249999999995 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.003668194444444429 and 0.015006249999999995 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.07018917854485227 and 0.06154660768149037 with exponent 0.5 is not a number
2020.06.25 15:34:27 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.07018917854485232 and 0.06154660768149037 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.08000633621822097 and 0.030815387260327936 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.08000633621822097 and 0.030815387260327936 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.08430153372198465 and 0.030143771454316168 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.0011266852500898456 and 1.6450839328537178E-4 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.0011266852500898456 and 1.6450839328537178E-4 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.0011266852500898456 and 1.6450839328537178E-4 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.020114559722477665 and 0.038847991096499716 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.01947219319630933 and 0.03884799109649972 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.003364307125357128 and 0.005465468685582884 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.01947219319630933 and 0.038847991096499716 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.24446893915284262 and 0.07197636670800606 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.02224423284816309 and 0.024317722283016496 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.0036522038798460447 and 0.00442378506568271 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.008739473147478954 and 0.0033135444805822705 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.004643528339796187 and 0.0019616538037390157 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.0036522038798460447 and 0.00442378506568271 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.0036522038798460447 and 0.00442378506568271 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.0036522038798460447 and 0.00442378506568271 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.008739473147478954 and 0.0033135444805822705 with exponent 0.5 is not a number
2020.06.25 15:34:28 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.16892647878792255 and 0.3328073535634554 with exponent 0.5 is not a number
2020.06.25 15:34:29 [ERROR] provingground.learning.ExprCalc.nextVec:588:31 - Geometric mean of -0.0037892274394858184 and 0.009128457267225925 with exponent 0.5 is not a number
2020.06.25 15:34:37 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 102 steps
2020.06.25 15:34:46 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 202 steps
2020.06.25 15:34:55 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 302 steps
2020.06.25 15:35:03 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 402 steps
2020.06.25 15:35:12 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 502 steps
2020.06.25 15:35:21 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 602 steps
2020.06.25 15:35:30 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 702 steps
2020.06.25 15:35:39 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 802 steps
2020.06.25 15:35:48 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 902 steps
2020.06.25 15:35:57 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 1002 steps
2020.06.25 15:36:06 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 1102 steps
2020.06.25 15:36:15 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 1202 steps
2020.06.25 15:36:24 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 1302 steps
2020.06.25 15:36:34 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 1402 steps
2020.06.25 15:36:43 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 1502 steps
2020.06.25 15:36:52 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 1602 steps
2020.06.25 15:37:02 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 1702 steps
2020.06.25 15:37:11 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 1802 steps
2020.06.25 15:37:20 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 1902 steps
2020.06.25 15:37:29 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2002 steps
2020.06.25 15:37:38 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2102 steps
2020.06.25 15:37:48 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2202 steps
2020.06.25 15:37:57 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2302 steps
2020.06.25 15:38:06 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2402 steps
2020.06.25 15:38:15 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2502 steps
2020.06.25 15:38:24 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2602 steps
2020.06.25 15:38:34 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2702 steps
2020.06.25 15:38:43 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2802 steps
2020.06.25 15:38:52 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2902 steps
2020.06.25 15:39:01 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 3002 steps
2020.06.25 15:39:10 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 3102 steps
2020.06.25 15:39:20 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 3202 steps
2020.06.25 15:39:29 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 3302 steps
2020.06.25 15:39:38 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 3402 steps
2020.06.25 15:39:47 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 3502 steps
2020.06.25 15:39:56 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 3602 steps
2020.06.25 15:40:06 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 3702 steps
2020.06.25 15:40:15 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 3802 steps
2020.06.25 15:40:24 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 3902 steps
2020.06.25 15:40:33 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 4002 steps
2020.06.25 15:40:43 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 4102 steps
2020.06.25 15:40:52 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 4202 steps
2020.06.25 15:41:01 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 4302 steps
2020.06.25 15:41:10 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 4402 steps
2020.06.25 15:41:19 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 4502 steps
2020.06.25 15:41:28 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 4602 steps
2020.06.25 15:41:38 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 4702 steps
2020.06.25 15:41:47 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 4802 steps
2020.06.25 15:41:56 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 4902 steps
2020.06.25 15:42:05 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 5002 steps
2020.06.25 15:42:14 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 5102 steps
2020.06.25 15:42:24 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 5202 steps
2020.06.25 15:42:33 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 5302 steps
2020.06.25 15:42:42 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 5402 steps
2020.06.25 15:42:45 [ERROR] provingground.learning.ExprCalc.stableVec:630:25 - Timeout for stable vector after 5434 steps
2020.06.25 15:42:45 [ERROR] provingground.learning.ExpressionEval.GenerateTyps.finalTyps:343:27 - NaN for some types before normalizing
2020.06.25 15:42:45 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,1448401125)
2020.06.25 15:42:45 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.Lemmas] to posts of type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 15:42:45 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 15:42:45 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 15:42:45 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.FinalState]
2020.06.25 15:42:45 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.FinalState], id: (17,1448401125)
2020.06.25 15:43:14 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2 steps
2020.06.25 15:43:26 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-2126491084)
2020.06.25 15:43:26 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Results: 5
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m); best proof: ((ass1) (m)) (n) with weight 2.565338001850545E-4; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n); best proof: ((ass2) (((mul) (m)) (n))) (n) with weight 2.575115748418282E-4; statement weight NaN
Lemma: ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))); best proof: (((sym) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (n)) (((ass2) (((mul) (m)) (n))) (n)) with weight 3.634828069026364E-6; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)); best proof: ((((left-multiply) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))) (m)) (((ass1) (m)) (n)) with weight 1.596273572121328E-7; statement weight NaN
Lemma: ((eqM) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m))) (((mul) (m)) (n)); best proof: ((ass1) (((mul) (m)) (n))) (m) with weight 2.575115748418282E-4; statement weight NaN
2020.06.25 15:43:26 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[(provingground.learning.HoTTMessages.UsedLemmas :: provingground.learning.HoTTMessages.TangentLemmas :: shapeless.HNil) :: provingground.learning.HoTTMessages.BaseMixinLemmas :: shapeless.HNil] to posts of type TypeTag[provingground.learning.HoTTMessages.Lemmas]
2020.06.25 15:43:26 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.Lemmas], id: (18,-2126491084)
2020.06.25 15:43:26 [INFO] provingground.learning.HoTTBot.$anonfun:902:24 - excluded lemmas:

2020.06.25 15:43:26 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.UsedLemmas], id: (19,-2126491084)
2020.06.25 15:43:26 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentLemmas], id: (20,-2126491084)
2020.06.25 15:43:26 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,-2126491084)
2020.06.25 15:43:26 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.post:384:20 - triggered (multiple) responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] to posts of type TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas]
2020.06.25 15:43:26 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.BaseMixinLemmas], id: (21,-2126491084)
2020.06.25 15:43:29 [INFO] provingground.learning.HoTTBot.$anonfun:376:26 - Steps (in final state): 3
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best proof: trans with weight 0.05648014431528924; statement weight NaN
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best proof: (left-multiply) (((mul) (m)) (n)) with weight 0.005970353792916322; statement weight NaN
Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best proof: (right-multiply) (m) with weight 0.00594768428520867; statement weight NaN
2020.06.25 15:43:47 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.taskNest:389:32 - launching 1 branches
2020.06.25 15:43:47 [INFO] provingground.learning.HoTTBot.$anonfun:1009:22 - previous special init states are 2
2020.06.25 15:43:47 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun:394:36 - launching 2 responses  of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState] in branch
2020.06.25 15:43:55 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2 steps
2020.06.25 15:43:55 [INFO] provingground.learning.ExprCalc.stableVec:633:46 - completed 2 steps
2020.06.25 15:44:16 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (22,-809265120)
2020.06.25 15:44:16 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 1 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 15:44:21 [INFO] provingground.learning.ErasablePostBuffer.$anon.post:85:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseState], id: (23,1294617878)
2020.06.25 15:44:21 [INFO] provingground.learning.TypedPostResponse.DualMiniBot.$anonfun.applyOrElse:399:44 - remaining 0 responses of type TypeTag[provingground.learning.HoTTMessages.TangentBaseState]
2020.06.25 15:44:21 [INFO] provingground.learning.PostBuffer.$anon.post:244:22 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435), content:
TangentBaseCompleted
2020.06.25 15:44:21 [INFO] provingground.learning.HoTTBot.scribeLog:1940:16 - Post; tag: TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type], id: (24,-1666923435)
2020.06.25 15:44:21 [INFO] provingground.learning.TypedPostResponse.MicroBot.post:227:18 - triggered response of type TypeTag[provingground.learning.HoTTMessages.GeneratedEquationNodes] to posts of type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 15:44:21 [INFO] provingground.learning.TypedPostResponse.Callback.post:188:18 - triggered callback for type TypeTag[provingground.learning.HoTTMessages.TangentBaseCompleted.type]
2020.06.25 15:44:41 [INFO] provingground.learning.HoTTBot.$anonfun:1205:26 - generating equations with 2 base states and 0 lemmas (before pruning)
2020.06.25 15:44:41 [INFO] provingground.learning.HoTTBot.$anonfun:1213:26 - Tangent lemmas (used with bases below): 0

2020.06.25 15:44:41 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 2
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))); best term: (left-multiply) (((mul) (m)) (n)) with weight 0.02915229238589741
Type: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))); best term: (right-multiply) (m) with weight 0.02915229238589741
2020.06.25 15:44:41 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 0

2020.06.25 15:44:41 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.0, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.02915229238589741, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.02915229238589741, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 15:44:47 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.0

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.02915229238589741
P₁(((mul) (m)) (n) ∈ Terms) -> 0.15834322771228476
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.15834322771228476
P₁(n ∈ Terms) -> 0.15834322771228476
P₁(left-multiply ∈ Terms) -> 0.15834322771228476

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (Coeff(Init(AtCoord(FuncsWithDomain,M :: HNil)))) * (P₀(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.02915229238589741
P₁(m ∈ Terms) -> 0.15834322771228476
P₁(right-multiply ∈ Terms) -> 0.15834322771228476


2020.06.25 15:44:47 [INFO] provingground.learning.HoTTBot.$anonfun:1227:28 - Terms in base (used with tangents above): 1
Type: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))); best term: trans with weight 0.8999999999999999
2020.06.25 15:44:47 [INFO] provingground.learning.HoTTBot.$anonfun:1239:28 - Lemmas in base for mixin (used with tangents above): 0

2020.06.25 15:44:47 [INFO] provingground.learning.HoTTBot.$anonfun:1246:28 - Inference by unified applications, triples and weights (for this base state)
(0.8999999999999999, 0.0, 0.0) for ((`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c)))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n))), (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))))
(0.0, 0.0, 0.0) for ((`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm))), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c))))), ((eqM) (((mul) (((mul) (m)) (n))) (n))) (m), ((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (((mul) (((mul) (m)) (n))) (m)))
(0.0, 0.0, 0.0) for ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m))))), ((eqM) (n)) (((mul) (((mul) (m)) (n))) (m)), ((eqM) (((mul) (n)) (m))) (((mul) (((mul) (((mul) (m)) (n))) (m))) (m)))

2020.06.25 15:44:53 [INFO] provingground.learning.HoTTBot.$anonfun:1265:28 - Tracing back equations and values for steps
Lemma: (`a : M ) ~> ((`b : M ) ~> ((`c : M ) ~> ((((eqM) (`a)) (`b)) → ((((eqM) (`b)) (`c)) → (((eqM) (`a)) (`c))))))
Traced back equations:
(P₁(trans ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(trans ∈ Terms))
Weights of terms and types:
P₁(trans ∈ Terms) -> 0.8999999999999999

Lemma: (`$afm : M ) ~> ((((eqM) (((mul) (((mul) (m)) (n))) (((mul) (((mul) (m)) (n))) (n)))) (`$afm)) → (((eqM) (n)) (`$afm)))
Traced back equations:

Weights of terms and types:


Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (((mul) (m)) (n))) (`b))) (((mul) (((mul) (m)) (n))) (`c)))))
Traced back equations:
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(((mul) (m)) (n) ∈ Terms))) * (P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((left-multiply) (((mul) (m)) (n)) ∈ Terms))
(P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(left-multiply) ∈ Funcs))) * (P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap((mul) (m)) ∈ Funcs))) * (P₁(n ∈ Terms))
(P₁(((mul) (m)) (n) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(n ∈ Terms))) * (P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁(((mul) (m)) (n) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(((mul) (m)) (n) ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ Funcs)) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((mul) (m) ∈ Terms))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(mul) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((mul) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(mul) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(n ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(n ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(n ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁(n ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(n ∈ Terms))
(P₁(Wrap((mul) (m)) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁((mul) (m) ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(Wrap(left-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(left-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(left-multiply ∈ Terms))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(left-multiply) ∈ Funcs))
(P₁(Wrap(left-multiply) ∈ Funcs)) = (P₁(left-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(((mul) (m)) (n) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(((mul) (m)) (n) ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((left-multiply) (((mul) (m)) (n)) ∈ Terms) -> 0.0
P₁(((mul) (m)) (n) ∈ Terms) -> 0.0
P₁((mul) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(n ∈ Terms) -> 0.0
P₁(left-multiply ∈ Terms) -> 0.0

Lemma: (`b : M ) ~> ((`c : M ) ~> ((((eqM) (`b)) (`c)) → (((eqM) (((mul) (`b)) (m))) (((mul) (`c)) (m)))))
Traced back equations:
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(typeOf(_),FuncsWithDomain,FlipAppn,Terms,Terms))) * (P₁(m ∈ Terms))) * (P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(FiberProductMap(domOf,TermsWithTyp,Appln,Funcs,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
(P₁((right-multiply) (m) ∈ Terms)) = ((Coeff(ZipMapOpt(UnifApplnOpt,Funcs,Terms,Terms))) * (P₁(Wrap(right-multiply) ∈ Funcs))) * (P₁(m ∈ Terms))
(P₁((right-multiply) (m) ∈ Terms)) = (Coeff(Init(Terms))) * (P₀((right-multiply) (m) ∈ Terms))
(P₁(m ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(m ∈ Terms))
(P₁(Wrap(right-multiply) ∈ AtCoord(FuncsWithDomain,M :: HNil))) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncWithDom(M))}))
(P₁(right-multiply ∈ Terms)) = (Coeff(Init(Terms))) * (P₀(right-multiply ∈ Terms))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (Coeff(Init(Funcs))) * (P₀(Wrap(right-multiply) ∈ Funcs))
(P₁(Wrap(right-multiply) ∈ Funcs)) = (P₁(right-multiply ∈ Terms)) / (P₁({Terms ∈ Restrict(FuncOpt)}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (P₁(m ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))
(P₁(m ∈ AtCoord(TermsWithTyp,M :: HNil))) = (Coeff(Init(AtCoord(TermsWithTyp,M :: HNil)))) * (P₀(m ∈ AtCoord(TermsWithTyp,M :: HNil)))
Weights of terms and types:
P₁((right-multiply) (m) ∈ Terms) -> 0.0
P₁(m ∈ Terms) -> 0.0
P₁(right-multiply ∈ Terms) -> 0.0



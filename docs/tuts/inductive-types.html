
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Inductive Types</title>
    <link rel="icon" href="../IIScLogo.jpg">

    <!-- Bootstrap -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
   <link href="../css/katex.min.css" rel="stylesheet">
   <link href="../css/main.css" rel="stylesheet">


    <link rel="stylesheet" href="../css/zenburn.css">
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

   <script src="../js/ace.js"></script>
   <script src="../js/katex.min.js"></script>

    
<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
tex2jax: {
  inlineMath: [ ['$', '$'] ],
  displayMath: [ ['$$', '$$']],
  processEscapes: true,
  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
},
messageStyle: "none",
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
       </script>
    
  </head>

   
<body>
<nav class="navbar navbar-default">
      <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <span class="navbar-brand">ProvingGround</span>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav" id="left-nav">
            <li><a href="../index.html">Docs Home</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
                Tutorials (notes)<span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="../tuts/hott.html">HoTT</a></li><li><a href="../tuts/left-and-right-identities.html">Left and Right Identities</a></li><li><a href="../tuts/internal-repetition-for-length-functions.html">Internal repetition for length functions</a></li><li><a href="../tuts/inductive-types.html">Inductive Types</a></li><li><a href="../tuts/scalarep.html">ScalaRep</a></li><li><a href="../tuts/symbolic-algebra.html">Symbolic algebra</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
                Posts<span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="../posts/computer-assistance-in-homogenous-length-functions.html">2018-1-14-Computer assistance in Homogenous length functions</a></li><li><a href="../posts/tuning-with-tensorflow.html">2017-12-12-Tuning with Tensorflow</a></li><li><a href="../posts/stalling-in-the-lean-import---the-problem-case..html">2017-12-7-Stalling in the lean import - the problem case.</a></li><li><a href="../posts/lean-import-and-propositions.html">2017-12-6-Lean Import and Propositions</a></li><li><a href="../posts/levels-of-parsimony,-as-seen-from-logic-runs.html">2017-11-2-Levels of parsimony, as seen from Logic runs</a></li><li><a href="../posts/improvements-to-searching-and--exploration.html">2017-10-31-Improvements to searching and  exploration</a></li><li><a href="../posts/logic-and-modus-ponens.html">2017-10-25-Logic and Modus Ponens</a></li><li><a href="../posts/prover-components-and-identities-in-a-monoid.html">2017-10-20-Prover Components and Identities in a Monoid</a></li><li><a href="../posts/on-import-from-lean-export-format.html">2017-10-17-On import from Lean Export format</a></li><li><a href="../posts/&quot;quasi-literate-programming&quot;.html">2014-12-31-&quot;Quasi-literate programming&quot;</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
                Notebooks<span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="../notes/2019-08-01-derived-equations.ipynb.html" target="_blank">2019-08-01-derived-equations.ipynb</a></li><li><a href="../notes/2019-09-13-cpflow.ipynb.html" target="_blank">2019-09-13-cpflow.ipynb</a></li><li><a href="../notes/2019-09-13-workflow.ipynb.html" target="_blank">2019-09-13-workflow.ipynb</a></li><li><a href="../notes/2019-09-14-topgoals.ipynb.html" target="_blank">2019-09-14-topgoals.ipynb</a></li><li><a href="../notes/2019-09-16-simple-optimize.ipynb.html" target="_blank">2019-09-16-simple-optimize.ipynb</a></li><li><a href="../notes/2019-09-17-refine-task.ipynb.html" target="_blank">2019-09-17-refine-task.ipynb</a></li><li><a href="../notes/2019-09-17-simple-optimization-constant-probs.ipynb.html" target="_blank">2019-09-17-simple-optimization-constant-probs.ipynb</a></li><li><a href="../notes/2019-09-18-monoid-unifiedapp.ipynb.html" target="_blank">2019-09-18-monoid-unifiedapp.ipynb</a></li><li><a href="../notes/2019-09-18-monoid.ipynb.html" target="_blank">2019-09-18-monoid.ipynb</a></li><li><a href="../notes/2019-09-18-refine-till-success.ipynb.html" target="_blank">2019-09-18-refine-till-success.ipynb</a></li><li><a href="../notes/2019-09-23-variable-modus-ponens.ipynb.html" target="_blank">2019-09-23-variable-modus-ponens.ipynb</a></li><li><a href="../notes/2019-10-16-variables-export.ipynb.html" target="_blank">2019-10-16-variables-export.ipynb</a></li><li><a href="../notes/2019-10-17-modus-ponens.ipynb.html" target="_blank">2019-10-17-modus-ponens.ipynb</a></li><li><a href="../notes/2019-10-18-chained-equations-monoid.ipynb.html" target="_blank">2019-10-18-chained-equations-monoid.ipynb</a></li><li><a href="../notes/2019-10-18-proof-propagation.ipynb.html" target="_blank">2019-10-18-proof-propagation.ipynb</a></li><li><a href="../notes/2019-10-21-goal-chomping.ipynb.html" target="_blank">2019-10-21-goal-chomping.ipynb</a></li><li><a href="../notes/2019-10-21-liberal-goal-chomping.ipynb.html" target="_blank">2019-10-21-liberal-goal-chomping.ipynb</a></li><li><a href="../notes/2019-10-22-memo-liberal-chomper.ipynb.html" target="_blank">2019-10-22-memo-liberal-chomper.ipynb</a></li><li><a href="../notes/2019-10-22-newmemo-liberal-chomper.ipynb.html" target="_blank">2019-10-22-newmemo-liberal-chomper.ipynb</a></li><li><a href="../notes/2019-10-23-chomper-memo-newlookup.ipynb.html" target="_blank">2019-10-23-chomper-memo-newlookup.ipynb</a></li><li><a href="../notes/2019-10-25-entropies.ipynb.html" target="_blank">2019-10-25-entropies.ipynb</a></li><li><a href="../notes/2019-11-12-Achal-CzechSlovakOlympiad.ipynb.html" target="_blank">2019-11-12-Achal-CzechSlovakOlympiad.ipynb</a></li><li><a href="../notes/2019-11-13-CzechSlovakOlympAppOnly.ipynb.html" target="_blank">2019-11-13-CzechSlovakOlympAppOnly.ipynb</a></li><li><a href="../notes/2019-11-13-CzechSlovakOlympCod.ipynb.html" target="_blank">2019-11-13-CzechSlovakOlympCod.ipynb</a></li><li><a href="../notes/2019-11-13-CzechSlovakOlympExplore.ipynb.html" target="_blank">2019-11-13-CzechSlovakOlympExplore.ipynb</a></li><li><a href="../notes/2019-11-13-codomain-target.ipynb.html" target="_blank">2019-11-13-codomain-target.ipynb</a></li><li><a href="../notes/2019-11-14-CzechSlovakOlympTillSuccess.ipynb.html" target="_blank">2019-11-14-CzechSlovakOlympTillSuccess.ipynb</a></li><li><a href="../notes/2019-11-14-CzechSlovakOlympWithMN.ipynb.html" target="_blank">2019-11-14-CzechSlovakOlympWithMN.ipynb</a></li><li><a href="../notes/2019-11-14-equation-generation.ipynb.html" target="_blank">2019-11-14-equation-generation.ipynb</a></li><li><a href="../notes/2019-11-15-CzechSlovakOlySteps.ipynb.html" target="_blank">2019-11-15-CzechSlovakOlySteps.ipynb</a></li><li><a href="../notes/2019-11-18-depth-bound.ipynb.html" target="_blank">2019-11-18-depth-bound.ipynb</a></li><li><a href="../notes/2019-11-21-skolemize-test.ipynb.html" target="_blank">2019-11-21-skolemize-test.ipynb</a></li><li><a href="../notes/2019-11-25-export-normalize-isles.ipynb.html" target="_blank">2019-11-25-export-normalize-isles.ipynb</a></li><li><a href="../notes/2019-11-27-afterfix-export-normalize-isles-refine.ipynb.html" target="_blank">2019-11-27-afterfix-export-normalize-isles-refine.ipynb</a></li><li><a href="../notes/2019-11-27-export-normalize-isles-refine.ipynb.html" target="_blank">2019-11-27-export-normalize-isles-refine.ipynb</a></li><li><a href="../notes/2019-11-27-simplified-export-normalize-isles-refine.ipynb.html" target="_blank">2019-11-27-simplified-export-normalize-isles-refine.ipynb</a></li><li><a href="../notes/2019-11-27tworfixes-export-normalize-isles-refine.ipynb.html" target="_blank">2019-11-27tworfixes-export-normalize-isles-refine.ipynb</a></li><li><a href="../notes/2019-11-28-export-normalize-isles-refine.ipynb.html" target="_blank">2019-11-28-export-normalize-isles-refine.ipynb</a></li><li><a href="../notes/2019-11-28-with-independent-export-normalize-isles-refine.ipynb.html" target="_blank">2019-11-28-with-independent-export-normalize-isles-refine.ipynb</a></li><li><a href="../notes/2019-12-02-recisles-with-independent-export-normalize-isles-refine-rhsmodify.ipynb.html" target="_blank">2019-12-02-recisles-with-independent-export-normalize-isles-refine-rhsmodify.ipynb</a></li><li><a href="../notes/2019-12-02-recisles-with-independent-export-normalize-isles-refine.ipynb.html" target="_blank">2019-12-02-recisles-with-independent-export-normalize-isles-refine.ipynb</a></li><li><a href="../notes/2019-12-02-with-independent-export-normalize-isles-refine.ipynb.html" target="_blank">2019-12-02-with-independent-export-normalize-isles-refine.ipynb</a></li><li><a href="../notes/2020-05-25-BotMonoid.ipynb.html" target="_blank">2020-05-25-BotMonoid.ipynb</a></li><li><a href="../notes/2020-05-26-bot-modus-ponens.ipynb.html" target="_blank">2020-05-26-bot-modus-ponens.ipynb</a></li><li><a href="../notes/Bird-Cooccurences.ipynb.html" target="_blank">Bird-Cooccurences.ipynb</a></li><li><a href="../notes/CzechSlovakLemmas.ipynb.html" target="_blank">CzechSlovakLemmas.ipynb</a></li><li><a href="../notes/EquationsMonoid.ipynb.html" target="_blank">EquationsMonoid.ipynb</a></li><li><a href="../notes/Evilplot.ipynb.html" target="_blank">Evilplot.ipynb</a></li><li><a href="../notes/Futures.ipynb.html" target="_blank">Futures.ipynb</a></li><li><a href="../notes/GenerateInductive.ipynb.html" target="_blank">GenerateInductive.ipynb</a></li><li><a href="../notes/HoTT.html" target="_blank">HoTT</a></li><li><a href="../notes/HoTT.ipynb.html" target="_blank">HoTT.ipynb</a></li><li><a href="../notes/HoTTCoreExperiments.ipynb.html" target="_blank">HoTTCoreExperiments.ipynb</a></li><li><a href="../notes/Inductive-Types-semi-explicit.ipynb.html" target="_blank">Inductive-Types-semi-explicit.ipynb</a></li><li><a href="../notes/ModPon.ipynb.html" target="_blank">ModPon.ipynb</a></li><li><a href="../notes/ModusPonens.ipynb.html" target="_blank">ModusPonens.ipynb</a></li><li><a href="../notes/MonoidBack.ipynb.html" target="_blank">MonoidBack.ipynb</a></li><li><a href="../notes/MonoidProof.html" target="_blank">MonoidProof</a></li><li><a href="../notes/MonoidProof.ipynb.html" target="_blank">MonoidProof.ipynb</a></li><li><a href="../notes/NatId.ipynb.html" target="_blank">NatId.ipynb</a></li><li><a href="../notes/NaturalLanguageParsing-simple-examples.ipynb.html" target="_blank">NaturalLanguageParsing-simple-examples.ipynb</a></li><li><a href="../notes/NaturalNumbers-SymbolicAlgebra.ipynb.html" target="_blank">NaturalNumbers-SymbolicAlgebra.ipynb</a></li><li><a href="../notes/PutnamOlympaid.ipynb.html" target="_blank">PutnamOlympaid.ipynb</a></li><li><a href="../notes/Putnum.ipynb.html" target="_blank">Putnum.ipynb</a></li><li><a href="../notes/ScalaRep.ipynb.html" target="_blank">ScalaRep.ipynb</a></li><li><a href="../notes/VectorTypeFamily.ipynb.html" target="_blank">VectorTypeFamily.ipynb</a></li><li><a href="../notes/index.html" target="_blank">index</a></li><li><a href="../notes/svg-experiments.ipynb.html" target="_blank">svg-experiments.ipynb</a></li>
              </ul>
            </li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li> <a href="../scaladoc/provingground/index.html" target="_blank">ScalaDocs</a></li>
            <li> <a href="https://github.com/siddhartha-gadgil/ProvingGround" target="_blank">
              <img src="../GitHub-Mark-Light-32px.png" alt="Github"></img> </a> </li>
          <li>
            <a href="https://gitter.im/siddhartha-gadgil/ProvingGround" target="_blank">
              <img src="https://badges.gitter.im/siddhartha-gadgil/ProvingGround.svg" alt="gitter"></img>
            </a>
          </li>


          </ul>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container-fluid -->
    </nav>
<div class="container">

<h1 class="text-center">Inductive Types</h1>

<div class="text-justify">
<h2>Recursion for inductive types</h2>
<p>We illustrate construction of inductive types, and defining functions on them recursively.</p>
<p>We begin with some imports. The import induction.TLImplicits gives the operations to construct inductive types.</p>
<pre><code class="language-scala">import provingground._
import HoTT._
import induction._
import translation._
import TLImplicits._
import shapeless._
</code></pre>
<p>We do not define inductive types, but instead define the <em>structure of an inductive type</em> on a given, typically symbolic type.</p>
<p>The inductive structure is defined using a DSL to specify constructors. The Boolean type has constants true and false as constructors.
Constructors are obtained using the <code>:::</code> method on a <em>Constructor pattern</em>, which for constants is essentially the inductive type itself.</p>
<pre><code class="language-scala">val Bool = &quot;Boolean&quot; :: Type
// Bool: Typ[Term] = Boolean
val BoolInd = &quot;true&quot; ::: Bool |: &quot;false&quot; ::: Bool =: Bool
// BoolInd: ConstructorSeqTL[HNil :: HNil :: HNil, Term, Term :: Term :: HNil] = ConstructorSeqTL(Cons(true,IdShape(),Cons(false,IdShape(),Empty())),Boolean)
</code></pre>
<p>From the inductive structure, we can obtain the introduction rules.</p>
<pre><code class="language-scala">val tt :: ff :: HNil = BoolInd.intros
// tt: Term = true
// ff: Term = false
tt
// res0: Term = true
ff
// res1: Term = false
</code></pre>
<p>The most important methods on an inductive structure are the <code>rec</code> method for making recursive definition on the inductive type,
and the corresponding method for dependent functions. The rec method takes as arguments the data giving the definition for the various constructors.</p>
<pre><code class="language-scala">BoolInd.rec(Bool)
// res2: Func[Term, Func[Term, Func[Term, Term]]] = (`RecDataSym(true) :  Boolean) ↦ ((`RecDataSym(false) :  Boolean) ↦ (rec(Boolean)(Boolean)(`RecDataSym(true))(`RecDataSym(false))))
val recBoolBool = BoolInd.rec(Bool)
// recBoolBool: Func[Term, Func[Term, Func[Term, Term]]] = (`RecDataSym(true) :  Boolean) ↦ ((`RecDataSym(false) :  Boolean) ↦ (rec(Boolean)(Boolean)(`RecDataSym(true))(`RecDataSym(false))))
recBoolBool.typ
// res3: Typ[Func[Term, Func[Term, Func[Term, Term]]]] = (Boolean) → ((Boolean) → ((Boolean) → (Boolean)))
</code></pre>
<p>We can define functions recursively using terms obtained from the <code>rec</code> method.
In the case of Booleans, the arguments are just the value of the function at true and false. The result is a function <code>f: Bool -&gt;: X</code> for a type <code>X</code></p>
<pre><code class="language-scala">val not = recBoolBool(ff)(tt)
// not: Func[Term, Term] = rec(Boolean)(Boolean)(false)(true)
not(ff)
// res4: Term = true
not(tt)
// res5: Term = false
assert(not(ff) == tt &amp;&amp; not(tt) == ff)
</code></pre>
<p>We can similarly define the <em>and</em> function by observing that <em>and(true)</em> is the identity and <em>and(false)</em> is the constant false function.</p>
<pre><code class="language-scala">val b = &quot;b&quot; :: Bool
// b: Term = b
val recBBB = BoolInd.rec(Bool -&gt;: Bool)
// recBBB: Func[Func[Term, Term], Func[Func[Term, Term], Func[Term, Func[Term, Term]]]] = (`RecDataSym(true) :  (Boolean) → (Boolean)) ↦ ((`RecDataSym(false) :  (Boolean) → (Boolean)) ↦ (rec(Boolean)((Boolean) → (Boolean))(`RecDataSym(true))(`RecDataSym(false))))
recBBB.typ
// res7: Typ[Func[Func[Term, Term], Func[Func[Term, Term], Func[Term, Func[Term, Term]]]]] = ((Boolean) → (Boolean)) → (((Boolean) → (Boolean)) → ((Boolean) → ((Boolean) → (Boolean))))
val and = recBBB(lmbda(b)(b))(lmbda(b)(ff))
// and: Func[Term, Func[Term, Term]] = rec(Boolean)((Boolean) → (Boolean))((`b :  Boolean) ↦ (`b))((b :  Boolean) ↦ (false))
</code></pre>
<pre><code class="language-scala">and(tt)(tt)
// res8: Term = true
and(tt)(ff)
// res9: Term = false
and(ff)(ff)
// res10: Term = false
and(ff)(tt)
// res11: Term = false
assert(and(tt)(tt)== tt &amp;&amp; and(tt)(ff) == ff &amp;&amp; and(ff)(tt) == ff &amp;&amp; and(ff)(ff) == ff)
</code></pre>
<p>The natural numbers <code>Nat</code> are an inductive type with two constructors, <code>zero</code> and <code>succ</code>, of types <code>Nat</code> and <code>Nat -&gt;: Nat</code>, respectively.
The method on constructors corresponding to function types we use if <code>--&gt;&gt;:</code>, which is used because the domain of the extension is also the type <code>Nat</code>. Note that extending the constructor by a constant type is very different (as we see with lists below), and a different method is used.</p>
<pre><code class="language-scala">val Nat = &quot;Nat&quot; :: Type
// Nat: Typ[Term] = Nat
val NatInd = (&quot;0&quot; ::: Nat) |: (&quot;succ&quot; ::: Nat --&gt;&gt;: Nat) =: Nat
// NatInd: ConstructorSeqTL[HNil :: ConstructorShape.FuncConsShape.type :: HNil :: HNil, Term, Term :: Func[Term, Term] :: HNil] = ConstructorSeqTL(Cons(0,IdShape(),Cons(succ,FuncConsShape(IdIterShape(),IdShape()),Empty())),Nat)
val zero :: succ :: HNil = NatInd.intros
// zero: Term = 0
// succ: Func[Term, Term] = succ
</code></pre>
<p>To define recursively a function <code>f : Nat -&gt;: X</code> for a type <code>X</code>, the data is</p>
<ul>
<li><code>f(zero) : X</code>, i.e., data of type <code>X</code></li>
<li><code>f(succ(n)) : X</code> as a function of <code>n : Nat</code> and <code>x: X</code>, i.e., data is of the form <code>Nat -&gt;: X -&gt;: X</code></li>
</ul>
<pre><code class="language-scala">val recNatBool = NatInd.rec(Bool)
// recNatBool: Func[Term, Func[Func[Term, Func[Term, Term]], Func[Term, Term]]] = (`RecDataSym(0) :  Boolean) ↦ ((`RecDataSym(succ) :  (Nat) → ((Boolean) → (Boolean))) ↦ (rec(Nat)(Boolean)(`RecDataSym(0))(`RecDataSym(succ))))
recNatBool.typ
// res13: Typ[Func[Term, Func[Func[Term, Func[Term, Term]], Func[Term, Term]]]] = (Boolean) → (((Nat) → ((Boolean) → (Boolean))) → ((Nat) → (Boolean)))
val n = &quot;n&quot; :: Nat
// n: Term = n
val even = recNatBool(tt)(n :-&gt; (b :-&gt; not(b)))
// even: Func[Term, Term] = rec(Nat)(Boolean)(true)((n :  Nat) ↦ ((`b :  Boolean) ↦ ((rec(Boolean)(Boolean)(false)(true)) (`b))))
</code></pre>
<pre><code class="language-scala">val one = succ(zero)
// one: Term = (succ) (0)
val two = succ(one)
// two: Term = (succ) ((succ) (0))
val three = succ(two)
// three: Term = (succ) ((succ) ((succ) (0)))
val four = succ(three)
// four: Term = (succ) ((succ) ((succ) ((succ) (0))))
even(two)
// res14: Term = true
even(three)
// res15: Term = false
</code></pre>
<p>A more complicated example is addition of natural numbers.</p>
<pre><code class="language-scala">val recNNN = NatInd.rec(Nat -&gt;: Nat)
// recNNN: Func[Func[Term, Term], Func[Func[Term, Func[Func[Term, Term], Func[Term, Term]]], Func[Term, Func[Term, Term]]]] = (`RecDataSym(0) :  (Nat) → (Nat)) ↦ ((`RecDataSym(succ) :  (Nat) → (((Nat) → (Nat)) → ((Nat) → (Nat)))) ↦ (rec(Nat)((Nat) → (Nat))(`RecDataSym(0))(`RecDataSym(succ))))
recNNN.typ
// res16: Typ[Func[Func[Term, Term], Func[Func[Term, Func[Func[Term, Term], Func[Term, Term]]], Func[Term, Func[Term, Term]]]]] = ((Nat) → (Nat)) → (((Nat) → (((Nat) → (Nat)) → ((Nat) → (Nat)))) → ((Nat) → ((Nat) → (Nat))))
val m = &quot;m&quot; :: Nat
// m: Term = m
val addn = &quot;add(n)&quot; :: Nat -&gt;: Nat
// addn: Func[Term, Term] = add(n)
val add = recNNN(m :-&gt; m)(n :-&gt; (addn :-&gt; (m :-&gt; (succ(addn(m))) ) ) )
// add: Func[Term, Func[Term, Term]] = rec(Nat)((Nat) → (Nat))((`m :  Nat) ↦ (`m))((n :  Nat) ↦ ((`add(n) :  (Nat) → (Nat)) ↦ ((`m :  Nat) ↦ ((succ) ((`add(n)) (`m))))))
</code></pre>
<pre><code class="language-scala">add(two)(one)
// res17: Term = (succ) ((succ) ((succ) (0)))
assert(add(two)(one) == three)
add(two)(two) == four
// res19: Boolean = true
</code></pre>
<p>Lists of elements of a type <code>A</code> form an inductive type <code>ListA</code>, again with two constructors:</p>
<ul>
<li><code>nil</code> of type <code>ListA</code></li>
<li><code>cons</code> of type <code>A -&gt;: ListA -&gt;: ListA</code></li>
</ul>
<p>A recursively defined function <code>f</code> to a type <code>X</code> is specified by data:</p>
<ul>
<li><code>f(nil) : X</code></li>
<li><code>f(cons(a)(l))</code> as a function of <code>a</code>, <code>l</code> and 'f(l)', i.e., data has type <code>A -&gt;: ListA -&gt;: X -&gt;: X</code>.</li>
</ul>
<p>Note that <code>f(a)</code> does not make sense. Hence a different method, <code>-&gt;&gt;:</code>, is used for such extensions.</p>
<pre><code class="language-scala">val A = &quot;A&quot; :: Type
// A: Typ[Term] = A
val ListA = &quot;List(A)&quot; :: Type
// ListA: Typ[Term] = List(A)
val ListAInd = (&quot;nil&quot; ::: ListA) |: (&quot;cons&quot; ::: A -&gt;&gt;: ListA --&gt;&gt;: ListA ) =: ListA
// ListAInd: ConstructorSeqTL[HNil :: ConstructorShape.CnstFuncConsShape.type :: ConstructorShape.FuncConsShape.type :: HNil :: HNil, Term, Term :: Func[Term, Func[Term, Term]] :: HNil] = ConstructorSeqTL(Cons(nil,IdShape(),Cons(cons,CnstFuncConsShape(A,FuncConsShape(IdIterShape(),IdShape())),Empty())),List(A))
val nil :: cons :: HNil = ListAInd.intros
// nil: Term = nil
// cons: Func[Term, Func[Term, Term]] = cons
</code></pre>
<p>We can define the size of a list as a natural number recursively.</p>
<pre><code class="language-scala">val recLN = ListAInd.rec(Nat)
// recLN: Func[Term, Func[Func[Term, Func[Term, Func[Term, Term]]], Func[Term, Term]]] = (`RecDataSym(nil) :  Nat) ↦ ((`RecDataSym(cons) :  (A) → ((List(A)) → ((Nat) → (Nat)))) ↦ (rec(List(A))(Nat)(`RecDataSym(nil))(`RecDataSym(cons))))
recLN.typ
// res20: Typ[Func[Term, Func[Func[Term, Func[Term, Func[Term, Term]]], Func[Term, Term]]]] = (Nat) → (((A) → ((List(A)) → ((Nat) → (Nat)))) → ((List(A)) → (Nat)))
val a = &quot;a&quot; :: A
// a: Term = a
val l = &quot;l&quot; :: ListA
// l: Term = l
</code></pre>
<pre><code class="language-scala">val size = recLN(zero)(a :-&gt; (l :-&gt; (n :-&gt; (succ(n)))))
// size: Func[Term, Term] = rec(List(A))(Nat)(0)((a :  A) ↦ ((l :  List(A)) ↦ ((`n :  Nat) ↦ ((succ) (`n)))))
size(nil)
// res21: Term = 0
size(cons(a)(cons(a)(nil)))
// res22: Term = (succ) ((succ) (0))
</code></pre>
<p>Another interesting inductive type is a binary rooted tree. This is our first description.
We define the number of vertices recursively on this.</p>
<pre><code class="language-scala">val T = &quot;Tree&quot; :: Type
// T: Typ[Term] = Tree
val TInd = (&quot;leaf&quot; ::: T) |: (&quot;node&quot; ::: T --&gt;&gt;: T --&gt;&gt;: T) =: T
// TInd: ConstructorSeqTL[HNil :: ConstructorShape.FuncConsShape.type :: ConstructorShape.FuncConsShape.type :: HNil :: HNil, Term, Term :: Func[Term, Func[Term, Term]] :: HNil] = ConstructorSeqTL(Cons(leaf,IdShape(),Cons(node,FuncConsShape(IdIterShape(),FuncConsShape(IdIterShape(),IdShape())),Empty())),Tree)
val leaf :: node :: HNil = TInd.intros
// leaf: Term = leaf
// node: Func[Term, Func[Term, Term]] = node
val ttt = node(node(leaf)(node(leaf)(leaf)))(node(leaf)(leaf))
// ttt: Term = ((node) (((node) (leaf)) (((node) (leaf)) (leaf)))) (((node) (leaf)) (leaf))
</code></pre>
<pre><code class="language-scala">val recTN = TInd.rec(Nat)
// recTN: Func[Term, Func[Func[Term, Func[Term, Func[Term, Func[Term, Term]]]], Func[Term, Term]]] = (`RecDataSym(leaf) :  Nat) ↦ ((`RecDataSym(node) :  (Tree) → ((Nat) → ((Tree) → ((Nat) → (Nat))))) ↦ (rec(Tree)(Nat)(`RecDataSym(leaf))(`RecDataSym(node))))
recTN.typ
// res23: Typ[Func[Term, Func[Func[Term, Func[Term, Func[Term, Func[Term, Term]]]], Func[Term, Term]]]] = (Nat) → (((Tree) → ((Nat) → ((Tree) → ((Nat) → (Nat))))) → ((Tree) → (Nat)))
</code></pre>
<pre><code class="language-scala">val t1 = &quot;t1&quot; :: T
// t1: Term = t1
val t2 = &quot;t2&quot; :: T
// t2: Term = t2

val vertices = recTN(one)(t1 :-&gt; (m :-&gt;( t2 :-&gt; (n :-&gt; (succ(add(n)(m))  ) ) ) ) )
// vertices: Func[Term, Term] = rec(Tree)(Nat)((succ) (0))((t1 :  Tree) ↦ ((`m :  Nat) ↦ ((t2 :  Tree) ↦ ((`n :  Nat) ↦ ((succ) (((rec(Nat)((Nat) → (Nat))((`m :  Nat) ↦ (`m))((`n :  Nat) ↦ ((`add(n) :  (Nat) → (Nat)) ↦ ((`m :  Nat) ↦ ((succ) ((`add(n)) (`m))))))) (`n)) (`m)))))))
</code></pre>
<pre><code class="language-scala">vertices(ttt)
// res24: Term = (succ) ((succ) ((succ) ((succ) ((succ) ((succ) ((succ) ((succ) ((succ) (0)))))))))
</code></pre>
<pre><code class="language-scala">val nine = succ(add(four)(four))
// nine: Term = (succ) ((succ) ((succ) ((succ) ((succ) ((succ) ((succ) ((succ) ((succ) (0)))))))))
vertices(ttt) == nine
// res25: Boolean = true
assert(vertices(ttt) == nine)
</code></pre>
<p>We can implement binary trees in another way, which generalizes to binary rooted trees with varying degree.
Instead of a pair of trees, a node corresponds to functions from Booleans to binary rooted trees.</p>
<p>This involves more complex constructors, with an additional method <code>-|&gt;:</code>.
The data for recursively defining <code>f</code> is also more complex.
We define the number of leaves in such a tree recursively.</p>
<pre><code class="language-scala">val BT = &quot;BinTree&quot; :: Type
// BT: Typ[Term] = BinTree
val BTInd = (&quot;leaf&quot; ::: BT) |: (&quot;node&quot; ::: (Bool -|&gt;: BT) --&gt;&gt;: BT )  =: BT
// BTInd: ConstructorSeqTL[HNil :: ConstructorShape.FuncConsShape.type :: HNil :: HNil, Term, Term :: Func[Func[Term, Term], Term] :: HNil] = ConstructorSeqTL(Cons(leaf,IdShape(),Cons(node,FuncConsShape(FuncShape(Boolean,IdIterShape()),IdShape()),Empty())),BinTree)
val bleaf :: bnode :: HNil = BTInd.intros
// bleaf: Term = leaf
// bnode: Func[Func[Term, Term], Term] = node
val recBTN = BTInd.rec(Nat)
// recBTN: Func[Term, Func[Func[Func[Term, Term], Func[Func[Term, Term], Term]], Func[Term, Term]]] = (`RecDataSym(leaf) :  Nat) ↦ ((`RecDataSym(node) :  ((Boolean) → (BinTree)) → (((Boolean) → (Nat)) → (Nat))) ↦ (rec(BinTree)(Nat)(`RecDataSym(leaf))(`RecDataSym(node))))
</code></pre>
<pre><code class="language-scala">recBTN.typ
// res27: Typ[Func[Term, Func[Func[Func[Term, Term], Func[Func[Term, Term], Term]], Func[Term, Term]]]] = (Nat) → ((((Boolean) → (BinTree)) → (((Boolean) → (Nat)) → (Nat))) → ((BinTree) → (Nat)))
</code></pre>
<pre><code class="language-scala">val f = &quot;f&quot; :: Bool -&gt;: BT
// f: Func[Term, Term] = f
val g = &quot;g&quot; :: Bool -&gt;: Nat
// g: Func[Term, Term] = g
val leaves = recBTN(one)(f :-&gt; (g :-&gt; (add(g(ff))(g(tt))) ))
// leaves: Func[Term, Term] = rec(BinTree)(Nat)((succ) (0))((f :  (Boolean) → (BinTree)) ↦ ((`g :  (Boolean) → (Nat)) ↦ (((rec(Nat)((Nat) → (Nat))((`m :  Nat) ↦ (`m))((n :  Nat) ↦ ((`add(n) :  (Nat) → (Nat)) ↦ ((`m :  Nat) ↦ ((succ) ((`add(n)) (`m))))))) ((`g) (false))) ((`g) (true)))))
leaves(bleaf)
// res28: Term = (succ) (0)
</code></pre>
<pre><code class="language-scala">val t = bnode(b :-&gt; bleaf)
// t: Term = (node) ((b :  Boolean) ↦ (leaf))
val recBBT = BoolInd.rec(BT)
// recBBT: Func[Term, Func[Term, Func[Term, Term]]] = (`RecDataSym(true) :  BinTree) ↦ ((`RecDataSym(false) :  BinTree) ↦ (rec(Boolean)(BinTree)(`RecDataSym(true))(`RecDataSym(false))))
recBBT.typ
// res29: Typ[Func[Term, Func[Term, Func[Term, Term]]]] = (BinTree) → ((BinTree) → ((Boolean) → (BinTree)))
</code></pre>
<pre><code class="language-scala">val ttn = recBBT(bleaf)(t)
// ttn: Func[Term, Term] = rec(Boolean)(BinTree)(leaf)((node) ((b :  Boolean) ↦ (leaf)))
val t2n = bnode(ttn)
// t2n: Term = (node) (rec(Boolean)(BinTree)(leaf)((node) ((b :  Boolean) ↦ (leaf))))
leaves(t2n)
// res30: Term = (succ) ((succ) ((succ) (0)))
</code></pre>
<p>As some expresssions are very long, we import a method &quot;FansiShow&quot; that prints in a more concise way.
In the REPL, this gives coloured output using ANSI strings.</p>
<pre><code class="language-scala">import FansiShow._
</code></pre>
<p>We define the double of a number recursively, mainly for use later. Observe the partial simplification.</p>
<pre><code class="language-scala">val recNN = NatInd.rec(Nat)
// recNN: Func[Term, Func[Func[Term, Func[Term, Term]], Func[Term, Term]]] = (`RecDataSym(0) :  Nat) ↦ ((`RecDataSym(succ) :  (Nat) → ((Nat) → (Nat))) ↦ (rec(Nat)(Nat)(`RecDataSym(0))(`RecDataSym(succ))))
val double = recNN(zero)(m :-&gt; (n :-&gt; (succ(succ(n)))))
// double: Func[Term, Term] = rec(Nat)(Nat)(0)((m :  Nat) ↦ ((`n :  Nat) ↦ ((succ) ((succ) (`n)))))
</code></pre>
<pre><code class="language-scala">double(two) == four
// res31: Boolean = true
assert(double(two) == four)
double(succ(n))
// res33: Term = (succ) ((succ) ((rec(Nat)(Nat)(0)((m :  Nat) ↦ ((`n :  Nat) ↦ ((succ) ((succ) (`n)))))) (n)))
</code></pre>
<p>All our recursive definitions so far of functions <code>f</code> have ignored <code>n</code> in defining <code>f(succ(n))</code>,
and are only in terms of <code>f(n)</code>. We see a more complex definition, the sum of numbers up to <code>n</code>.
Note that we are defining <code>sumTo(succ(m))</code> in terms of <code>m</code> and <code>n = sumTo(m)</code>, so this is <code>add(succ(m))(n)</code></p>
<pre><code class="language-scala">val sumTo = recNN(zero)(m :-&gt; (n :-&gt; (add(succ(m))(n))))
// sumTo: Func[Term, Term] = rec(Nat)(Nat)(0)((`m :  Nat) ↦ ((`n :  Nat) ↦ ((succ) (((rec(Nat)((Nat) → (Nat))((`m :  Nat) ↦ (`m))((`n :  Nat) ↦ ((`add(n) :  (Nat) → (Nat)) ↦ ((``m :  Nat) ↦ ((succ) ((`add(n)) (``m))))))) (`m)) (`n)))))
sumTo(one)
// res34: Term = (succ) (0)
sumTo(three).fansi
// res35: String = succ(succ(succ(succ(succ(succ(0))))))
</code></pre>
<pre><code class="language-scala">val ten = succ(nine)
// ten: Term = (succ) ((succ) ((succ) ((succ) ((succ) ((succ) ((succ) ((succ) ((succ) ((succ) (0))))))))))
sumTo(four) == ten
// res36: Boolean = true
</code></pre>
<pre><code class="language-scala">assert(sumTo(four) == ten)
</code></pre>
<h2>Inductive definitions</h2>
<p>In homotopy type theory, inductive definitions are the analogues of recursive definitions for dependent functions.
We see an example of such a definition.</p>
<p>The image is a family <code>V : Nat -&gt;: Type</code> which we can think of as vectors of natural numbers indexed by length.
Just like actual vectors, we have <code>nil</code> and <code>cons</code> introduction rules, but here they are purely formal.</p>
<pre><code class="language-scala">val V = &quot;Vec&quot; :: Nat -&gt;: Type
// V: Func[Term, Typ[Term]] = Vec
val nilv = &quot;nil&quot; :: V(zero)
// nilv: Term = nil
val consv = &quot;cons&quot; :: n ~&gt;: (Nat -&gt;: V(n) -&gt;: V(succ(n)))
// consv: FuncLike[Term, Func[Term, Func[Term, Term]]] = cons
</code></pre>
<p>We have an induction function taking data for the cases and returning a dependent function.
This is defined by giving data for cases corresponding to the constructors.
Namely to define the dependent function <code>f</code>, we must specify</p>
<ul>
<li><code>f(zero)</code> of type <code>V(zero)</code></li>
<li><code>f(succ(m))</code> of type <code>V(succ(m))</code>, as a dependent function of <code>m</code> and of <code>f(m) : V(m)</code>.</li>
</ul>
<p>We define inductively a countdown function, giving the vector counting down from <code>n</code>.</p>
<pre><code class="language-scala">val indNV = NatInd.induc(V)
// indNV: Func[Term, Func[FuncLike[Term, Func[Term, Term]], FuncLike[Term, Term]]] = (`InducDataSym(0) :  (Vec) (0)) ↦ ((`InducDataSym(succ) :  (`$anasn : Nat ) ~&gt; (((Vec) (`$anasn)) → ((Vec) ((succ) (`$anasn))))) ↦ (ind(Nat)(Vec)(`InducDataSym(0))(`InducDataSym(succ))))

val v = &quot;v_m&quot; :: V(m)
// v: Term = v_m
val countdown = indNV(nilv)(m :~&gt; (v :-&gt; consv(m)(succ(m))(v)) )
// countdown: FuncLike[Term, Term] = ind(Nat)(Vec)(nil)((`m :  Nat) ↦ ((``v_m :  (Vec) (`m)) ↦ ((((cons) (`m)) ((succ) (`m))) (``v_m))))
</code></pre>
<pre><code class="language-scala">countdown(zero)
// res38: Term = nil
countdown(one)
// res39: Term = (((cons) (0)) ((succ) (0))) (nil)
countdown(one).fansi
// res40: String = cons(0)(succ(0))(nil)
countdown(three).fansi
// res41: String = cons(succ(succ(0)))(succ(succ(succ(0))))(cons(succ(0))(succ(succ(0)))(cons(0)(succ(0))(nil)))
</code></pre>
<pre><code class="language-scala">assert(countdown(three) ==
  consv(two)(three)(
    consv(one)(two)(
      consv(zero)(one)(nilv))))
</code></pre>
<pre><code class="language-scala">countdown(zero) == nilv
// res43: Boolean = true
countdown(nine).fansi
// res44: String = cons(succ(succ(succ(succ(succ(succ(succ(succ(0)))))))))(succ(succ(succ(succ(succ(succ(succ(succ(succ(0))))))))))(cons(succ(succ(succ(succ(succ(succ(succ(0))))))))(succ(succ(succ(succ(succ(succ(succ(succ(0)))))))))(cons(succ(succ(succ(succ(succ(succ(0)))))))(succ(succ(succ(succ(succ(succ(succ(0))))))))(cons(succ(succ(succ(succ(succ(0))))))(succ(succ(succ(succ(succ(succ(0)))))))(cons(succ(succ(succ(succ(0)))))(succ(succ(succ(succ(succ(0))))))(cons(succ(succ(succ(0))))(succ(succ(succ(succ(0)))))(cons(succ(succ(0)))(succ(succ(succ(0))))(cons(succ(0))(succ(succ(0)))(cons(0)(succ(0))(nil)))))))))
</code></pre>
<p>We now illustrate a simple instance of using <em>propositions as proofs</em>.
The type family <code>isEven : Nat -&gt;: Type</code> gives a type representing whether a natural number is even.
This is an inductive type, but here we simply specify the type by  its introduction rules (constructors).
Such terms introduced by specifying types are logically <em>axioms</em>.</p>
<pre><code class="language-scala">val isEven = &quot;isEven&quot; :: Nat -&gt;: Type
// isEven: Func[Term, Typ[Term]] = isEven
val zeroEven = &quot;0even&quot; :: isEven(zero)
// zeroEven: Term = 0even
val plusTwoEven = &quot;_+2even&quot; :: (n ~&gt;: (isEven(n) -&gt;: isEven(succ(succ(n)))))
// plusTwoEven: FuncLike[Term, Func[Term, Term]] = _+2even
</code></pre>
<p>One can directly see that two and four are even.</p>
<pre><code class="language-scala">val TwoEven = plusTwoEven(zero)(zeroEven)  !: isEven(two)
// TwoEven: Term = ((_+2even) (0)) (0even)
val FourEven = plusTwoEven(two)(TwoEven) !: isEven(four)
// FourEven: Term = ((_+2even) ((succ) ((succ) (0)))) (((_+2even) (0)) (0even))
</code></pre>
<p>Here is a simple proof by induction. We prove the statement that the <em>double</em> of every natural number is even.
The <code>induc</code> method gives a dependent function, which takes the base case and the induction step as arguments.
The <em>base case</em> is inhabited by the constructor of type <code>isEven(zero)</code>.
The <em>induction step</em> for <code>n</code> is a term of type <code>isEven(double(succ(n)))</code> as a function of <code>n</code> and
the <em>induction hypothesis</em>. Note that the induction hypothesis is a term of type <code>isEven(double(n))</code>.</p>
<pre><code class="language-scala">val thmDoubleEven = n ~&gt;: isEven(double(n))
// thmDoubleEven: GenFuncTyp[Term, Term] = (`n : Nat ) ~&gt; ((isEven) ((rec(Nat)(Nat)(0)((m :  Nat) ↦ ((`n :  Nat) ↦ ((succ) ((succ) (`n)))))) (`n)))
val hyp = &quot;isEven(double(n))&quot; :: isEven(double(n))
// hyp: Term = isEven(double(n))
val inducDoubleEven = NatInd.induc(n :-&gt; isEven(double(n)))
// inducDoubleEven: Func[Term, Func[FuncLike[Term, Func[Term, Term]], FuncLike[Term, Term]]] = (`InducDataSym(0) :  (isEven) (0)) ↦ ((`InducDataSym(succ) :  (`$fwbks : Nat ) ~&gt; (((isEven) ((rec(Nat)(Nat)(0)((m :  Nat) ↦ ((`n :  Nat) ↦ ((succ) ((succ) (`n)))))) (`$fwbks))) → ((isEven) ((succ) ((succ) ((rec(Nat)(Nat)(0)((m :  Nat) ↦ ((`n :  Nat) ↦ ((succ) ((succ) (`n)))))) (`$fwbks))))))) ↦ (ind(Nat)((`n :  Nat) ↦ ((isEven) ((rec(Nat)(Nat)(0)((m :  Nat) ↦ ((`n :  Nat) ↦ ((succ) ((succ) (`n)))))) (`n))))(`InducDataSym(0))(`InducDataSym(succ))))
</code></pre>
<pre><code class="language-scala">val pfDoubleEven =
  inducDoubleEven(
    zeroEven){
      n :~&gt; (
        hyp :-&gt; (
          plusTwoEven(double(n))(hyp)
          )
          )
    }  !: thmDoubleEven
// pfDoubleEven: FuncLike[Term, Term] = ind(Nat)((`n :  Nat) ↦ ((isEven) ((rec(Nat)(Nat)(0)((m :  Nat) ↦ ((`n :  Nat) ↦ ((succ) ((succ) (`n)))))) (`n))))(0even)((`n :  Nat) ↦ ((``isEven(double(n)) :  (isEven) ((rec(Nat)(Nat)(0)((m :  Nat) ↦ ((`n :  Nat) ↦ ((succ) ((succ) (`n)))))) (`n))) ↦ (((_+2even) ((rec(Nat)(Nat)(0)((m :  Nat) ↦ ((`n :  Nat) ↦ ((succ) ((succ) (`n)))))) (`n))) (``isEven(double(n))))))
</code></pre>
<p>We next prove a more interesting statement, namely that for any natural number <code>n</code>, one of <code>n</code> and <code>n+1</code> is even.</p>
<pre><code class="language-scala">val succEven = n :-&gt; (isEven(n) || isEven(succ(n)))
// succEven: Func[Term, PlusTyp[Term, Term]] = (`n :  Nat) ↦ (PlusTyp((isEven) (`n),(isEven) ((succ) (`n))))
</code></pre>
<pre><code class="language-scala">val base = succEven(zero).incl1(zeroEven) !: succEven(zero)
// base: Term = FirstIncl(PlusTyp((isEven) (0),(isEven) ((succ) (0))),0even)
</code></pre>
<pre><code class="language-scala">val thmSuccEven = n ~&gt;: (succEven(n))
// thmSuccEven: GenFuncTyp[Term, Term] = (`n : Nat ) ~&gt; (PlusTyp((isEven) (`n),(isEven) ((succ) (`n))))
</code></pre>
<pre><code class="language-scala">val hyp1 = &quot;n-is-Even&quot; :: isEven(n)
// hyp1: Term = n-is-Even
val hyp2 = &quot;(n+1)-is-Even&quot; :: isEven(succ(n))
// hyp2: Term = (n+1)-is-Even
</code></pre>
<pre><code class="language-scala">val step = (succEven(n).rec(succEven(succ(n)))){hyp1 :-&gt; (succEven(succ(n)).incl2(plusTwoEven(n)(hyp1)))}{hyp2 :-&gt; (succEven(succ(n)).incl1((hyp2)))}
// step: Func[Term, Term] = rec(PlusTyp((isEven) (n),(isEven) ((succ) (n))))(PlusTyp((isEven) ((succ) (n)),(isEven) ((succ) ((succ) (n)))))((`n-is-Even :  (isEven) (n)) ↦ (ScndIncl(PlusTyp((isEven) ((succ) (n)),(isEven) ((succ) ((succ) (n)))),((_+2even) (n)) (`n-is-Even))))((`(n+1)-is-Even :  (isEven) ((succ) (n))) ↦ (FirstIncl(PlusTyp((isEven) ((succ) (n)),(isEven) ((succ) ((succ) (n)))),`(n+1)-is-Even)))
</code></pre>
<pre><code class="language-scala">val inducSuccEven = NatInd.induc(succEven)
// inducSuccEven: Func[Term, Func[FuncLike[Term, Func[Term, Term]], FuncLike[Term, Term]]] = (`InducDataSym(0) :  PlusTyp((isEven) (0),(isEven) ((succ) (0)))) ↦ ((`InducDataSym(succ) :  (`$gapup : Nat ) ~&gt; ((PlusTyp((isEven) (`$gapup),(isEven) ((succ) (`$gapup)))) → (PlusTyp((isEven) ((succ) (`$gapup)),(isEven) ((succ) ((succ) (`$gapup))))))) ↦ (ind(Nat)((`n :  Nat) ↦ (PlusTyp((isEven) (`n),(isEven) ((succ) (`n)))))(`InducDataSym(0))(`InducDataSym(succ))))
</code></pre>
<pre><code class="language-scala">val pf = inducSuccEven(base)(n :~&gt; step) !: thmSuccEven
// pf: FuncLike[Term, Term] = ind(Nat)((`n :  Nat) ↦ (PlusTyp((isEven) (`n),(isEven) ((succ) (`n)))))(FirstIncl(PlusTyp((isEven) (0),(isEven) ((succ) (0))),0even))((`n :  Nat) ↦ (rec(PlusTyp((isEven) (`n),(isEven) ((succ) (`n))))(PlusTyp((isEven) ((succ) (`n)),(isEven) ((succ) ((succ) (`n)))))((``n-is-Even :  (isEven) (`n)) ↦ (ScndIncl(PlusTyp((isEven) ((succ) (`n)),(isEven) ((succ) ((succ) (`n)))),((_+2even) (`n)) (``n-is-Even))))((``(n+1)-is-Even :  (isEven) ((succ) (`n))) ↦ (FirstIncl(PlusTyp((isEven) ((succ) (`n)),(isEven) ((succ) ((succ) (`n)))),``(n+1)-is-Even)))))
</code></pre>
<p>We now prove a result that has been a goal, namely that for a function on Natural numbers if <code>f(n)=f(n+1)</code> for all n,
<code>f</code> is constant.</p>
<pre><code class="language-scala">val fn = &quot;f&quot; :: Nat -&gt;: A
// fn: Func[Term, Term] = f
val ass = &quot;assumption&quot; :: n ~&gt;: (fn(n) =:= fn(succ(n)))
// ass: FuncLike[Term, Equality[Term]] = assumption
</code></pre>
<pre><code class="language-scala">val claim = n :-&gt; (fn(zero) =:= fn(n))
// claim: Func[Term, IdentityTyp[Term]] = (`n :  Nat) ↦ ((f) (0) = (f) (`n))
</code></pre>
<pre><code class="language-scala">val sbase = fn(zero).refl
// sbase: Refl[Term] = Refl(A,(f) (0))
</code></pre>
<pre><code class="language-scala">val shyp = &quot;hypothesis&quot; :: (fn(zero) =:= fn(n))
// shyp: Equality[Term] = hypothesis : ((f) (0) = (f) (n))
val sstep = shyp :-&gt; {IdentityTyp.trans(A)(fn(zero))(fn(n))(fn(succ(n)))(shyp)(ass(n)) }
// sstep: Func[Equality[Term], Equality[Term]] = (`hypothesis : ((f) (0) = (f) (n)) :  (f) (0) = (f) (n)) ↦ (((ind{(`$gcrra :  A) ↦ ((`$gcrrb :  A) ↦ (`$gcrra = `$gcrrb))((f) (0))((f) (n))}{(`$gbuyc :  A) ↦ ((`$gbuyd :  A) ↦ ((``$gbuyf : (`$gbuyc = `$gbuyd) :  `$gbuyc = `$gbuyd) ↦ ((`$gbuyd = (f) ((succ) (n))) → (`$gbuyc = (f) ((succ) (n))))))}((`$gbuyc :  A) ↦ ((``````$gbwqb : (`$gbuyc = (f) ((succ) (n))) :  `$gbuyc = (f) ((succ) (n))) ↦ (``````$gbwqb : (`$gbuyc = (f) ((succ) (n))))))) (`hypothesis : ((f) (0) = (f) (n)))) ((assumption) (n) : ((f) (n) = (f) ((succ) (n)))) : ((f) (0) = (f) ((succ) (n))))
</code></pre>
<pre><code class="language-scala">val inducClaim = NatInd.induc(claim)
// inducClaim: Func[Equality[Term], Func[FuncLike[Term, Func[Equality[Term], Equality[Term]]], FuncLike[Term, Equality[Term]]]] = (`InducDataSym(0) : ((f) (0) = (f) (0)) :  (f) (0) = (f) (0)) ↦ ((`InducDataSym(succ) :  (`$gctfw : Nat ) ~&gt; (((f) (0) = (f) (`$gctfw)) → ((f) (0) = (f) ((succ) (`$gctfw))))) ↦ (ind(Nat)((`n :  Nat) ↦ ((f) (0) = (f) (`n)))(`InducDataSym(0) : ((f) (0) = (f) (0)))(`InducDataSym(succ))))
</code></pre>
<pre><code class="language-scala">val spf = inducClaim(sbase)(n :~&gt; sstep) !: (n ~&gt;: (fn(zero) =:= fn(n)))
// spf: FuncLike[Term, Equality[Term]] = ind(Nat)((`n :  Nat) ↦ ((f) (0) = (f) (`n)))(Refl(A,(f) (0)))((`n :  Nat) ↦ ((``hypothesis : ((f) (0) = (f) (`n)) :  (f) (0) = (f) (`n)) ↦ (((ind{(`$gdcut :  A) ↦ ((`$gdcuu :  A) ↦ (`$gdcut = `$gdcuu))((f) (0))((f) (`n))}{(`$gbuyc :  A) ↦ ((`$gbuyd :  A) ↦ ((``$gbuyf : (`$gbuyc = `$gbuyd) :  `$gbuyc = `$gbuyd) ↦ ((`$gbuyd = (f) ((succ) (`n))) → (`$gbuyc = (f) ((succ) (`n))))))}((`$gbuyc :  A) ↦ ((```````$gbwqb : (`$gbuyc = (f) ((succ) (`n))) :  `$gbuyc = (f) ((succ) (`n))) ↦ (```````$gbwqb : (`$gbuyc = (f) ((succ) (`n))))))) (``hypothesis : ((f) (0) = (f) (`n)))) ((assumption) (`n) : ((f) (`n) = (f) ((succ) (`n)))) : ((f) (0) = (f) ((succ) (`n))))))
</code></pre>
<h2>Indexed Inductive types</h2>
<p>A generalization of inductive types are <em>inductive type families</em>, i.e., inductive types depending on an index.
Unlike parametrized inductive types (such as lists), the constructors of an inductive type family involve in general several different indices.
Further, the recursion and induction function only allow construction of (dependent) functions on the whole family.</p>
<p>A typical example is vectors, defined as a family indexed by their length.</p>
<pre><code class="language-scala">val Vec = &quot;Vec&quot; :: Nat -&gt;: Type
// Vec: Func[Term, Typ[Term]] = Vec

val VecInd =
  (&quot;nil&quot; ::: (Vec -&gt; Vec(zero))) |: {
    &quot;cons&quot; ::: n ~&gt;&gt;: (A -&gt;&gt;: (Vec :&gt; Vec(n)) --&gt;&gt;: (Vec -&gt; Vec(succ(n))))
  } =:: Vec
// VecInd: IndexedConstructorSeqDom[HNil :: IndexedConstructorShape.IndexedCnstDepFuncConsShape.type :: IndexedConstructorShape.IndexedCnstFuncConsShape.type :: IndexedConstructorShape.IndexedIndexedFuncConsShape.type :: HNil :: HNil, Term, Func[Term, Typ[Term]], Term :: HNil, Term :: FuncLike[Term, Func[Term, Func[Term, Term]]] :: HNil] = Cons(nil,IndexedIdShape(FuncTypFamily(Nat,IdTypFamily()),0 :: HNil),Cons(cons,IndexedCnstDepFuncConsShape(Nat,n ↦ IndexedCnstFuncConsShape(A,IndexedIndexedFuncConsShape(IdIterShape(FuncTypFamily(Nat,IdTypFamily()),n :: HNil),IndexedIdShape(FuncTypFamily(Nat,IdTypFamily()),(succ) (n) :: HNil),n :: HNil))),Empty(Vec,FuncTypFamily(Nat,IdTypFamily()))))
</code></pre>
<pre><code class="language-scala">val vnil :: vcons :: HNil = VecInd.intros
// vnil: Term = nil
// vcons: FuncLike[Term, Func[Term, Func[Term, Term]]] = cons

vcons.typ.fansi
// res45: String = [36m∏[93m([39m$gdvgk[33m : [39mNat[93m)[91m{ [39m(A [91m→[39m (Vec($gdvgk) [91m→[39m Vec(succ($gdvgk))))[91m }[39m
</code></pre>
<p>We can define function recursively on vectors of all indices. For instance, we can define the size.</p>
<pre><code class="language-scala">val vn = &quot;v_n&quot; :: Vec(n)
// vn: Term = v_n
val recVN = VecInd.rec(Nat)
// recVN: Func[Term, Func[FuncLike[Term, Func[Term, Func[Term, Func[Term, Term]]]], FuncLike[Term, Func[Term, Term]]]] = (`RecDataSym(nil) :  Nat) ↦ ((`RecDataSym(cons) :  (`$gdvik : Nat ) ~&gt; ((A) → (((Vec) (`$gdvik)) → ((Nat) → (Nat))))) ↦ ((`$gdvhw :  Nat) ↦ (rec{Vec(`$gdvhw)}{Nat}(`RecDataSym(nil))(`RecDataSym(cons)))))
val vsize = recVN(zero)(n :~&gt;(a :-&gt; (vn :-&gt;(m :-&gt;(succ(m))))))
// vsize: FuncLike[Term, Func[Term, Term]] = (`$gdvhw :  Nat) ↦ (rec{Vec(`$gdvhw)}{Nat}(0)((`n :  Nat) ↦ ((a :  A) ↦ ((`v_n :  (Vec) (`n)) ↦ ((`m :  Nat) ↦ ((succ) (`m)))))))
vsize(zero)(vnil)
// res46: Term = 0
</code></pre>
<pre><code class="language-scala">val v1 = vcons(zero)(a)(vnil)
// v1: Term = (((cons) (0)) (a)) (nil)
vsize(one)(v1)
// res47: Term = (succ) (0)
assert(vsize(one)(v1) == one)
</code></pre>
<p>For a more interesting example, we consider vectors with entries natural numbers, and define the sum of entries.</p>
<pre><code class="language-scala">val VecN = &quot;Vec(Nat)&quot; :: Nat -&gt;: Type
// VecN: Func[Term, Typ[Term]] = Vec(Nat)
val vnn  = &quot;v_n&quot; :: VecN(n)
// vnn: Term = v_n
val VecNInd =
  (&quot;nil&quot; ::: (VecN -&gt; VecN(zero))) |: {
    &quot;cons&quot; ::: n ~&gt;&gt;:
      (Nat -&gt;&gt;: (VecN :&gt; VecN(n)) --&gt;&gt;: (VecN -&gt; VecN(succ(n))))
  } =:: VecN
// VecNInd: IndexedConstructorSeqDom[HNil :: IndexedConstructorShape.IndexedCnstDepFuncConsShape.type :: IndexedConstructorShape.IndexedCnstFuncConsShape.type :: IndexedConstructorShape.IndexedIndexedFuncConsShape.type :: HNil :: HNil, Term, Func[Term, Typ[Term]], Term :: HNil, Term :: FuncLike[Term, Func[Term, Func[Term, Term]]] :: HNil] = Cons(nil,IndexedIdShape(FuncTypFamily(Nat,IdTypFamily()),0 :: HNil),Cons(cons,IndexedCnstDepFuncConsShape(Nat,n ↦ IndexedCnstFuncConsShape(Nat,IndexedIndexedFuncConsShape(IdIterShape(FuncTypFamily(Nat,IdTypFamily()),n :: HNil),IndexedIdShape(FuncTypFamily(Nat,IdTypFamily()),(succ) (n) :: HNil),n :: HNil))),Empty(Vec(Nat),FuncTypFamily(Nat,IdTypFamily()))))
</code></pre>
<pre><code class="language-scala">val recVNN                  = VecNInd.rec(Nat)
// recVNN: Func[Term, Func[FuncLike[Term, Func[Term, Func[Term, Func[Term, Term]]]], FuncLike[Term, Func[Term, Term]]]] = (`RecDataSym(nil) :  Nat) ↦ ((`RecDataSym(cons) :  (`$geazt : Nat ) ~&gt; ((Nat) → (((Vec(Nat)) (`$geazt)) → ((Nat) → (Nat))))) ↦ ((`$geazf :  Nat) ↦ (rec{Vec(Nat)(`$geazf)}{Nat}(`RecDataSym(nil))(`RecDataSym(cons)))))
val vnilN :: vconsN :: HNil = VecNInd.intros
// vnilN: Term = nil
// vconsN: FuncLike[Term, Func[Term, Func[Term, Term]]] = cons
</code></pre>
<pre><code class="language-scala">val k = &quot;k&quot; :: Nat
// k: Term = k
val vsum = recVNN(zero)(n :~&gt;(k :-&gt; (vnn :-&gt;(m :-&gt; (add(m)(k)) ))))
// vsum: FuncLike[Term, Func[Term, Term]] = (`$geazf :  Nat) ↦ (rec{Vec(Nat)(`$geazf)}{Nat}(0)((`n :  Nat) ↦ ((`k :  Nat) ↦ ((`v_n :  (Vec(Nat)) (`n)) ↦ ((`m :  Nat) ↦ (((rec(Nat)((Nat) → (Nat))((`m :  Nat) ↦ (`m))((n :  Nat) ↦ ((`add(n) :  (Nat) → (Nat)) ↦ ((`m :  Nat) ↦ ((succ) ((`add(n)) (`m))))))) (`m)) (`k)))))))
</code></pre>
<pre><code class="language-scala">vsum(zero)(vnilN)
// res49: Term = 0
val v2 = vconsN(zero)(two)(vnilN)
// v2: Term = (((cons) (0)) ((succ) ((succ) (0)))) (nil)
vsum(one)(v2)
// res50: Term = (succ) ((succ) (0))
</code></pre>
<pre><code class="language-scala">assert(vsum(one)(v2) == two)
</code></pre>
<pre><code class="language-scala">val v3 = vconsN(one)(one)(v2)
// v3: Term = (((cons) ((succ) (0))) ((succ) (0))) ((((cons) (0)) ((succ) ((succ) (0)))) (nil))
v3.fansi
// res52: String = cons(succ(0))(succ(0))(cons(0)(succ(succ(0)))(nil))
vsum(two)(v3)
// res53: Term = (succ) ((succ) ((succ) (0)))
assert(vsum(two)(v3) == three)
</code></pre>
<h4>git commit hash when running tutorial: 36c30fa8ccefe0796d9d7c1881a0061fa435e6e0</h4>


</div>
</div>

<div class="container-fluid">
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <div class="footer navbar-fixed-bottom bg-primary">
    <h4>
    &nbsp;Developed by:
    &nbsp;<a href="http://math.iisc.ac.in/~gadgil" target="_blank">&nbsp; Siddhartha Gadgil</a>

  </h4>

  </div>
</div>
<script type="text/javascript" src="../js/jquery-2.1.4.min.js"></script>
<script type="text/javascript" src="../js/bootstrap.min.js"></script>
<script type="text/javascript" src="../js/provingground.js"></script>
<script>
  provingground.main()
</script>
   
</body>
</html>
   
<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../lib/jquery.min.js"></script><script type="text/javascript" src="../../lib/index.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript" src="../../lib/scheduler.js"></script><script type="text/javascript" src="../../lib/template.js"></script><script type="text/javascript" src="https://d3js.org/d3.v4.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.provingground" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="provingground"></a><a id="provingground:provingground"></a> <span class="permalink"><a href="../../provingground/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title="This is work towards automated theorem proving based on learning, using homotopy type theory (HoTT) as foundations and natural language processing."><span class="name">provingground</span></a></span><p class="shortcomment cmt">This is work towards automated theorem proving based on learning, using
homotopy type theory (HoTT) as foundations and natural language processing.</p><div class="fullcomment"><div class="comment cmt"><p>This is work towards automated theorem proving based on learning, using
homotopy type theory (HoTT) as foundations and natural language processing.</p><p>The implementation of homotopy type theory is split into:</p><ul><li>the object <a href="../HoTT$.html" name="provingground.HoTT" id="provingground.HoTT" class="extype">HoTT</a> with terms, types, functions and dependent functions, pairs etc</li><li>the package <a href="../induction/index.html" name="provingground.induction" id="provingground.induction" class="extype">induction</a> with general inductive types and recursion/induction on these.</li></ul><p>The <a href="index.html" name="provingground.learning" id="provingground.learning" class="extype">learning</a> package has the code for learning.</p><p>Scala code, including the <code><code>spire</code></code> library, is integrated with homotopy type theory
in the <a href="../scalahott/index.html" name="provingground.scalahott" id="provingground.scalahott" class="extype">scalahott</a> package</p><p>We have implemented a functor based approach to translation in the <a href="../translation/index.html" name="provingground.translation" id="provingground.translation" class="extype">translation</a>
package, used for <code><code>nlp</code></code> as well as <code><code>serialization</code></code> and <code><code>parsing</code></code>.</p><p>The <a href="../library/index.html" name="provingground.library" id="provingground.library" class="extype">library</a> package is contains basic structures implemented in HoTT.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="provingground.learning" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="learning"></a><a id="learning:learning"></a> <span class="permalink"><a href="../../provingground/learning/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title=""><span class="name">learning</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="provingground" id="provingground" class="extype">provingground</a></dd></dl></div></li><li class="current-entities indented2"><a href="AdjDiffbleFunction$.html" title="" class="object"></a> <a href="AdjDiffbleFunction.html" title="" class="trait"></a><a href="AdjDiffbleFunction.html" title="">AdjDiffbleFunction</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="AnswerFromPost.html" title="Looking up an answer to a query for U from posts of type P meant for querying for the latest post etc." class="class"></a><a href="AnswerFromPost.html" title="Looking up an answer to a query for U from posts of type P meant for querying for the latest post etc.">AnswerFromPost</a></li><li class="current-entities indented2"><a href="ApplnInverse$.html" title="" class="object"></a> <a href="ApplnInverse.html" title="inverses under application with an without unification" class="trait"></a><a href="ApplnInverse.html" title="inverses under application with an without unification">ApplnInverse</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="BackPaths.html" title="" class="class"></a><a href="BackPaths.html" title="">BackPaths</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="BasicDeducer.html" title="" class="class"></a><a href="BasicDeducer.html" title="">BasicDeducer</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="BiPostable.html" title="" class="trait"></a><a href="BiPostable.html" title="">BiPostable</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="BufferedRun.html" title="" class="class"></a><a href="BufferedRun.html" title="">BufferedRun</a></li><li class="current-entities indented2"><a href="BuffersJson$.html" title="" class="object"></a> <a href="BuffersJson.html" title="" class="trait"></a><a href="BuffersJson.html" title="">BuffersJson</a></li><li class="current-entities indented2"><a href="BuildPostable$.html" title="" class="object"></a> <a href="BuildPostable.html" title="typeclass for building HLists of postables (and other things) based on HLists of buffers, but formally just returns object of type P" class="trait"></a><a href="BuildPostable.html" title="typeclass for building HLists of postables (and other things) based on HLists of buffers, but formally just returns object of type P">BuildPostable</a></li><li class="current-entities indented2"><a href="BuildQuery$.html" title="" class="object"></a> <a href="BuildQuery.html" title="" class="trait"></a><a href="BuildQuery.html" title="">BuildQuery</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Collated.html" title="" class="class"></a><a href="Collated.html" title="">Collated</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Collections$.html" title="" class="object"></a><a href="Collections$.html" title="">Collections</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="CompositeProver.html" title="" class="class"></a><a href="CompositeProver.html" title="">CompositeProver</a></li><li class="current-entities indented2"><a href="Conditioning$.html" title="" class="object"></a> <a href="Conditioning.html" title="typeclass for being able to condition" class="trait"></a><a href="Conditioning.html" title="typeclass for being able to condition">Conditioning</a></li><li class="current-entities indented2"><a href="ContextExport$.html" title="" class="object"></a> <a href="ContextExport.html" title="changes in the distribution-like object other than those induced by object level map while exporting from an island typically a change in context for variables representing terms in a context" class="trait"></a><a href="ContextExport.html" title="changes in the distribution-like object other than those induced by object level map while exporting from an island typically a change in context for variables representing terms in a context">ContextExport</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="CounterGlobalID.html" title="allows posting globally and keeps count without stroing anything" class="class"></a><a href="CounterGlobalID.html" title="allows posting globally and keeps count without stroing anything">CounterGlobalID</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="DE$.html" title="" class="object"></a><a href="DE$.html" title="">DE</a></li><li class="current-entities indented2"><a href="DataGetter$.html" title="" class="object"></a> <a href="DataGetter.html" title="" class="trait"></a><a href="DataGetter.html" title="">DataGetter</a></li><li class="current-entities indented2"><a href="Deducer$.html" title="Generating terms from given ones using the main HoTT operations, and the adjoint of this generation." class="object"></a> <a href="Deducer.html" title="" class="class"></a><a href="Deducer.html" title="">Deducer</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="DeducerBuffer.html" title="" class="class"></a><a href="DeducerBuffer.html" title="">DeducerBuffer</a></li><li class="current-entities indented2"><a href="DeducerSource$.html" title="" class="object"></a> <a href="DeducerSource.html" title="" class="class"></a><a href="DeducerSource.html" title="">DeducerSource</a></li><li class="current-entities indented2"><a href="DerivedEquations$.html" title="" class="object"></a> <a href="DerivedEquations.html" title="" class="class"></a><a href="DerivedEquations.html" title="">DerivedEquations</a></li><li class="current-entities indented2"><a href="DiffbleFunction$.html" title="" class="object"></a> <a href="DiffbleFunction.html" title="" class="trait"></a><a href="DiffbleFunction.html" title="">DiffbleFunction</a></li><li class="current-entities indented2"><a href="DistributionState$.html" title="" class="object"></a> <a href="DistributionState.html" title="typeclass for providing distributions from a state and modifying a state from distributions" class="trait"></a><a href="DistributionState.html" title="typeclass for providing distributions from a state and modifying a state from distributions">DistributionState</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="DistributionStateEvolver.html" title="" class="class"></a><a href="DistributionStateEvolver.html" title="">DistributionStateEvolver</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="EgUnif.html" title="" class="class"></a><a href="EgUnif.html" title="">EgUnif</a></li><li class="current-entities indented2"><a href="Empty$.html" title="" class="object"></a> <a href="Empty.html" title="" class="trait"></a><a href="Empty.html" title="">Empty</a></li><li class="current-entities indented2"><a href="EntropyAtomWeight$.html" title="" class="object"></a> <a href="EntropyAtomWeight.html" title="Spire gradient learning for tradeoff between generation entropy and theorem-proof relative entropy" class="class"></a><a href="EntropyAtomWeight.html" title="Spire gradient learning for tradeoff between generation entropy and theorem-proof relative entropy">EntropyAtomWeight</a></li><li class="current-entities indented2"><a href="EqDistMemo$.html" title="" class="object"></a> <a href="EqDistMemo.html" title="" class="class"></a><a href="EqDistMemo.html" title="">EqDistMemo</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Equation.html" title="" class="class"></a><a href="Equation.html" title="">Equation</a></li><li class="current-entities indented2"><a href="EquationExporter$.html" title="" class="object"></a> <a href="EquationExporter.html" title="" class="class"></a><a href="EquationExporter.html" title="">EquationExporter</a></li><li class="current-entities indented2"><a href="EquationNode$.html" title="" class="object"></a> <a href="EquationNode.html" title="" class="class"></a><a href="EquationNode.html" title="">EquationNode</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="EquationOps$.html" title="" class="object"></a><a href="EquationOps$.html" title="">EquationOps</a></li><li class="current-entities indented2"><a href="ErasablePostBuffer$.html" title="" class="object"></a> <a href="ErasablePostBuffer.html" title="" class="class"></a><a href="ErasablePostBuffer.html" title="">ErasablePostBuffer</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="ErasableWebBuffer.html" title="" class="class"></a><a href="ErasableWebBuffer.html" title="">ErasableWebBuffer</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="EvolvedEquations.html" title="" class="trait"></a><a href="EvolvedEquations.html" title="">EvolvedEquations</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="EvolvedState.html" title="" class="class"></a><a href="EvolvedState.html" title="">EvolvedState</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="EvolvedStateLike.html" title="" class="trait"></a><a href="EvolvedStateLike.html" title="">EvolvedStateLike</a></li><li class="current-entities indented2"><a href="EvolverEquations$.html" title="" class="object"></a> <a href="EvolverEquations.html" title="variables for probabilities and equations for consistency" class="class"></a><a href="EvolverEquations.html" title="variables for probabilities and equations for consistency">EvolverEquations</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="EvolverSupport.html" title="Support of the final distribution of an evolver, i.e., a generative model for terms" class="trait"></a><a href="EvolverSupport.html" title="Support of the final distribution of an evolver, i.e., a generative model for terms">EvolverSupport</a></li><li class="current-entities indented2"><a href="EvolverVariables$.html" title="" class="object"></a> <a href="EvolverVariables.html" title="Variables in an evolver; not all need to be used in a give case" class="trait"></a><a href="EvolverVariables.html" title="Variables in an evolver; not all need to be used in a give case">EvolverVariables</a></li><li class="current-entities indented2"><a href="Expression$.html" title="" class="object"></a> <a href="Expression.html" title="" class="trait"></a><a href="Expression.html" title="">Expression</a></li><li class="current-entities indented2"><a href="ExpressionEquationIndexifier$.html" title="" class="object"></a> <a href="ExpressionEquationIndexifier.html" title="Maps equations based on expressions in terms, randomvariables etc." class="class"></a><a href="ExpressionEquationIndexifier.html" title="Maps equations based on expressions in terms, randomvariables etc.">ExpressionEquationIndexifier</a></li><li class="current-entities indented2"><a href="ExpressionEquationSolver$.html" title="Working with expressions built from initial and final values of random variables, including in islands, given equations satisfied by these" class="object"></a> <a href="ExpressionEquationSolver.html" title="Solve equations based on expressions (approximately), and compute various related quantities The actual solving is done after translating the equations to ones based on indices, for the sake of efficiency." class="trait"></a><a href="ExpressionEquationSolver.html" title="Solve equations based on expressions (approximately), and compute various related quantities The actual solving is done after translating the equations to ones based on indices, for the sake of efficiency.">ExpressionEquationSolver</a></li><li class="current-entities indented2"><a href="ExstParMap$.html" title="" class="object"></a> <a href="ExstParMap.html" title="" class="trait"></a><a href="ExstParMap.html" title="">ExstParMap</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="FallBackLookups.html" title="" class="trait"></a><a href="FallBackLookups.html" title="">FallBackLookups</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="FatExprEquations.html" title="" class="class"></a><a href="FatExprEquations.html" title="">FatExprEquations</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="FieldGramSchmidt$.html" title="" class="object"></a><a href="FieldGramSchmidt$.html" title="">FieldGramSchmidt</a></li><li class="current-entities indented2"><a href="FineDeducer$.html" title="A refined deducer, i.e., evolution of terms and derivatives of evolution." class="object"></a> <a href="FineDeducer.html" title="A refined deducer, i.e., evolution of terms and derivatives of evolution." class="class"></a><a href="FineDeducer.html" title="A refined deducer, i.e., evolution of terms and derivatives of evolution.">FineDeducer</a></li><li class="current-entities indented2"><a href="FineDeducerStep$.html" title="" class="object"></a> <a href="FineDeducerStep.html" title="Monad based step for deducer, to be used, for example, with Monix Task" class="class"></a><a href="FineDeducerStep.html" title="Monad based step for deducer, to be used, for example, with Monix Task">FineDeducerStep</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="FineEvolver.html" title="A refined evolver, i.e., evolution of terms and subclasses such as types." class="class"></a><a href="FineEvolver.html" title="A refined evolver, i.e., evolution of terms and subclasses such as types.">FineEvolver</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="FineProverTasks$.html" title="A collection of functions to build provers; some are abstract methods for exploring, searching etc., while others generate terms and types, sometimes as derivatives." class="object"></a><a href="FineProverTasks$.html" title="A collection of functions to build provers; some are abstract methods for exploring, searching etc., while others generate terms and types, sometimes as derivatives.">FineProverTasks</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="FiniteDistributionLearner$.html" title="A combinator for learning systems with state finite distributions on vertices." class="object"></a><a href="FiniteDistributionLearner$.html" title="A combinator for learning systems with state finite distributions on vertices.">FiniteDistributionLearner</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="ForceDirected.html" title="" class="class"></a><a href="ForceDirected.html" title="">ForceDirected</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="ForceDirectedVectors.html" title="" class="class"></a><a href="ForceDirectedVectors.html" title="">ForceDirectedVectors</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="GatherMapPost.html" title="" class="class"></a><a href="GatherMapPost.html" title="">GatherMapPost</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="GatherPost.html" title="" class="class"></a><a href="GatherPost.html" title="">GatherPost</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="GenMonixFiniteDistribution.html" title="" class="class"></a><a href="GenMonixFiniteDistribution.html" title="">GenMonixFiniteDistribution</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="GenMonixFiniteDistributionEq.html" title="" class="class"></a><a href="GenMonixFiniteDistributionEq.html" title="">GenMonixFiniteDistributionEq</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="GenTruncatedFiniteDistribution.html" title="" class="class"></a><a href="GenTruncatedFiniteDistribution.html" title="">GenTruncatedFiniteDistribution</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="GeneratorData.html" title="" class="class"></a><a href="GeneratorData.html" title="">GeneratorData</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="GeneratorEquations.html" title="" class="class"></a><a href="GeneratorEquations.html" title="">GeneratorEquations</a></li><li class="current-entities indented2"><a href="GeneratorNode$.html" title="" class="object"></a> <a href="GeneratorNode.html" title="A formal node for describing recursive generation." class="trait"></a><a href="GeneratorNode.html" title="A formal node for describing recursive generation.">GeneratorNode</a></li><li class="current-entities indented2"><a href="GeneratorNodeFamily$.html" title="" class="object"></a> <a href="GeneratorNodeFamily.html" title="Family of (recursive) generation functions, either a function giving a family or a single {{GeneratorNode}}, which is the interesting case." class="trait"></a><a href="GeneratorNodeFamily.html" title="Family of (recursive) generation functions, either a function giving a family or a single {{GeneratorNode}}, which is the interesting case.">GeneratorNodeFamily</a></li><li class="current-entities indented2"><a href="GeneratorTF$.html" title="" class="object"></a> <a href="GeneratorTF.html" title="" class="class"></a><a href="GeneratorTF.html" title="">GeneratorTF</a></li><li class="current-entities indented2"><a href="GeneratorVariables$.html" title="" class="object"></a> <a href="GeneratorVariables.html" title="resolving a general specification of a recursive generative model as finite distributions, depending on truncation; the coefficients of the various generator nodes should be Double" class="class"></a><a href="GeneratorVariables.html" title="resolving a general specification of a recursive generative model as finite distributions, depending on truncation; the coefficients of the various generator nodes should be Double">GeneratorVariables</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="GeometricDistribution$.html" title="An example, the geometric distribution in an abstract form" class="object"></a><a href="GeometricDistribution$.html" title="An example, the geometric distribution in an abstract form">GeometricDistribution</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="GlobalID.html" title="" class="trait"></a><a href="GlobalID.html" title="">GlobalID</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="GlobalPost.html" title="Allows posting any content, typically just returns an ID to be used by something else." class="trait"></a><a href="GlobalPost.html" title="Allows posting any content, typically just returns an ID to be used by something else.">GlobalPost</a></li><li class="current-entities indented2"><a href="GlobalProver$.html" title="" class="object"></a> <a href="GlobalProver.html" title="" class="trait"></a><a href="GlobalProver.html" title="">GlobalProver</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="GramSchmidt$.html" title="" class="object"></a><a href="GramSchmidt$.html" title="">GramSchmidt</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="GraphEmbedding$.html" title="" class="object"></a><a href="GraphEmbedding$.html" title="">GraphEmbedding</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="GraphEmbeddingLogisitic.html" title="" class="class"></a><a href="GraphEmbeddingLogisitic.html" title="">GraphEmbeddingLogisitic</a></li><li class="current-entities indented2"><a href="HistoryGetter$.html" title="" class="object"></a> <a href="HistoryGetter.html" title="" class="trait"></a><a href="HistoryGetter.html" title="">HistoryGetter</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="HoTTBot$.html" title="" class="object"></a><a href="HoTTBot$.html" title="">HoTTBot</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="HoTTMessages$.html" title="Messages to be posted for autonomous/interactive running." class="object"></a><a href="HoTTMessages$.html" title="Messages to be posted for autonomous/interactive running.">HoTTMessages</a></li><li class="current-entities indented2"><a href="HoTTPost$.html" title="" class="object"></a> <a href="HoTTPost.html" title="" class="class"></a><a href="HoTTPost.html" title="">HoTTPost</a></li><li class="current-entities indented2"><a href="HoTTPostWeb$.html" title="" class="object"></a> <a href="HoTTPostWeb.html" title="Better building of post webs, without depending on separate lists for implicits and history (history to be done)." class="class"></a><a href="HoTTPostWeb.html" title="Better building of post webs, without depending on separate lists for implicits and history (history to be done).">HoTTPostWeb</a></li><li class="current-entities indented2"><a href="HoTTWebSession$.html" title="" class="object"></a> <a href="HoTTWebSession.html" title="" class="class"></a><a href="HoTTWebSession.html" title="">HoTTWebSession</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="HoTTgen$.html" title="" class="object"></a><a href="HoTTgen$.html" title="">HoTTgen</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Hub$.html" title="" class="object"></a><a href="Hub$.html" title="">Hub</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="IndexEquationMapSolver.html" title="Seek an approximately stable distribution for equations given in terms of indices, hence solving the equations (approximately)." class="class"></a><a href="IndexEquationMapSolver.html" title="Seek an approximately stable distribution for equations given in terms of indices, hence solving the equations (approximately).">IndexEquationMapSolver</a></li><li class="current-entities indented2"><a href="IndexEquationSolver$.html" title="" class="object"></a> <a href="IndexEquationSolver.html" title="Seek an approximately stable distribution for equations given in terms of indices, hence solving the equations (approximately)." class="class"></a><a href="IndexEquationSolver.html" title="Seek an approximately stable distribution for equations given in terms of indices, hence solving the equations (approximately).">IndexEquationSolver</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="IntElem.html" title="" class="class"></a><a href="IntElem.html" title="">IntElem</a></li><li class="current-entities indented2"><a href="IterantRunner$.html" title="" class="object"></a> <a href="IterantRunner.html" title="" class="trait"></a><a href="IterantRunner.html" title="">IterantRunner</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="IterateDyn$.html" title="" class="object"></a><a href="IterateDyn$.html" title="">IterateDyn</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="LatestAnswer.html" title="Queries answered by taking the latest out of possibly many choices of posts to be looked up and transformed." class="class"></a><a href="LatestAnswer.html" title="Queries answered by taking the latest out of possibly many choices of posts to be looked up and transformed.">LatestAnswer</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="LatestTagged.html" title="" class="class"></a><a href="LatestTagged.html" title="">LatestTagged</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="LemmaWeigths$.html" title="" class="object"></a><a href="LemmaWeigths$.html" title="">LemmaWeigths</a></li><li class="current-entities indented2"><a href="LocalProver$.html" title="" class="object"></a> <a href="LocalProver.html" title="Collect local/generative/tactical proving; this includes configuration and learning but excludes strategy and attention." class="class"></a><a href="LocalProver.html" title="Collect local/generative/tactical proving; this includes configuration and learning but excludes strategy and attention.">LocalProver</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="LocalProverStep.html" title="" class="trait"></a><a href="LocalProverStep.html" title="">LocalProverStep</a></li><li class="current-entities indented2"><a href="LocalQueryable$.html" title="" class="object"></a> <a href="LocalQueryable.html" title="Typeclass for being able to query W for a vector of elements of type Q at an index" class="trait"></a><a href="LocalQueryable.html" title="Typeclass for being able to query W for a vector of elements of type Q at an index">LocalQueryable</a></li><li class="current-entities indented2"><a href="LocalTangentProver$.html" title="" class="object"></a> <a href="LocalTangentProver.html" title="" class="class"></a><a href="LocalTangentProver.html" title="">LocalTangentProver</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="MapVS$.html" title="" class="object"></a><a href="MapVS$.html" title="">MapVS</a></li><li class="current-entities indented2"><a href="MemoState$.html" title="" class="object"></a> <a href="MemoState.html" title="" class="class"></a><a href="MemoState.html" title="">MemoState</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="MonixFieldGramSchmidt$.html" title="" class="object"></a><a href="MonixFieldGramSchmidt$.html" title="">MonixFieldGramSchmidt</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="MonixFiniteDistribution.html" title="resolving a general specification of a recursive generative model as finite distributions, depending on truncation; the coefficients of the various generator nodes should be Double" class="class"></a><a href="MonixFiniteDistribution.html" title="resolving a general specification of a recursive generative model as finite distributions, depending on truncation; the coefficients of the various generator nodes should be Double">MonixFiniteDistribution</a></li><li class="current-entities indented2"><a href="MonixFiniteDistributionEq$.html" title="" class="object"></a> <a href="MonixFiniteDistributionEq.html" title="resolving a general specification of a recursive generative model as finite distributions, depending on truncation; the coefficients of the various generator nodes should be Double" class="class"></a><a href="MonixFiniteDistributionEq.html" title="resolving a general specification of a recursive generative model as finite distributions, depending on truncation; the coefficients of the various generator nodes should be Double">MonixFiniteDistributionEq</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="MonixGramSchmidt$.html" title="" class="object"></a><a href="MonixGramSchmidt$.html" title="">MonixGramSchmidt</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="MonixProverTasks$.html" title="A drop-in replacement for FineProverTasks to test the abstract generators approach; since testing is the goal redundancies and some comments have been removed." class="object"></a><a href="MonixProverTasks$.html" title="A drop-in replacement for FineProverTasks to test the abstract generators approach; since testing is the goal redundancies and some comments have been removed.">MonixProverTasks</a></li><li class="current-entities indented2"><a href="MonixSamples$.html" title="" class="object"></a> <a href="MonixSamples.html" title="" class="trait"></a><a href="MonixSamples.html" title="">MonixSamples</a></li><li class="current-entities indented2"><a href="MonixTangentFiniteDistribution$.html" title="" class="object"></a> <a href="MonixTangentFiniteDistribution.html" title="resolving a general specification of a recursive generative model as finite distributions, depending on truncation; the coefficients of the various generator nodes should be Double" class="class"></a><a href="MonixTangentFiniteDistribution.html" title="resolving a general specification of a recursive generative model as finite distributions, depending on truncation; the coefficients of the various generator nodes should be Double">MonixTangentFiniteDistribution</a></li><li class="current-entities indented2"><a href="MonixTangentFiniteDistributionEq$.html" title="" class="object"></a> <a href="MonixTangentFiniteDistributionEq.html" title="resolving a general specification of a recursive generative model as finite distributions, depending on truncation; the coefficients of the various generator nodes should be Double" class="class"></a><a href="MonixTangentFiniteDistributionEq.html" title="resolving a general specification of a recursive generative model as finite distributions, depending on truncation; the coefficients of the various generator nodes should be Double">MonixTangentFiniteDistributionEq</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="NextSample.html" title="" class="class"></a><a href="NextSample.html" title="">NextSample</a></li><li class="current-entities indented2"><a href="NodeCoeffSeq$.html" title="" class="object"></a> <a href="NodeCoeffSeq.html" title="" class="trait"></a><a href="NodeCoeffSeq.html" title="">NodeCoeffSeq</a></li><li class="current-entities indented2"><a href="NodeCoeffs$.html" title="" class="object"></a> <a href="NodeCoeffs.html" title="" class="trait"></a><a href="NodeCoeffs.html" title="">NodeCoeffs</a></li><li class="current-entities indented2"><a href="ParDistEq$.html" title="" class="object"></a> <a href="ParDistEq.html" title="" class="class"></a><a href="ParDistEq.html" title="">ParDistEq</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="ParDistEqMemo.html" title="" class="class"></a><a href="ParDistEqMemo.html" title="">ParDistEqMemo</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="ParGramSchmidt$.html" title="" class="object"></a><a href="ParGramSchmidt$.html" title="">ParGramSchmidt</a></li><li class="current-entities indented2"><a href="ParMapState$.html" title="" class="object"></a> <a href="ParMapState.html" title="" class="class"></a><a href="ParMapState.html" title="">ParMapState</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="ParStrategicProvers$.html" title="" class="object"></a><a href="ParStrategicProvers$.html" title="">ParStrategicProvers</a></li><li class="current-entities indented2"><a href="ParTangentDistEq$.html" title="" class="object"></a> <a href="ParTangentDistEq.html" title="" class="class"></a><a href="ParTangentDistEq.html" title="">ParTangentDistEq</a></li><li class="current-entities indented2"><a href="ParTermState$.html" title="" class="object"></a> <a href="ParTermState.html" title="" class="class"></a><a href="ParTermState.html" title="">ParTermState</a></li><li class="current-entities indented2"><a href="PickledTermPopulation$.html" title="" class="object"></a> <a href="PickledTermPopulation.html" title="" class="class"></a><a href="PickledTermPopulation.html" title="">PickledTermPopulation</a></li><li class="current-entities indented2"><a href="PostBuffer$.html" title="" class="object"></a> <a href="PostBuffer.html" title="A buffer for storing posts, extending GlobalPost which supplies an ID" class="class"></a><a href="PostBuffer.html" title="A buffer for storing posts, extending GlobalPost which supplies an ID">PostBuffer</a></li><li class="current-entities indented2"><a href="PostData$.html" title="" class="object"></a> <a href="PostData.html" title="Data for a post, including the implicit saying it is postable" class="class"></a><a href="PostData.html" title="Data for a post, including the implicit saying it is postable">PostData</a></li><li class="current-entities indented2"><a href="PostDiscarder$.html" title="" class="object"></a> <a href="PostDiscarder.html" title="" class="trait"></a><a href="PostDiscarder.html" title="">PostDiscarder</a></li><li class="current-entities indented2"><a href="PostHistory$.html" title="" class="object"></a> <a href="PostHistory.html" title="" class="trait"></a><a href="PostHistory.html" title="">PostHistory</a></li><li class="current-entities indented2"><a href="PostMaps$.html" title="" class="object"></a> <a href="PostMaps.html" title="" class="trait"></a><a href="PostMaps.html" title="">PostMaps</a></li><li class="current-entities indented2"><a href="PostResponse$.html" title="" class="object"></a> <a href="PostResponse.html" title="Response to a post, generating one or more posts or just a callback; this exists mainly for nicer type collections." class="trait"></a><a href="PostResponse.html" title="Response to a post, generating one or more posts or just a callback; this exists mainly for nicer type collections.">PostResponse</a></li><li class="current-entities indented2"><a href="Postable$.html" title="" class="object"></a> <a href="Postable.html" title="Typeclass for being able to post with content type P in W" class="trait"></a><a href="Postable.html" title="Typeclass for being able to post with content type P in W">Postable</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="PreviousPosts.html" title="" class="class"></a><a href="PreviousPosts.html" title="">PreviousPosts</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="ProductIndexExpression.html" title="" class="class"></a><a href="ProductIndexExpression.html" title="">ProductIndexExpression</a></li><li class="current-entities indented2"><a href="ProofEntropies$.html" title="" class="object"></a> <a href="ProofEntropies.html" title="" class="class"></a><a href="ProofEntropies.html" title="">ProofEntropies</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="ProverTasks$.html" title="" class="object"></a><a href="ProverTasks$.html" title="">ProverTasks</a></li><li class="current-entities indented2"><a href="QueryBaseState$.html" title="" class="object"></a> <a href="QueryBaseState.html" title="" class="class"></a><a href="QueryBaseState.html" title="">QueryBaseState</a></li><li class="current-entities indented2"><a href="QueryEquations$.html" title="" class="object"></a> <a href="QueryEquations.html" title="" class="class"></a><a href="QueryEquations.html" title="">QueryEquations</a></li><li class="current-entities indented2"><a href="QueryFromPosts$.html" title="" class="object"></a> <a href="QueryFromPosts.html" title="" class="trait"></a><a href="QueryFromPosts.html" title="">QueryFromPosts</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="QueryImplicit.html" title="" class="class"></a><a href="QueryImplicit.html" title="">QueryImplicit</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="QueryImplicitWrap.html" title="Have a wrapper type T for the query and make the companion object extend this class, giving query-from-posts as input (whose type should be deducable)" class="class"></a><a href="QueryImplicitWrap.html" title="Have a wrapper type T for the query and make the companion object extend this class, giving query-from-posts as input (whose type should be deducable)">QueryImplicitWrap</a></li><li class="current-entities indented2"><a href="QueryInitState$.html" title="" class="object"></a> <a href="QueryInitState.html" title="" class="class"></a><a href="QueryInitState.html" title="">QueryInitState</a></li><li class="current-entities indented2"><a href="QueryOptions$.html" title="" class="object"></a> <a href="QueryOptions.html" title="" class="class"></a><a href="QueryOptions.html" title="">QueryOptions</a></li><li class="current-entities indented2"><a href="QueryProver$.html" title="" class="object"></a> <a href="QueryProver.html" title="" class="class"></a><a href="QueryProver.html" title="">QueryProver</a></li><li class="current-entities indented2"><a href="Queryable$.html" title="" class="object"></a> <a href="Queryable.html" title="Typeclass for being able to query W for type Q" class="trait"></a><a href="Queryable.html" title="Typeclass for being able to query W for type Q">Queryable</a></li><li class="current-entities indented2"><a href="RandomVar$.html" title="" class="object"></a> <a href="RandomVar.html" title="A formal Random Variable up to equality of distribution." class="class"></a><a href="RandomVar.html" title="A formal Random Variable up to equality of distribution.">RandomVar</a></li><li class="current-entities indented2"><a href="RandomVarFamily$.html" title="" class="object"></a> <a href="RandomVarFamily.html" title="A formal family of Random Variables up to equality of distribution." class="class"></a><a href="RandomVarFamily.html" title="A formal family of Random Variables up to equality of distribution.">RandomVarFamily</a></li><li class="current-entities indented2"><a href="RandomVarList$.html" title="" class="object"></a> <a href="RandomVarList.html" title="List of random variables, e.g." class="trait"></a><a href="RandomVarList.html" title="List of random variables, e.g.">RandomVarList</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="RandomVarMemo.html" title="" class="class"></a><a href="RandomVarMemo.html" title="">RandomVarMemo</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="RandomVarValues.html" title="" class="trait"></a><a href="RandomVarValues.html" title="">RandomVarValues</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="RandomVector.html" title="distributions of vectors from a base distribution" class="class"></a><a href="RandomVector.html" title="distributions of vectors from a base distribution">RandomVector</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="RecParDistEq.html" title="" class="trait"></a><a href="RecParDistEq.html" title="">RecParDistEq</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="RecursiveGeneratorNode.html" title="" class="trait"></a><a href="RecursiveGeneratorNode.html" title="">RecursiveGeneratorNode</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="RecursiveGeneratorNodeFamily.html" title="" class="trait"></a><a href="RecursiveGeneratorNodeFamily.html" title="">RecursiveGeneratorNodeFamily</a></li><li class="current-entities indented2"><a href="Representation$.html" title="" class="object"></a> <a href="Representation.html" title="" class="class"></a><a href="Representation.html" title="">Representation</a></li><li class="current-entities indented2"><a href="RepresentationLearner$.html" title="" class="object"></a> <a href="RepresentationLearner.html" title="" class="class"></a><a href="RepresentationLearner.html" title="">RepresentationLearner</a></li><li class="current-entities indented2"><a href="Samples$.html" title="" class="object"></a> <a href="Samples.html" title="" class="trait"></a><a href="Samples.html" title="">Samples</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="SimpleDataGetter.html" title="" class="trait"></a><a href="SimpleDataGetter.html" title="">SimpleDataGetter</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="SimpleEquations$.html" title="" class="object"></a><a href="SimpleEquations$.html" title="">SimpleEquations</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="SimpleSession.html" title="A simple session to post stuff, call responses and if these responses generate posts, recursively call itself for them." class="class"></a><a href="SimpleSession.html" title="A simple session to post stuff, call responses and if these responses generate posts, recursively call itself for them.">SimpleSession</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="SnapShot.html" title="" class="class"></a><a href="SnapShot.html" title="">SnapShot</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="SomePost.html" title="Wrapper to query for all posts, even after the query position or in a different thread" class="class"></a><a href="SomePost.html" title="Wrapper to query for all posts, even after the query position or in a different thread">SomePost</a></li><li class="current-entities indented2"><a href="Sort$.html" title="" class="object"></a> <a href="Sort.html" title="A sort, i.e." class="trait"></a><a href="Sort.html" title="A sort, i.e.">Sort</a></li><li class="current-entities indented2"><a href="SortList$.html" title="" class="object"></a> <a href="SortList.html" title="List of Sorts, used as domains for families." class="trait"></a><a href="SortList.html" title="List of Sorts, used as domains for families.">SortList</a></li><li class="current-entities indented2"><a href="SpireExprEquations$.html" title="" class="object"></a> <a href="SpireExprEquations.html" title="" class="class"></a><a href="SpireExprEquations.html" title="">SpireExprEquations</a></li><li class="current-entities indented2"><a href="SpireGradient$.html" title="" class="object"></a> <a href="SpireGradient.html" title="" class="class"></a><a href="SpireGradient.html" title="">SpireGradient</a></li><li class="current-entities indented2"><a href="SplitPost$.html" title="" class="object"></a> <a href="SplitPost.html" title="Wrapper for post content that should be posted, with the previous elements of the same type also posted, in general with transformations (e.g." class="class"></a><a href="SplitPost.html" title="Wrapper for post content that should be posted, with the previous elements of the same type also posted, in general with transformations (e.g.">SplitPost</a></li><li class="current-entities indented2"><a href="StateDistribution$.html" title="" class="object"></a> <a href="StateDistribution.html" title="typeclass for providing distributions from a state" class="trait"></a><a href="StateDistribution.html" title="typeclass for providing distributions from a state">StateDistribution</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="StateEvolver.html" title="" class="trait"></a><a href="StateEvolver.html" title="">StateEvolver</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="StochasticLang.html" title="" class="class"></a><a href="StochasticLang.html" title="">StochasticLang</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="StrategicProvers$.html" title="" class="object"></a><a href="StrategicProvers$.html" title="">StrategicProvers</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="SumIndexExpression.html" title="" class="class"></a><a href="SumIndexExpression.html" title="">SumIndexExpression</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Support.html" title="" class="trait"></a><a href="Support.html" title="">Support</a></li><li class="current-entities indented2"><a href="TFData$.html" title="" class="object"></a> <a href="TFData.html" title="" class="class"></a><a href="TFData.html" title="">TFData</a></li><li class="current-entities indented2"><a href="TFDist$.html" title="" class="object"></a> <a href="TFDist.html" title="" class="class"></a><a href="TFDist.html" title="">TFDist</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TFEg.html" title="" class="class"></a><a href="TFEg.html" title="">TFEg</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TangSamples.html" title="" class="trait"></a><a href="TangSamples.html" title="">TangSamples</a></li><li class="current-entities indented2"><a href="TangVec$.html" title="" class="object"></a> <a href="TangVec.html" title="" class="class"></a><a href="TangVec.html" title="">TangVec</a></li><li class="current-entities indented2"><a href="TangentFiniteDistribution$.html" title="" class="object"></a> <a href="TangentFiniteDistribution.html" title="resolving a general specification of a recursive generative model as finite distributions, depending on truncation; the coefficients of the various generator nodes should be Double" class="class"></a><a href="TangentFiniteDistribution.html" title="resolving a general specification of a recursive generative model as finite distributions, depending on truncation; the coefficients of the various generator nodes should be Double">TangentFiniteDistribution</a></li><li class="current-entities indented2"><a href="TensorFlowExprEquations$.html" title="" class="object"></a> <a href="TensorFlowExprEquations.html" title="" class="class"></a><a href="TensorFlowExprEquations.html" title="">TensorFlowExprEquations</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TensorFlowExprVarEquations.html" title="" class="class"></a><a href="TensorFlowExprVarEquations.html" title="">TensorFlowExprVarEquations</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TensorFlowFatExprEquations.html" title="" class="class"></a><a href="TensorFlowFatExprEquations.html" title="">TensorFlowFatExprEquations</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TensorflowExpressions.html" title="" class="class"></a><a href="TensorflowExpressions.html" title="">TensorflowExpressions</a></li><li class="current-entities indented2"><a href="TermBucket$.html" title="" class="object"></a> <a href="TermBucket.html" title="" class="class"></a><a href="TermBucket.html" title="">TermBucket</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TermData$.html" title="" class="object"></a><a href="TermData$.html" title="">TermData</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TermEvolution.html" title="" class="trait"></a><a href="TermEvolution.html" title="">TermEvolution</a></li><li class="current-entities indented2"><a href="TermEvolutionStep$.html" title="" class="object"></a> <a href="TermEvolutionStep.html" title="" class="class"></a><a href="TermEvolutionStep.html" title="">TermEvolutionStep</a></li><li class="current-entities indented2"><a href="TermEvolver$.html" title="" class="object"></a> <a href="TermEvolver.html" title="" class="class"></a><a href="TermEvolver.html" title="">TermEvolver</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TermGenCost.html" title="" class="class"></a><a href="TermGenCost.html" title="">TermGenCost</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TermGenEqCost.html" title="" class="class"></a><a href="TermGenEqCost.html" title="">TermGenEqCost</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TermGenJson$.html" title="" class="object"></a><a href="TermGenJson$.html" title="">TermGenJson</a></li><li class="current-entities indented2"><a href="TermGenParams$.html" title="" class="object"></a> <a href="TermGenParams.html" title="" class="class"></a><a href="TermGenParams.html" title="">TermGenParams</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TermGenParamsNodes.html" title="" class="class"></a><a href="TermGenParamsNodes.html" title="">TermGenParamsNodes</a></li><li class="current-entities indented2"><a href="TermGeneratorNodes$.html" title="Combining terms and subclasses to get terms, types, functions etc; these are abstract specifications, to be used for generating distributions, obtaining equations etc." class="object"></a> <a href="" title="Combining terms and subclasses to get terms, types, functions etc; these are abstract specifications, to be used for generating distributions, obtaining equations etc." class="class"></a><a href="" title="Combining terms and subclasses to get terms, types, functions etc; these are abstract specifications, to be used for generating distributions, obtaining equations etc.">TermGeneratorNodes</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TermLearner.html" title="Adding equations from a simple generative model to EvolverEquations" class="class"></a><a href="TermLearner.html" title="Adding equations from a simple generative model to EvolverEquations">TermLearner</a></li><li class="current-entities indented2"><a href="TermNodeCoeffSeq$.html" title="" class="object"></a> <a href="TermNodeCoeffSeq.html" title="" class="class"></a><a href="TermNodeCoeffSeq.html" title="">TermNodeCoeffSeq</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TermPopulation.html" title="" class="class"></a><a href="TermPopulation.html" title="">TermPopulation</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TermProver$.html" title="" class="object"></a><a href="TermProver$.html" title="">TermProver</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TermRandomVars$.html" title="" class="object"></a><a href="TermRandomVars$.html" title="">TermRandomVars</a></li><li class="current-entities indented2"><a href="TermState$.html" title="" class="object"></a> <a href="TermState.html" title="A state, typically the initial state, for generating terms, types etc" class="class"></a><a href="TermState.html" title="A state, typically the initial state, for generating terms, types etc">TermState</a></li><li class="current-entities indented2"><a href="TermsTypThms$.html" title="" class="object"></a> <a href="TermsTypThms.html" title="" class="trait"></a><a href="TermsTypThms.html" title="">TermsTypThms</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TestCustomQuery$.html" title="" class="object"></a><a href="TestCustomQuery$.html" title="">TestCustomQuery</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TheoremFeedback.html" title="feedback based on the term-type map as well as ensuring total weight of theorems is not  small; various steps are explicit for exploration and debugging" class="class"></a><a href="TheoremFeedback.html" title="feedback based on the term-type map as well as ensuring total weight of theorems is not  small; various steps are explicit for exploration and debugging">TheoremFeedback</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="ThmEntropies.html" title="" class="class"></a><a href="ThmEntropies.html" title="">ThmEntropies</a></li><li class="current-entities indented2"><a href="TruncDistVal$.html" title="" class="object"></a> <a href="TruncDistVal.html" title="" class="class"></a><a href="TruncDistVal.html" title="">TruncDistVal</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Truncate$.html" title="" class="object"></a><a href="Truncate$.html" title="">Truncate</a></li><li class="current-entities indented2"><a href="TruncatedDistribution$.html" title="" class="object"></a> <a href="TruncatedDistribution.html" title="" class="trait"></a><a href="TruncatedDistribution.html" title="">TruncatedDistribution</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TruncatedDistributionDomain.html" title="" class="class"></a><a href="TruncatedDistributionDomain.html" title="">TruncatedDistributionDomain</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TruncatedDistributionExprPatterns.html" title="" class="class"></a><a href="TruncatedDistributionExprPatterns.html" title="">TruncatedDistributionExprPatterns</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TruncatedDistributionLang.html" title="" class="class"></a><a href="TruncatedDistributionLang.html" title="">TruncatedDistributionLang</a></li><li class="current-entities indented2"><a href="TruncatedFiniteDistribution$.html" title="" class="object"></a> <a href="TruncatedFiniteDistribution.html" title="resolving a general specification of a recursive generative model as finite distributions, depending on truncation; the coefficients of the various generator nodes should be Double" class="class"></a><a href="TruncatedFiniteDistribution.html" title="resolving a general specification of a recursive generative model as finite distributions, depending on truncation; the coefficients of the various generator nodes should be Double">TruncatedFiniteDistribution</a></li><li class="current-entities indented2"><a href="TypSolver$.html" title="" class="object"></a> <a href="TypSolver.html" title="" class="trait"></a><a href="TypSolver.html" title="">TypSolver</a></li><li class="current-entities indented2"><a href="TypedPostResponse$.html" title="" class="object"></a> <a href="TypedPostResponse.html" title="Post response with type P of post as a type parameter" class="class"></a><a href="TypedPostResponse.html" title="Post response with type P of post as a type parameter">TypedPostResponse</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Unify$.html" title="" class="object"></a><a href="Unify$.html" title="">Unify</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="VarValueSet.html" title="" class="class"></a><a href="VarValueSet.html" title="">VarValueSet</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="WebBuffer.html" title="" class="class"></a><a href="WebBuffer.html" title="">WebBuffer</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="WebState.html" title="" class="class"></a><a href="WebState.html" title="">WebState</a></li><li class="current-entities indented2"><a href="WeightVect$.html" title="" class="object"></a> <a href="WeightVect.html" title="" class="class"></a><a href="WeightVect.html" title="">WeightVect</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="WeightedBackPaths.html" title="" class="class"></a><a href="WeightedBackPaths.html" title="">WeightedBackPaths</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="WeightedBiPaths.html" title="" class="class"></a><a href="WeightedBiPaths.html" title="">WeightedBiPaths</a></li><li class="current-entities indented2"><a href="WeightedTermBucket$.html" title="" class="object"></a> <a href="WeightedTermBucket.html" title="" class="class"></a><a href="WeightedTermBucket.html" title="">WeightedTermBucket</a></li></ul></div></div><div id="content"><body class="class type"><div id="definition"><a href="TermGeneratorNodes$.html" title="See companion object"><div class="big-circle class-companion-object">c</div></a><p id="owner"><a href="../index.html" name="provingground" id="provingground" class="extype">provingground</a>.<a href="index.html" name="provingground.learning" id="provingground.learning" class="extype">learning</a></p><h1><a href="TermGeneratorNodes$.html" title="See companion object">TermGeneratorNodes</a><span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"><div>Companion <a href="TermGeneratorNodes$.html" title="See companion object">object TermGeneratorNodes</a></div></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><span class="name">TermGeneratorNodes</span><span class="tparams">[<span name="InitState">InitState</span>]</span><span class="result"> extends <a href="../../scala/index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Combining terms and subclasses to get terms, types, functions etc; these are abstract specifications,
to be used for generating distributions, obtaining equations etc.
</p></div><dl class="paramcmts block"><dt class="tparam">InitState</dt><dd class="cmt"><p>the initial state for the dynamics, equations etc</p></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="../../scala/index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a>, <span name="scala.Any" class="extype">Any</span></div></div></div><div class="toggleContainer"><div class="toggle block"><span>Known Subclasses</span><div class="subClasses hiddenContent"><a href="ParMapState$$ParBaseNodes$.html" name="provingground.learning.ParMapState.ParBaseNodes" id="provingground.learning.ParMapState.ParBaseNodes" class="extype">ParBaseNodes</a>, <a href="ParMapState$$ParGenNodes.html" name="provingground.learning.ParMapState.ParGenNodes" id="provingground.learning.ParMapState.ParGenNodes" class="extype">ParGenNodes</a>, <a href="TermGenParamsNodes.html" name="provingground.learning.TermGenParamsNodes" id="provingground.learning.TermGenParamsNodes" class="extype">TermGenParamsNodes</a>, <a href="TermGeneratorNodes$$Base$.html" name="provingground.learning.TermGeneratorNodes.Base" id="provingground.learning.TermGeneratorNodes.Base" class="extype">Base</a></div></div></div><div id="inheritance-diagram-container" class="toggleContainer block diagram-container"><span class="toggle diagram-link">Type Hierarchy</span><div id="inheritance-diagram" class="diagram hiddenContent"><svg id="graph1" class="class-diagram" width="800" height="600"></svg><script type="text/dot" id="dot1">
digraph G {
  
  subgraph clusterAll {
  style = "invis"
  
  subgraph clusterThis {
  style="invis"
  node0 [URL="#inheritance-diagram-container", label="TermGeneratorNodes[InitState]", id="graph1_0", class="this class", tooltip="provingground.learning.TermGeneratorNodes (this class)"] ;
}
  
  
  
}
  
  node1 [URL="TermGeneratorNodes$$Base$.html#inheritance-diagram-container", label="TermGeneratorNodes.Base", id="graph1_1", class="default", tooltip="provingground.learning.TermGeneratorNodes.Base"] ;
  node2 [URL="ParMapState$$ParBaseNodes$.html#inheritance-diagram-container", label="ParBaseNodes", id="graph1_2", class="default", tooltip="provingground.learning.ParMapState.ParBaseNodes"] ;
  node3 [URL="ParMapState$$ParGenNodes.html#inheritance-diagram-container", label="ParGenNodes", id="graph1_3", class="default", tooltip="provingground.learning.ParMapState.ParGenNodes"] ;
  node4 [URL="TermGenParamsNodes.html#inheritance-diagram-container", label="TermGenParamsNodes", id="graph1_4", class="default", tooltip="provingground.learning.TermGenParamsNodes"] ;
  node5 [label="AnyRef", id="graph1_5", class="default", tooltip="scala.AnyRef"] ;
  node5 -> node0 [arrowtail="empty", dir="back", id="graph1_5_0", class="inheritance", tooltip="TermGeneratorNodes[InitState] is a subtype of AnyRef"] ;
  node0 -> node1 [arrowtail="empty", dir="back", id="graph1_0_1", class="inheritance", tooltip="TermGeneratorNodes.Base is a subtype of TermGeneratorNodes[InitState]"] ;
  node0 -> node2 [arrowtail="empty", dir="back", id="graph1_0_2", class="inheritance", tooltip="ParBaseNodes is a subtype of TermGeneratorNodes[InitState]"] ;
  node0 -> node3 [arrowtail="empty", dir="back", id="graph1_0_3", class="inheritance", tooltip="ParGenNodes is a subtype of TermGeneratorNodes[InitState]"] ;
  node0 -> node4 [arrowtail="empty", dir="back", id="graph1_0_4", class="inheritance", tooltip="TermGenParamsNodes is a subtype of TermGeneratorNodes[InitState]"] ;
}
</script><script>$("#inheritance-diagram").bind('beforeShow', function() {
  if ($("svg#graph1").children().length == 0) {
    var dot = document.querySelector("#dot1").text;
    var svg = d3.select("#graph1");
    var inner = svg.append("g");

    // Set up zoom support
    var zoom = d3.zoom()
        .on("zoom", function() {
          inner.attr("transform", d3.event.transform);
        });
    svg.call(zoom);

    var render = new dagreD3.render();
    var g = graphlibDot.read(dot);
    render(inner, g);

    inner.selectAll("g.node").each(function(v) {
      // https://stackoverflow.com/questions/27381452/wrapping-existing-inline-svg-g-element-with-a-element
      var tgt = $("#"+ g.node(v).id +" g.label text")[0];
      var parent = tgt.parentNode;
      var a = document.createElementNS('http://www.w3.org/2000/svg', 'a');
      a.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', g.node(v).URL);
      a.appendChild(tgt);
      parent.appendChild(a);
    });
  }
})</script></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="provingground.learning.TermGeneratorNodes"><span>TermGeneratorNodes</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype">Implicitly<br/></span><ol id="implicits"><li class="in" name="scala.Predef.any2stringadd" data-hidden="true"><span>by any2stringadd</span></li><li class="in" name="scala.Predef.StringFormat" data-hidden="true"><span>by StringFormat</span></li><li class="in" name="scala.Predef.Ensuring" data-hidden="true"><span>by Ensuring</span></li><li class="in" name="scala.Predef.ArrowAssoc" data-hidden="true"><span>by ArrowAssoc</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="constructors" class="members"><h3>Instance Constructors</h3><ol><li class="indented0 " name="provingground.learning.TermGeneratorNodes#&lt;init&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;init&gt;(appln:(provingground.HoTT.ExstFunc,provingground.HoTT.Term)=&gt;provingground.HoTT.Term,unifApplnOpt:(provingground.HoTT.ExstFunc,provingground.HoTT.Term)=&gt;Option[provingground.HoTT.Term],addVar:provingground.HoTT.Typ[provingground.HoTT.Term]=&gt;(InitState=&gt;(Double=&gt;(InitState,provingground.HoTT.Term))),getVar:provingground.HoTT.Typ[provingground.HoTT.Term]=&gt;provingground.HoTT.Term,inIsle:(provingground.HoTT.Term,InitState)=&gt;InitState):provingground.learning.TermGeneratorNodes[InitState]"></a><a id="&lt;init&gt;:TermGeneratorNodes[InitState]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#&lt;init&gt;(appln:(provingground.HoTT.ExstFunc,provingground.HoTT.Term)=&gt;provingground.HoTT.Term,unifApplnOpt:(provingground.HoTT.ExstFunc,provingground.HoTT.Term)=&gt;Option[provingground.HoTT.Term],addVar:provingground.HoTT.Typ[provingground.HoTT.Term]=&gt;(InitState=&gt;(Double=&gt;(InitState,provingground.HoTT.Term))),getVar:provingground.HoTT.Typ[provingground.HoTT.Term]=&gt;provingground.HoTT.Term,inIsle:(provingground.HoTT.Term,InitState)=&gt;InitState):provingground.learning.TermGeneratorNodes[InitState]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">new</span></span> <span class="symbol"><span class="name">TermGeneratorNodes</span><span class="params">(<span name="appln">appln: (<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>) =&gt; <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>, <span name="unifApplnOpt">unifApplnOpt: (<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>) =&gt; <span name="scala.Option" class="extype">Option</span>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>, <span name="addVar">addVar: (<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]) =&gt; (<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>) =&gt; (<span name="scala.Double" class="extype">Double</span>) =&gt; (<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>)</span>, <span name="getVar">getVar: (<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]) =&gt; <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>, <span name="inIsle">inIsle: (<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>) =&gt; <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span></span>)</span></span><p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt class="param">appln</dt><dd class="cmt"><p>function application, assuming domain and type match</p></dd><dt class="param">unifApplnOpt</dt><dd class="cmt"><p>unified application of functions</p></dd><dt class="param">addVar</dt><dd class="cmt"><p>new state with a variable, of specified type, added</p></dd><dt class="param">getVar</dt><dd class="cmt"><p>a variable of a specified type</p></dd></dl></div></li></ol></div><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="provingground.learning.TermGeneratorNodes.FoldFuncTargetNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="FoldFuncTargetNodeextendsprovingground.HoTT.Term=&gt;Option[provingground.learning.GeneratorNode[provingground.HoTT.Term]]withProductwithSerializable"></a><a id="FoldFuncTargetNode:FoldFuncTargetNode"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$FoldFuncTargetNode.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="TermGeneratorNodes$FoldFuncTargetNode.html" title=""><span class="name">FoldFuncTargetNode</span></a><span class="params">(<span name="typ">typ: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result"> extends (<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>) =&gt; <span name="scala.Option" class="extype">Option</span>[<a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.TargetInducFuncsFolded" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="TargetInducFuncsFoldedextendsprovingground.induction.ExstInducDefn=&gt;Option[provingground.learning.GeneratorNode[provingground.HoTT.Term]]withProductwithSerializable"></a><a id="TargetInducFuncsFolded:TargetInducFuncsFolded"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$TargetInducFuncsFolded.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="TermGeneratorNodes$TargetInducFuncsFolded.html" title=""><span class="name">TargetInducFuncsFolded</span></a><span class="params">(<span name="target">target: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result"> extends (<a href="../induction/ExstInducDefn.html" name="provingground.induction.ExstInducDefn" id="provingground.induction.ExstInducDefn" class="extype">ExstInducDefn</a>) =&gt; <span name="scala.Option" class="extype">Option</span>[<a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##:Int"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html###:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.Predef.any2stringadd#+" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="+(other:String):String"></a><a id="+(String):String"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#+(other:String):String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit" title="gt4s: $plus">+</span><span class="params">(<span name="other">other: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>] to<span name="scala.Predef.any2stringadd" class="extype">any2stringadd</span>[<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]] performed by method any2stringadd in scala.Predef.</dd><dt>Definition Classes</dt><dd>any2stringadd</dd></dl></div></li><li class="indented0 " name="scala.Predef.ArrowAssoc#-&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="-&gt;[B](y:B):(A,B)"></a><a id="-&gt;[B](B):(TermGeneratorNodes[InitState],B)"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#-&gt;[B](y:B):(A,B)" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit" title="gt4s: $minus$greater">-&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span name="scala.Predef.ArrowAssoc.-&gt;.B" class="extype">B</span></span>)</span><span class="result">: (<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>], <span name="scala.Predef.ArrowAssoc.-&gt;.B" class="extype">B</span>)</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>] to<span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]] performed by method ArrowAssoc in scala.Predef.</dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#applnByArgNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="applnByArgNode:provingground.learning.GeneratorNode.FiberProductMap[provingground.HoTT.Term,provingground.HoTT.ExstFunc,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]"></a><a id="applnByArgNode:FiberProductMap[Term,ExstFunc,Typ[Term],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#applnByArgNode:provingground.learning.GeneratorNode.FiberProductMap[provingground.HoTT.Term,provingground.HoTT.ExstFunc,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">applnByArgNode</span><span class="result">: <a href="GeneratorNode$$FiberProductMap.html" name="provingground.learning.GeneratorNode.FiberProductMap" id="provingground.learning.GeneratorNode.FiberProductMap" class="extype">FiberProductMap</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>, <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">function application to get terms by choosing an argument and then a function with domain containing this.</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#applnNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="applnNode:provingground.learning.GeneratorNode.FiberProductMap[provingground.HoTT.ExstFunc,provingground.HoTT.Term,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]"></a><a id="applnNode:FiberProductMap[ExstFunc,Term,Typ[Term],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#applnNode:provingground.learning.GeneratorNode.FiberProductMap[provingground.HoTT.ExstFunc,provingground.HoTT.Term,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">applnNode</span><span class="result">: <a href="GeneratorNode$$FiberProductMap.html" name="provingground.learning.GeneratorNode.FiberProductMap" id="provingground.learning.GeneratorNode.FiberProductMap" class="extype">FiberProductMap</a>[<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">function application to get terms by choosing a function and then a term in its domain
</p></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#backwardTypNodeFamily" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="backwardTypNodeFamily:provingground.learning.GeneratorNodeFamily.BasePiOpt[provingground.HoTT.Typ[provingground.HoTT.Term]::shapeless.HNil,provingground.HoTT.Term]"></a><a id="backwardTypNodeFamily:BasePiOpt[::[Typ[Term],HNil],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#backwardTypNodeFamily:provingground.learning.GeneratorNodeFamily.BasePiOpt[provingground.HoTT.Typ[provingground.HoTT.Term]::shapeless.HNil,provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">backwardTypNodeFamily</span><span class="result">: <a href="GeneratorNodeFamily$$BasePiOpt.html" name="provingground.learning.GeneratorNodeFamily.BasePiOpt" id="provingground.learning.GeneratorNodeFamily.BasePiOpt" class="extype">BasePiOpt</a>[<span name="shapeless.::" class="extype">::</span>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="shapeless.HNil" class="extype">HNil</span>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">nodes combining backward reasoning targeting types that are  (dependent) function types,
aggregated over all types
</p></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object"></a><a id="clone():AnyRef"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <a href="../../scala/index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#curryBackwardTypNodeFamily" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="curryBackwardTypNodeFamily:provingground.learning.GeneratorNodeFamily.BasePiOpt[provingground.HoTT.Typ[provingground.HoTT.Term]::shapeless.HNil,provingground.HoTT.Term]"></a><a id="curryBackwardTypNodeFamily:BasePiOpt[::[Typ[Term],HNil],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#curryBackwardTypNodeFamily:provingground.learning.GeneratorNodeFamily.BasePiOpt[provingground.HoTT.Typ[provingground.HoTT.Term]::shapeless.HNil,provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">curryBackwardTypNodeFamily</span><span class="result">: <a href="GeneratorNodeFamily$$BasePiOpt.html" name="provingground.learning.GeneratorNodeFamily.BasePiOpt" id="provingground.learning.GeneratorNodeFamily.BasePiOpt" class="extype">BasePiOpt</a>[<span name="shapeless.::" class="extype">::</span>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="shapeless.HNil" class="extype">HNil</span>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">nodes combining backward reasoning targeting types that are  (dependent) function types, with domain product, sigma-types or co-products
aggregated over all types
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#curryForTyp" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="curryForTyp(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):Option[provingground.learning.GeneratorNode[provingground.HoTT.Term]]"></a><a id="curryForTyp(Typ[Term]):Option[GeneratorNode[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#curryForTyp(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):Option[provingground.learning.GeneratorNode[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">curryForTyp</span><span class="params">(<span name="typ">typ: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">node for targeting functions on products by currying, and also on sigma-types and co-products
</p></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:A=&gt;Boolean,msg:=&gt;Any):A"></a><a id="ensuring((TermGeneratorNodes[InitState])=&gt;Boolean,=&gt;Any):TermGeneratorNodes[InitState]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#ensuring(cond:A=&gt;Boolean,msg:=&gt;Any):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="msg">msg: =&gt; <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:A=&gt;Boolean):A"></a><a id="ensuring((TermGeneratorNodes[InitState])=&gt;Boolean):TermGeneratorNodes[InitState]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#ensuring(cond:A=&gt;Boolean):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:Boolean,msg:=&gt;Any):A"></a><a id="ensuring(Boolean,=&gt;Any):TermGeneratorNodes[InitState]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#ensuring(cond:Boolean,msg:=&gt;Any):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="msg">msg: =&gt; <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:Boolean):A"></a><a id="ensuring(Boolean):TermGeneratorNodes[InitState]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#ensuring(cond:Boolean):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="../../scala/index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean"></a><a id="equals(AnyRef):Boolean"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <a href="../../scala/index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#foldFuncNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="foldFuncNode(t:provingground.HoTT.Term,depth:Int):provingground.learning.GeneratorNode[provingground.HoTT.Term]"></a><a id="foldFuncNode(Term,Int):GeneratorNode[Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#foldFuncNode(t:provingground.HoTT.Term,depth:Int):provingground.learning.GeneratorNode[provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldFuncNode</span><span class="params">(<span name="t">t: <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>, <span name="depth">depth: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">Node for folding a function (or term) with a speficied number of arguments
to get terms.</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#foldFuncTargetNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="foldFuncTargetNode(t:provingground.HoTT.Term,target:provingground.HoTT.Typ[provingground.HoTT.Term],output:provingground.learning.RandomVar[provingground.HoTT.Term]):Option[provingground.learning.GeneratorNode[provingground.HoTT.Term]]"></a><a id="foldFuncTargetNode(Term,Typ[Term],RandomVar[Term]):Option[GeneratorNode[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#foldFuncTargetNode(t:provingground.HoTT.Term,target:provingground.HoTT.Typ[provingground.HoTT.Term],output:provingground.learning.RandomVar[provingground.HoTT.Term]):Option[provingground.learning.GeneratorNode[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldFuncTargetNode</span><span class="params">(<span name="t">t: <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>, <span name="target">target: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>, <span name="output">output: <a href="RandomVar.html" name="provingground.learning.RandomVar" id="provingground.learning.RandomVar" class="extype">RandomVar</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">Node for folding a function (or term) with a speficied target type
to optionally get terms with the target type.</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#foldTypFamily" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="foldTypFamily(w:provingground.HoTT.Term):provingground.learning.GeneratorNode[provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="foldTypFamily(Term):GeneratorNode[Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#foldTypFamily(w:provingground.HoTT.Term):provingground.learning.GeneratorNode[provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldTypFamily</span><span class="params">(<span name="w">w: <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>)</span><span class="result">: <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">Node for fully folding a type family to get types
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#foldedTargetFunctionNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="foldedTargetFunctionNode(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.FlatMapOpt[provingground.HoTT.Term,provingground.HoTT.Term]"></a><a id="foldedTargetFunctionNode(Typ[Term]):FlatMapOpt[Term,Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#foldedTargetFunctionNode(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.FlatMapOpt[provingground.HoTT.Term,provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldedTargetFunctionNode</span><span class="params">(<span name="typ">typ: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$FlatMapOpt.html" name="provingground.learning.GeneratorNode.FlatMapOpt" id="provingground.learning.GeneratorNode.FlatMapOpt" class="extype">FlatMapOpt</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">Node for generating terms of a type (if possible) by multiple applications of functions tageting the type.</p></li><li class="indented0 " name="scala.Predef.StringFormat#formatted" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="formatted(fmtstr:String):String"></a><a id="formatted(String):String"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#formatted(fmtstr:String):String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">formatted</span><span class="params">(<span name="fmtstr">fmtstr: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>] to<span name="scala.Predef.StringFormat" class="extype">StringFormat</span>[<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]] performed by method StringFormat in scala.Predef.</dd><dt>Definition Classes</dt><dd>StringFormat</dd><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]"></a><a id="getClass():Class[_&lt;:AnyRef]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#java.lang.Class" name="java.lang.Class" id="java.lang.Class" class="extype">Class</a>[_ &lt;: <a href="../../scala/index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#indexedInducIdNode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="indexedInducIdNode(typF:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Map[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="indexedInducIdNode(Typ[Term]):Map[Typ[Term],Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#indexedInducIdNode(typF:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Map[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">indexedInducIdNode</span><span class="params">(<span name="typF">typF: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$Map.html" name="provingground.learning.GeneratorNode.Map" id="provingground.learning.GeneratorNode.Map" class="extype">Map</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">Start of an indexed introduction rule by fully applying a type family
</p><div class="fullcomment"><div class="comment cmt"><p>Start of an indexed introduction rule by fully applying a type family
</p></div><dl class="paramcmts block"><dt class="param">typF</dt><dd class="cmt"><p>the type family for the inductive type</p></dd><dt>returns</dt><dd class="cmt"><p>distribution of types</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#indexedIterFuncIsle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="indexedIterFuncIsle(targetTyp:provingground.HoTT.Term)(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Typ[provingground.HoTT.Term],InitState,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]"></a><a id="indexedIterFuncIsle(Term)(Typ[Term]):Island[Typ[Term],InitState,Typ[Term],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#indexedIterFuncIsle(targetTyp:provingground.HoTT.Term)(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Typ[provingground.HoTT.Term],InitState,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">indexedIterFuncIsle</span><span class="params">(<span name="targetTyp">targetTyp: <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>)</span><span class="params">(<span name="typ">typ: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$Island.html" name="provingground.learning.GeneratorNode.Island" id="provingground.learning.GeneratorNode.Island" class="extype">Island</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>, <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">Extending indexed introduction rule by an iterated function ending in the inductive type family fully applied.</p><div class="fullcomment"><div class="comment cmt"><p>Extending indexed introduction rule by an iterated function ending in the inductive type family fully applied.
</p></div><dl class="paramcmts block"><dt class="param">typ</dt><dd class="cmt"><p>the type by which we are extending</p></dd><dt>returns</dt><dd class="cmt"><p>distribution on types.</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#indexedIterFuncNode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="indexedIterFuncNode(targetTyp:provingground.HoTT.Term):provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="indexedIterFuncNode(Term):FlatMap[Typ[Term],Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#indexedIterFuncNode(targetTyp:provingground.HoTT.Term):provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">indexedIterFuncNode</span><span class="params">(<span name="targetTyp">targetTyp: <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>)</span><span class="result">: <a href="GeneratorNode$$FlatMap.html" name="provingground.learning.GeneratorNode.FlatMap" id="provingground.learning.GeneratorNode.FlatMap" class="extype">FlatMap</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">Aggregating extending indexed introduction rule by iterated function type eding in
fully applied inductive type family.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregating extending indexed introduction rule by iterated function type eding in
fully applied inductive type family.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>distribution on types.</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#indexedIterHeadNode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="indexedIterHeadNode(inductiveTyp:provingground.HoTT.Term):provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="indexedIterHeadNode(Term):FlatMap[Typ[Term],Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#indexedIterHeadNode(inductiveTyp:provingground.HoTT.Term):provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">indexedIterHeadNode</span><span class="params">(<span name="inductiveTyp">inductiveTyp: <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>)</span><span class="result">: <a href="GeneratorNode$$FlatMap.html" name="provingground.learning.GeneratorNode.FlatMap" id="provingground.learning.GeneratorNode.FlatMap" class="extype">FlatMap</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">Aggregating extending introduction types for indexed inductive types by iterated function types
</p><div class="fullcomment"><div class="comment cmt"><p>Aggregating extending introduction types for indexed inductive types by iterated function types
</p></div><dl class="paramcmts block"><dt class="param">inductiveTyp</dt><dd class="cmt"><p>the indexed inductive types</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#indexedOtherHeadIsle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="indexedOtherHeadIsle(typF:provingground.HoTT.Term)(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Typ[provingground.HoTT.Term],InitState,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]"></a><a id="indexedOtherHeadIsle(Term)(Typ[Term]):Island[Typ[Term],InitState,Typ[Term],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#indexedOtherHeadIsle(typF:provingground.HoTT.Term)(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Typ[provingground.HoTT.Term],InitState,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">indexedOtherHeadIsle</span><span class="params">(<span name="typF">typF: <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>)</span><span class="params">(<span name="typ">typ: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$Island.html" name="provingground.learning.GeneratorNode.Island" id="provingground.learning.GeneratorNode.Island" class="extype">Island</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>, <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">Extending an indexed introduction rule by a specific unrelated type
</p><div class="fullcomment"><div class="comment cmt"><p>Extending an indexed introduction rule by a specific unrelated type
</p></div><dl class="paramcmts block"><dt class="param">typF</dt><dd class="cmt"><p>the indexed inductive type family</p></dd><dt class="param">typ</dt><dd class="cmt"><p>the type by which to extends</p></dd><dt>returns</dt><dd class="cmt"><p>distribution on types</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#indexedOtherHeadNode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="indexedOtherHeadNode(typF:provingground.HoTT.Term):provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="indexedOtherHeadNode(Term):FlatMap[Typ[Term],Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#indexedOtherHeadNode(typF:provingground.HoTT.Term):provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">indexedOtherHeadNode</span><span class="params">(<span name="typF">typF: <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>)</span><span class="result">: <a href="GeneratorNode$$FlatMap.html" name="provingground.learning.GeneratorNode.FlatMap" id="provingground.learning.GeneratorNode.FlatMap" class="extype">FlatMap</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">aggregating extending introduction types for  indexed inductive types by unrelated types
</p><div class="fullcomment"><div class="comment cmt"><p>aggregating extending introduction types for  indexed inductive types by unrelated types
</p></div><dl class="paramcmts block"><dt class="param">typF</dt><dd class="cmt"><p>the indexed type family</p></dd><dt>returns</dt><dd class="cmt"><p>distribution of terms</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#indexedSelfHeadNode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="indexedSelfHeadNode(typF:provingground.HoTT.Term):provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="indexedSelfHeadNode(Term):FlatMap[Typ[Term],Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#indexedSelfHeadNode(typF:provingground.HoTT.Term):provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">indexedSelfHeadNode</span><span class="params">(<span name="typF">typF: <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>)</span><span class="result">: <a href="GeneratorNode$$FlatMap.html" name="provingground.learning.GeneratorNode.FlatMap" id="provingground.learning.GeneratorNode.FlatMap" class="extype">FlatMap</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">Aggregating extending indexed introduction rule by fully applied inductive type family.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregating extending indexed introduction rule by fully applied inductive type family.
</p></div><dl class="paramcmts block"><dt class="param">typF</dt><dd class="cmt"><p>the type family</p></dd><dt>returns</dt><dd class="cmt"><p>distribution on types.</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#inducFuncFoldedNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="inducFuncFoldedNode:provingground.learning.GeneratorNode[provingground.HoTT.Term]"></a><a id="inducFuncFoldedNode:GeneratorNode[Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#inducFuncFoldedNode:provingground.learning.GeneratorNode[provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">inducFuncFoldedNode</span><span class="result">: <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">Node for recursive definitions given an inductive definition, generating a domain and
invoking the node getting codomain and recursion data
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#inducFuncs" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="inducFuncs:provingground.learning.GeneratorNode.FlatMap[provingground.induction.ExstInducStrucs,provingground.HoTT.ExstFunc]"></a><a id="inducFuncs:FlatMap[ExstInducStrucs,ExstFunc]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#inducFuncs:provingground.learning.GeneratorNode.FlatMap[provingground.induction.ExstInducStrucs,provingground.HoTT.ExstFunc]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">inducFuncs</span><span class="result">: <a href="GeneratorNode$$FlatMap.html" name="provingground.learning.GeneratorNode.FlatMap" id="provingground.learning.GeneratorNode.FlatMap" class="extype">FlatMap</a>[<a href="../induction/ExstInducStrucs.html" name="provingground.induction.ExstInducStrucs" id="provingground.induction.ExstInducStrucs" class="extype">ExstInducStrucs</a>, <a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>]</span></span><p class="shortcomment cmt">aggregated induction functions from inductive types
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#inducFuncsFolded" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="inducFuncsFolded(ind:provingground.induction.ExstInducDefn):provingground.learning.GeneratorNode[provingground.HoTT.Term]"></a><a id="inducFuncsFolded(ExstInducDefn):GeneratorNode[Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#inducFuncsFolded(ind:provingground.induction.ExstInducDefn):provingground.learning.GeneratorNode[provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">inducFuncsFolded</span><span class="params">(<span name="ind">ind: <a href="../induction/ExstInducDefn.html" name="provingground.induction.ExstInducDefn" id="provingground.induction.ExstInducDefn" class="extype">ExstInducDefn</a></span>)</span><span class="result">: <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">Inductive definitions from a given inductive definition by generating a domain and
invoking the node getting codomain and recursion data
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#inducFuncsFoldedGivenDomNode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="inducFuncsFoldedGivenDomNode(ind:provingground.induction.ExstInducDefn,dom:provingground.HoTT.Term):provingground.learning.GeneratorNode[provingground.HoTT.Term]"></a><a id="inducFuncsFoldedGivenDomNode(ExstInducDefn,Term):GeneratorNode[Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#inducFuncsFoldedGivenDomNode(ind:provingground.induction.ExstInducDefn,dom:provingground.HoTT.Term):provingground.learning.GeneratorNode[provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">inducFuncsFoldedGivenDomNode</span><span class="params">(<span name="ind">ind: <a href="../induction/ExstInducDefn.html" name="provingground.induction.ExstInducDefn" id="provingground.induction.ExstInducDefn" class="extype">ExstInducDefn</a></span>, <span name="dom">dom: <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>)</span><span class="result">: <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">Recursive definition given an inductive definition and a domain,
i.e., recursion function with data of the right type folded in.</p><div class="fullcomment"><div class="comment cmt"><p>Recursive definition given an inductive definition and a domain,
i.e., recursion function with data of the right type folded in.
Examples of domains are <code>Nat</code>, <code>Vec(A)</code> and <code>Fin</code>
</p></div></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#inducFuncsForStruc" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="inducFuncsForStruc(ind:provingground.induction.ExstInducStrucs):provingground.learning.GeneratorNode.ZipMapOpt[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term,provingground.HoTT.ExstFunc]"></a><a id="inducFuncsForStruc(ExstInducStrucs):ZipMapOpt[Typ[Term],Term,ExstFunc]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#inducFuncsForStruc(ind:provingground.induction.ExstInducStrucs):provingground.learning.GeneratorNode.ZipMapOpt[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term,provingground.HoTT.ExstFunc]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">inducFuncsForStruc</span><span class="params">(<span name="ind">ind: <a href="../induction/ExstInducStrucs.html" name="provingground.induction.ExstInducStrucs" id="provingground.induction.ExstInducStrucs" class="extype">ExstInducStrucs</a></span>)</span><span class="result">: <a href="GeneratorNode$$ZipMapOpt.html" name="provingground.learning.GeneratorNode.ZipMapOpt" id="provingground.learning.GeneratorNode.ZipMapOpt" class="extype">ZipMapOpt</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>]</span></span><p class="shortcomment cmt">induction function for a specific structure, picking the type family
</p><div class="fullcomment"><div class="comment cmt"><p>induction function for a specific structure, picking the type family
</p></div><dl class="paramcmts block"><dt class="param">ind</dt><dd class="cmt"><p>the inductive structure</p></dd><dt>returns</dt><dd class="cmt"><p>distribution of functions</p></dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#iterFuncIsle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="iterFuncIsle(targetTyp:provingground.HoTT.Typ[provingground.HoTT.Term])(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Typ[provingground.HoTT.Term],InitState,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]"></a><a id="iterFuncIsle(Typ[Term])(Typ[Term]):Island[Typ[Term],InitState,Typ[Term],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#iterFuncIsle(targetTyp:provingground.HoTT.Typ[provingground.HoTT.Term])(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Typ[provingground.HoTT.Term],InitState,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">iterFuncIsle</span><span class="params">(<span name="targetTyp">targetTyp: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="params">(<span name="typ">typ: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$Island.html" name="provingground.learning.GeneratorNode.Island" id="provingground.learning.GeneratorNode.Island" class="extype">Island</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>, <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">extending types of iterated functions targeting <code>W</code> by the type <code>typ</code>
</p><div class="fullcomment"><div class="comment cmt"><p>extending types of iterated functions targeting <code>W</code> by the type <code>typ</code>
</p></div><dl class="paramcmts block"><dt class="param">targetTyp</dt><dd class="cmt"><p>the target type</p></dd><dt class="param">typ</dt><dd class="cmt"><p>the type by which it is extended</p></dd><dt>returns</dt><dd class="cmt"><p>distribution of types</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#iterFuncNode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="iterFuncNode(targetTyp:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="iterFuncNode(Typ[Term]):FlatMap[Typ[Term],Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#iterFuncNode(targetTyp:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">iterFuncNode</span><span class="params">(<span name="targetTyp">targetTyp: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$FlatMap.html" name="provingground.learning.GeneratorNode.FlatMap" id="provingground.learning.GeneratorNode.FlatMap" class="extype">FlatMap</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">aggregating extensions of iterated function types
</p><div class="fullcomment"><div class="comment cmt"><p>aggregating extensions of iterated function types
</p></div><dl class="paramcmts block"><dt class="param">targetTyp</dt><dd class="cmt"><p>target type</p></dd><dt>returns</dt><dd class="cmt"><p>distribution of types</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#iterHeadNode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="iterHeadNode(inductiveTyp:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="iterHeadNode(Typ[Term]):FlatMap[Typ[Term],Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#iterHeadNode(inductiveTyp:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">iterHeadNode</span><span class="params">(<span name="inductiveTyp">inductiveTyp: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$FlatMap.html" name="provingground.learning.GeneratorNode.FlatMap" id="provingground.learning.GeneratorNode.FlatMap" class="extype">FlatMap</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">extension of the introduction rule for an inductive type <code>W</code> by a type of the form eg <code>A -&gt; W</code>
</p><div class="fullcomment"><div class="comment cmt"><p>extension of the introduction rule for an inductive type <code>W</code> by a type of the form eg <code>A -&gt; W</code>
</p></div><dl class="paramcmts block"><dt class="param">inductiveTyp</dt><dd class="cmt"><p>the inductive type <code>W</code></p></dd><dt>returns</dt><dd class="cmt"><p>distribution of types</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#iteratedApply" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="iteratedApply(f:provingground.HoTT.Term):provingground.learning.GeneratorNode[provingground.HoTT.Term]"></a><a id="iteratedApply(Term):GeneratorNode[Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#iteratedApply(f:provingground.HoTT.Term):provingground.learning.GeneratorNode[provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">iteratedApply</span><span class="params">(<span name="f">f: <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>)</span><span class="result">: <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">node to generate partial applications of <code>f</code> from partial applications that are functions.</p><div class="fullcomment"><div class="comment cmt"><p>node to generate partial applications of <code>f</code> from partial applications that are functions.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>function to be applied</p></dd><dt>returns</dt><dd class="cmt"><p>distribution of terms</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#lambdaForFuncWithDomFamily" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="lambdaForFuncWithDomFamily:provingground.learning.GeneratorNodeFamily.BasePi[provingground.HoTT.Typ[provingground.HoTT.Term]::shapeless.HNil,provingground.HoTT.ExstFunc]"></a><a id="lambdaForFuncWithDomFamily:BasePi[::[Typ[Term],HNil],ExstFunc]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#lambdaForFuncWithDomFamily:provingground.learning.GeneratorNodeFamily.BasePi[provingground.HoTT.Typ[provingground.HoTT.Term]::shapeless.HNil,provingground.HoTT.ExstFunc]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">lambdaForFuncWithDomFamily</span><span class="result">: <a href="GeneratorNodeFamily$$BasePi.html" name="provingground.learning.GeneratorNodeFamily.BasePi" id="provingground.learning.GeneratorNodeFamily.BasePi" class="extype">BasePi</a>[<span name="shapeless.::" class="extype">::</span>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="shapeless.HNil" class="extype">HNil</span>], <a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>]</span></span><p class="shortcomment cmt">nodes combining lambdas with given domain that are  (dependent) function types,
aggregated over all domains
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#lambdaIsle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lambdaIsle(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Term,InitState,provingground.HoTT.Term,provingground.HoTT.Term]"></a><a id="lambdaIsle(Typ[Term]):Island[Term,InitState,Term,Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#lambdaIsle(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Term,InitState,provingground.HoTT.Term,provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lambdaIsle</span><span class="params">(<span name="typ">typ: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$Island.html" name="provingground.learning.GeneratorNode.Island" id="provingground.learning.GeneratorNode.Island" class="extype">Island</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">An island to generate lambda terms, i.e., terms are generated withing the island and exported as lambdas;
the initial state of the island has a new variable mixed in.</p><div class="fullcomment"><div class="comment cmt"><p>An island to generate lambda terms, i.e., terms are generated withing the island and exported as lambdas;
the initial state of the island has a new variable mixed in.
</p></div><dl class="paramcmts block"><dt class="param">typ</dt><dd class="cmt"><p>the domain of the lambda</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#lambdaIsleForFuncWithDomain" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lambdaIsleForFuncWithDomain(dom:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.ExstFunc,InitState,provingground.HoTT.Term,provingground.HoTT.Term]"></a><a id="lambdaIsleForFuncWithDomain(Typ[Term]):Island[ExstFunc,InitState,Term,Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#lambdaIsleForFuncWithDomain(dom:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.ExstFunc,InitState,provingground.HoTT.Term,provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lambdaIsleForFuncWithDomain</span><span class="params">(<span name="dom">dom: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$Island.html" name="provingground.learning.GeneratorNode.Island" id="provingground.learning.GeneratorNode.Island" class="extype">Island</a>[<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>, <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">lambda island for generating function with specified domain
</p><div class="fullcomment"><div class="comment cmt"><p>lambda island for generating function with specified domain
</p></div><dl class="paramcmts block"><dt class="param">dom</dt><dd class="cmt"><p>the desired domain</p></dd><dt>returns</dt><dd class="cmt"><p>distribution of functions</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#lambdaNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="lambdaNode:provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]"></a><a id="lambdaNode:FlatMap[Typ[Term],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#lambdaNode:provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">lambdaNode</span><span class="result">: <a href="GeneratorNode$$FlatMap.html" name="provingground.learning.GeneratorNode.FlatMap" id="provingground.learning.GeneratorNode.FlatMap" class="extype">FlatMap</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">node combining lambda islands aggregated by type
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#lambdaTypFamilyIsle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lambdaTypFamilyIsle(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode[provingground.HoTT.ExstFunc]"></a><a id="lambdaTypFamilyIsle(Typ[Term]):GeneratorNode[ExstFunc]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#lambdaTypFamilyIsle(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode[provingground.HoTT.ExstFunc]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lambdaTypFamilyIsle</span><span class="params">(<span name="typ">typ: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>]</span></span><p class="shortcomment cmt">An island to generate lambda terms that are type families, i.e., terms are generated withing the island and exported as lambdas;
the initial state of the island has a new variable mixed in.</p><div class="fullcomment"><div class="comment cmt"><p>An island to generate lambda terms that are type families, i.e., terms are generated withing the island and exported as lambdas;
the initial state of the island has a new variable mixed in.
Within the island types and type families are generated.
</p></div><dl class="paramcmts block"><dt class="param">typ</dt><dd class="cmt"><p>the domain of the lambda</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#lambdaTypFamilyNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="lambdaTypFamilyNode:provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.ExstFunc]"></a><a id="lambdaTypFamilyNode:FlatMap[Typ[Term],ExstFunc]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#lambdaTypFamilyNode:provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.ExstFunc]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">lambdaTypFamilyNode</span><span class="result">: <a href="GeneratorNode$$FlatMap.html" name="provingground.learning.GeneratorNode.FlatMap" id="provingground.learning.GeneratorNode.FlatMap" class="extype">FlatMap</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>]</span></span><p class="shortcomment cmt">node combining lambda islands targeting type families aggregated by type
</p></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="../../scala/index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#nodeForTyp" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="nodeForTyp(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):Option[provingground.learning.GeneratorNode[provingground.HoTT.Term]]"></a><a id="nodeForTyp(Typ[Term]):Option[GeneratorNode[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#nodeForTyp(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):Option[provingground.learning.GeneratorNode[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">nodeForTyp</span><span class="params">(<span name="typ">typ: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">A node  for targeting a (dependent function) type, with variable of the domain generated and the co-domain
type (more generally fibre) targeted within the island.</p><div class="fullcomment"><div class="comment cmt"><p>A node  for targeting a (dependent function) type, with variable of the domain generated and the co-domain
type (more generally fibre) targeted within the island.
</p></div><dl class="paramcmts block"><dt class="param">typ</dt><dd class="cmt"><p>the target type</p></dd><dt>returns</dt><dd class="cmt"><p>optional distribution.</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#otherHeadIsle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="otherHeadIsle(inductiveTyp:provingground.HoTT.Typ[provingground.HoTT.Term])(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Typ[provingground.HoTT.Term],InitState,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]"></a><a id="otherHeadIsle(Typ[Term])(Typ[Term]):Island[Typ[Term],InitState,Typ[Term],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#otherHeadIsle(inductiveTyp:provingground.HoTT.Typ[provingground.HoTT.Term])(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Typ[provingground.HoTT.Term],InitState,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">otherHeadIsle</span><span class="params">(<span name="inductiveTyp">inductiveTyp: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="params">(<span name="typ">typ: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$Island.html" name="provingground.learning.GeneratorNode.Island" id="provingground.learning.GeneratorNode.Island" class="extype">Island</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>, <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">extensions of the introduction rule types for an inductive type <code>W</code> by an unrelated type <code>C</code>;
we may have a Pi-Type with domain <code>C</code> rather than a FuncTyp
there is no assumption on how the head type <code>typ</code> is generated, so this is reusable if only that is changed.</p><div class="fullcomment"><div class="comment cmt"><p>extensions of the introduction rule types for an inductive type <code>W</code> by an unrelated type <code>C</code>;
we may have a Pi-Type with domain <code>C</code> rather than a FuncTyp
there is no assumption on how the head type <code>typ</code> is generated, so this is reusable if only that is changed.
</p></div><dl class="paramcmts block"><dt class="param">inductiveTyp</dt><dd class="cmt"><p>the inductive type <code>W</code></p></dd><dt class="param">typ</dt><dd class="cmt"><p>the type <code>C</code> by which we are extending the introduction rule type</p></dd><dt>returns</dt><dd class="cmt"><p>distribution of introduction rule types</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#otherHeadNode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="otherHeadNode(inductiveTyp:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="otherHeadNode(Typ[Term]):FlatMap[Typ[Term],Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#otherHeadNode(inductiveTyp:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">otherHeadNode</span><span class="params">(<span name="inductiveTyp">inductiveTyp: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$FlatMap.html" name="provingground.learning.GeneratorNode.FlatMap" id="provingground.learning.GeneratorNode.FlatMap" class="extype">FlatMap</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">aggregating extensions of inductive types by unrelated types
</p><div class="fullcomment"><div class="comment cmt"><p>aggregating extensions of inductive types by unrelated types
</p></div><dl class="paramcmts block"><dt class="param">inductiveTyp</dt><dd class="cmt"><p>the inductive type being generated</p></dd><dt>returns</dt><dd class="cmt"><p>distribution of introduction rule types.</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#partiallyApply" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="partiallyApply(f:provingground.HoTT.Term):Option[provingground.learning.GeneratorNode.Map[provingground.HoTT.Term,provingground.HoTT.Term]]"></a><a id="partiallyApply(Term):Option[Map[Term,Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#partiallyApply(f:provingground.HoTT.Term):Option[provingground.learning.GeneratorNode.Map[provingground.HoTT.Term,provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">partiallyApply</span><span class="params">(<span name="f">f: <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<a href="GeneratorNode$$Map.html" name="provingground.learning.GeneratorNode.Map" id="provingground.learning.GeneratorNode.Map" class="extype">Map</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">single function application to generate partial applications of <code>f</code>, if <code>f</code> is a function
</p><div class="fullcomment"><div class="comment cmt"><p>single function application to generate partial applications of <code>f</code>, if <code>f</code> is a function
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to partially apply</p></dd><dt>returns</dt><dd class="cmt"><p>distribution of terms</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#piIsle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="piIsle(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Typ[provingground.HoTT.Term],InitState,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]"></a><a id="piIsle(Typ[Term]):Island[Typ[Term],InitState,Typ[Term],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#piIsle(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Typ[provingground.HoTT.Term],InitState,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">piIsle</span><span class="params">(<span name="typ">typ: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$Island.html" name="provingground.learning.GeneratorNode.Island" id="provingground.learning.GeneratorNode.Island" class="extype">Island</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>, <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">island to generate Pi-Types by taking variables with specified domain, similar to <a href="#lambdaIsle(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Term,InitState,provingground.HoTT.Term,provingground.HoTT.Term]" name="provingground.learning.TermGeneratorNodes#lambdaIsle" id="provingground.learning.TermGeneratorNodes#lambdaIsle" class="extmbr">lambdaIsle</a>
</p><div class="fullcomment"><div class="comment cmt"><p>island to generate Pi-Types by taking variables with specified domain, similar to <a href="#lambdaIsle(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Term,InitState,provingground.HoTT.Term,provingground.HoTT.Term]" name="provingground.learning.TermGeneratorNodes#lambdaIsle" id="provingground.learning.TermGeneratorNodes#lambdaIsle" class="extmbr">lambdaIsle</a>
</p></div><dl class="paramcmts block"><dt class="param">typ</dt><dd class="cmt"><p>the domain for</p></dd><dt>returns</dt><dd class="cmt"><p>distribution of types</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#piNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="piNode:provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="piNode:FlatMap[Typ[Term],Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#piNode:provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">piNode</span><span class="result">: <a href="GeneratorNode$$FlatMap.html" name="provingground.learning.GeneratorNode.FlatMap" id="provingground.learning.GeneratorNode.FlatMap" class="extype">FlatMap</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">aggregate generation of Pi-types from islands
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#recFuncFoldedNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="recFuncFoldedNode:provingground.learning.GeneratorNode[provingground.HoTT.Term]"></a><a id="recFuncFoldedNode:GeneratorNode[Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#recFuncFoldedNode:provingground.learning.GeneratorNode[provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">recFuncFoldedNode</span><span class="result">: <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">Node for recursive definitions picking an inductive definition, generating a domain and
invoking the node getting codomain and recursion data
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#recFuncs" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="recFuncs:provingground.learning.GeneratorNode.FlatMap[provingground.induction.ExstInducStrucs,provingground.HoTT.ExstFunc]"></a><a id="recFuncs:FlatMap[ExstInducStrucs,ExstFunc]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#recFuncs:provingground.learning.GeneratorNode.FlatMap[provingground.induction.ExstInducStrucs,provingground.HoTT.ExstFunc]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">recFuncs</span><span class="result">: <a href="GeneratorNode$$FlatMap.html" name="provingground.learning.GeneratorNode.FlatMap" id="provingground.learning.GeneratorNode.FlatMap" class="extype">FlatMap</a>[<a href="../induction/ExstInducStrucs.html" name="provingground.induction.ExstInducStrucs" id="provingground.induction.ExstInducStrucs" class="extype">ExstInducStrucs</a>, <a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>]</span></span><p class="shortcomment cmt">aggregate recursion functions from inductive types
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#recFuncsFolded" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="recFuncsFolded(ind:provingground.induction.ExstInducDefn):provingground.learning.GeneratorNode[provingground.HoTT.Term]"></a><a id="recFuncsFolded(ExstInducDefn):GeneratorNode[Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#recFuncsFolded(ind:provingground.induction.ExstInducDefn):provingground.learning.GeneratorNode[provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">recFuncsFolded</span><span class="params">(<span name="ind">ind: <a href="../induction/ExstInducDefn.html" name="provingground.induction.ExstInducDefn" id="provingground.induction.ExstInducDefn" class="extype">ExstInducDefn</a></span>)</span><span class="result">: <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">Recursive definitions from a given inductive definition by generating a domain and
invoking the node getting codomain and recursion data
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#recFuncsFoldedGivenDomNode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="recFuncsFoldedGivenDomNode(ind:provingground.induction.ExstInducDefn,dom:provingground.HoTT.Term):provingground.learning.GeneratorNode[provingground.HoTT.Term]"></a><a id="recFuncsFoldedGivenDomNode(ExstInducDefn,Term):GeneratorNode[Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#recFuncsFoldedGivenDomNode(ind:provingground.induction.ExstInducDefn,dom:provingground.HoTT.Term):provingground.learning.GeneratorNode[provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">recFuncsFoldedGivenDomNode</span><span class="params">(<span name="ind">ind: <a href="../induction/ExstInducDefn.html" name="provingground.induction.ExstInducDefn" id="provingground.induction.ExstInducDefn" class="extype">ExstInducDefn</a></span>, <span name="dom">dom: <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>)</span><span class="result">: <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">Recursive definition given an inductive definition and a domain,
i.e., recursion function with data of the right type folded in.</p><div class="fullcomment"><div class="comment cmt"><p>Recursive definition given an inductive definition and a domain,
i.e., recursion function with data of the right type folded in.
Examples of domains are <code>Nat</code>, <code>Vec(A)</code> and <code>Fin</code>
</p></div></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#selfHeadNode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="selfHeadNode(inductiveTyp:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Typ[provingground.HoTT.Term],InitState,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]"></a><a id="selfHeadNode(Typ[Term]):Island[Typ[Term],InitState,Typ[Term],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#selfHeadNode(inductiveTyp:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Typ[provingground.HoTT.Term],InitState,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">selfHeadNode</span><span class="params">(<span name="inductiveTyp">inductiveTyp: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$Island.html" name="provingground.learning.GeneratorNode.Island" id="provingground.learning.GeneratorNode.Island" class="extype">Island</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>, <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">extend an introduction rule type for an inductive type <code>W</code> by <code>W -&gt; ...</code>
</p><div class="fullcomment"><div class="comment cmt"><p>extend an introduction rule type for an inductive type <code>W</code> by <code>W -&gt; ...</code>
</p></div><dl class="paramcmts block"><dt class="param">inductiveTyp</dt><dd class="cmt"><p>the inductive type being defined</p></dd><dt>returns</dt><dd class="cmt"><p>distribution of types for introduction rules</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#sigmaIsle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sigmaIsle(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Typ[provingground.HoTT.Term],InitState,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]"></a><a id="sigmaIsle(Typ[Term]):Island[Typ[Term],InitState,Typ[Term],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#sigmaIsle(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Typ[provingground.HoTT.Term],InitState,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sigmaIsle</span><span class="params">(<span name="typ">typ: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$Island.html" name="provingground.learning.GeneratorNode.Island" id="provingground.learning.GeneratorNode.Island" class="extype">Island</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>, <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">island to generate Sigma-Types by taking variables with specified domain, similar to <a href="#lambdaIsle(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Term,InitState,provingground.HoTT.Term,provingground.HoTT.Term]" name="provingground.learning.TermGeneratorNodes#lambdaIsle" id="provingground.learning.TermGeneratorNodes#lambdaIsle" class="extmbr">lambdaIsle</a>
</p><div class="fullcomment"><div class="comment cmt"><p>island to generate Sigma-Types by taking variables with specified domain, similar to <a href="#lambdaIsle(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Island[provingground.HoTT.Term,InitState,provingground.HoTT.Term,provingground.HoTT.Term]" name="provingground.learning.TermGeneratorNodes#lambdaIsle" id="provingground.learning.TermGeneratorNodes#lambdaIsle" class="extmbr">lambdaIsle</a>
</p></div><dl class="paramcmts block"><dt class="param">typ</dt><dd class="cmt"><p>the domain for</p></dd><dt>returns</dt><dd class="cmt"><p>distribution of types</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#sigmaNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="sigmaNode:provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="sigmaNode:FlatMap[Typ[Term],Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#sigmaNode:provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">sigmaNode</span><span class="result">: <a href="GeneratorNode$$FlatMap.html" name="provingground.learning.GeneratorNode.FlatMap" id="provingground.learning.GeneratorNode.FlatMap" class="extype">FlatMap</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">aggregate generation of Sigma-types from islands
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#simpleInductiveDefn" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="simpleInductiveDefn(inductiveTyp:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Map[Vector[provingground.HoTT.Typ[provingground.HoTT.Term]],provingground.induction.ExstInducDefn]"></a><a id="simpleInductiveDefn(Typ[Term]):Map[Vector[Typ[Term]],ExstInducDefn]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#simpleInductiveDefn(inductiveTyp:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Map[Vector[provingground.HoTT.Typ[provingground.HoTT.Term]],provingground.induction.ExstInducDefn]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">simpleInductiveDefn</span><span class="params">(<span name="inductiveTyp">inductiveTyp: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$Map.html" name="provingground.learning.GeneratorNode.Map" id="provingground.learning.GeneratorNode.Map" class="extype">Map</a>[<a href="../../scala/index.html#Vector[+A]=scala.collection.immutable.Vector[A]" name="scala.Vector" id="scala.Vector" class="extmbr">Vector</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]], <a href="../induction/ExstInducDefn.html" name="provingground.induction.ExstInducDefn" id="provingground.induction.ExstInducDefn" class="extype">ExstInducDefn</a>]</span></span><p class="shortcomment cmt">builds an inductive definition, i.e.</p><div class="fullcomment"><div class="comment cmt"><p>builds an inductive definition, i.e. structure with type, from a bunch of introduction rules for a type <code>inductiveTyp</code>,
we must separately specify how to build an introduction rules, as well as a vector of these.
</p></div><dl class="paramcmts block"><dt class="param">inductiveTyp</dt><dd class="cmt"><p>the inductve type being defined</p></dd><dt>returns</dt><dd class="cmt"><p>distribution on existential inductive structures</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#simpleInductiveStructure" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="simpleInductiveStructure(inductiveTyp:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Map[Vector[provingground.HoTT.Typ[provingground.HoTT.Term]],provingground.induction.ExstInducStrucs]"></a><a id="simpleInductiveStructure(Typ[Term]):Map[Vector[Typ[Term]],ExstInducStrucs]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#simpleInductiveStructure(inductiveTyp:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.Map[Vector[provingground.HoTT.Typ[provingground.HoTT.Term]],provingground.induction.ExstInducStrucs]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">simpleInductiveStructure</span><span class="params">(<span name="inductiveTyp">inductiveTyp: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$Map.html" name="provingground.learning.GeneratorNode.Map" id="provingground.learning.GeneratorNode.Map" class="extype">Map</a>[<a href="../../scala/index.html#Vector[+A]=scala.collection.immutable.Vector[A]" name="scala.Vector" id="scala.Vector" class="extmbr">Vector</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]], <a href="../induction/ExstInducStrucs.html" name="provingground.induction.ExstInducStrucs" id="provingground.induction.ExstInducStrucs" class="extype">ExstInducStrucs</a>]</span></span><p class="shortcomment cmt">builds an inductive structure from a bunch of introduction rules for a type <code>inductiveTyp</code>,
we must separately specify how to build an introduction rules, as well as a vector of these.</p><div class="fullcomment"><div class="comment cmt"><p>builds an inductive structure from a bunch of introduction rules for a type <code>inductiveTyp</code>,
we must separately specify how to build an introduction rules, as well as a vector of these.
</p></div><dl class="paramcmts block"><dt class="param">inductiveTyp</dt><dd class="cmt"><p>the inductve type being defined</p></dd><dt>returns</dt><dd class="cmt"><p>distribution on existential inductive structures</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](=&gt;T0):T0"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#targetInducBackNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="targetInducBackNode(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.MapOpt[provingground.induction.ExstInducDefn,provingground.HoTT.Term]"></a><a id="targetInducBackNode(Typ[Term]):MapOpt[ExstInducDefn,Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#targetInducBackNode(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.MapOpt[provingground.induction.ExstInducDefn,provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">targetInducBackNode</span><span class="params">(<span name="typ">typ: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$MapOpt.html" name="provingground.learning.GeneratorNode.MapOpt" id="provingground.learning.GeneratorNode.MapOpt" class="extype">MapOpt</a>[<a href="../induction/ExstInducDefn.html" name="provingground.induction.ExstInducDefn" id="provingground.induction.ExstInducDefn" class="extype">ExstInducDefn</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">Node for recursive definitions targeting a specific type
picking an inductive definition, generating a domain and
invoking the node getting codomain; but not the recursion data here
meant to be used for backward reasoning.</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#targetInducFuncsFolded" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="targetInducFuncsFolded(ind:provingground.induction.ExstInducDefn,target:provingground.HoTT.Typ[provingground.HoTT.Term]):Option[provingground.learning.GeneratorNode[provingground.HoTT.Term]]"></a><a id="targetInducFuncsFolded(ExstInducDefn,Typ[Term]):Option[GeneratorNode[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#targetInducFuncsFolded(ind:provingground.induction.ExstInducDefn,target:provingground.HoTT.Typ[provingground.HoTT.Term]):Option[provingground.learning.GeneratorNode[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">targetInducFuncsFolded</span><span class="params">(<span name="ind">ind: <a href="../induction/ExstInducDefn.html" name="provingground.induction.ExstInducDefn" id="provingground.induction.ExstInducDefn" class="extype">ExstInducDefn</a></span>, <span name="target">target: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">Node for recursive definitions targeting a specific type
picking an inductive definition, generating a domain and
invoking the node getting codomain and recursion data
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#targetInducNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="targetInducNode(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.FlatMapOpt[provingground.induction.ExstInducDefn,provingground.HoTT.Term]"></a><a id="targetInducNode(Typ[Term]):FlatMapOpt[ExstInducDefn,Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#targetInducNode(typ:provingground.HoTT.Typ[provingground.HoTT.Term]):provingground.learning.GeneratorNode.FlatMapOpt[provingground.induction.ExstInducDefn,provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">targetInducNode</span><span class="params">(<span name="typ">typ: <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span>)</span><span class="result">: <a href="GeneratorNode$$FlatMapOpt.html" name="provingground.learning.GeneratorNode.FlatMapOpt" id="provingground.learning.GeneratorNode.FlatMapOpt" class="extype">FlatMapOpt</a>[<a href="../induction/ExstInducDefn.html" name="provingground.induction.ExstInducDefn" id="provingground.induction.ExstInducDefn" class="extype">ExstInducDefn</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">Node for recursive definitions targeting a specific type
picking an inductive definition, generating a domain and
invoking the node getting codomain; but not the recursion data here
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#targetInducNodeFamily" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="targetInducNodeFamily:provingground.learning.GeneratorNodeFamily.BasePi[provingground.HoTT.Typ[provingground.HoTT.Term]::shapeless.HNil,provingground.HoTT.Term]"></a><a id="targetInducNodeFamily:BasePi[::[Typ[Term],HNil],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#targetInducNodeFamily:provingground.learning.GeneratorNodeFamily.BasePi[provingground.HoTT.Typ[provingground.HoTT.Term]::shapeless.HNil,provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">targetInducNodeFamily</span><span class="result">: <a href="GeneratorNodeFamily$$BasePi.html" name="provingground.learning.GeneratorNodeFamily.BasePi" id="provingground.learning.GeneratorNodeFamily.BasePi" class="extype">BasePi</a>[<span name="shapeless.::" class="extype">::</span>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="shapeless.HNil" class="extype">HNil</span>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt"> Family of nodes for recursive definitions targeting a specific type
picking an inductive definition, generating a domain and
invoking the node getting codomain; but not the recursion data here
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#termsByTyps" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="termsByTyps:provingground.learning.GeneratorNode.ZipFlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term,provingground.HoTT.Term]"></a><a id="termsByTyps:ZipFlatMap[Typ[Term],Term,Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#termsByTyps:provingground.learning.GeneratorNode.ZipFlatMap[provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term,provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">termsByTyps</span><span class="result">: <a href="GeneratorNode$$ZipFlatMap.html" name="provingground.learning.GeneratorNode.ZipFlatMap" id="provingground.learning.GeneratorNode.ZipFlatMap" class="extype">ZipFlatMap</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">terms generated by first choosing type and then term with the type;
a form of backward reasoning
</p></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#typApplnBase" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="typApplnBase:provingground.learning.GeneratorNode.FiberProductMap[provingground.HoTT.ExstFunc,provingground.HoTT.Term,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]"></a><a id="typApplnBase:FiberProductMap[ExstFunc,Term,Typ[Term],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#typApplnBase:provingground.learning.GeneratorNode.FiberProductMap[provingground.HoTT.ExstFunc,provingground.HoTT.Term,provingground.HoTT.Typ[provingground.HoTT.Term],provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">typApplnBase</span><span class="result">: <a href="GeneratorNode$$FiberProductMap.html" name="provingground.learning.GeneratorNode.FiberProductMap" id="provingground.learning.GeneratorNode.FiberProductMap" class="extype">FiberProductMap</a>[<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">function application to get terms by choosing a type family and then a term in its domain, but without conditioning
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#typApplnNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="typApplnNode:provingground.learning.GeneratorNode[provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="typApplnNode:GeneratorNode[Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#typApplnNode:provingground.learning.GeneratorNode[provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">typApplnNode</span><span class="result">: <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">function application to get types by choosing a type family and then a term in its domain, but without conditioning
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#typAsCodNodeFamily" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="typAsCodNodeFamily:provingground.learning.GeneratorNodeFamily.BasePi[provingground.HoTT.Typ[provingground.HoTT.Term]::shapeless.HNil,provingground.HoTT.Term]"></a><a id="typAsCodNodeFamily:BasePi[::[Typ[Term],HNil],Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#typAsCodNodeFamily:provingground.learning.GeneratorNodeFamily.BasePi[provingground.HoTT.Typ[provingground.HoTT.Term]::shapeless.HNil,provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">typAsCodNodeFamily</span><span class="result">: <a href="GeneratorNodeFamily$$BasePi.html" name="provingground.learning.GeneratorNodeFamily.BasePi" id="provingground.learning.GeneratorNodeFamily.BasePi" class="extype">BasePi</a>[<span name="shapeless.::" class="extype">::</span>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="shapeless.HNil" class="extype">HNil</span>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">Node for generating terms of a type (if possible) by multiple applications of functions targeting the type.</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#typFamilyApplnNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="typFamilyApplnNode:provingground.learning.GeneratorNode[provingground.HoTT.ExstFunc]"></a><a id="typFamilyApplnNode:GeneratorNode[ExstFunc]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#typFamilyApplnNode:provingground.learning.GeneratorNode[provingground.HoTT.ExstFunc]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">typFamilyApplnNode</span><span class="result">: <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>]</span></span><p class="shortcomment cmt">function application to get type families by choosing a type family and then a term in its domain, but without conditioning
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#typFamilyUnifApplnNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="typFamilyUnifApplnNode:provingground.learning.GeneratorNode[provingground.HoTT.ExstFunc]"></a><a id="typFamilyUnifApplnNode:GeneratorNode[ExstFunc]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#typFamilyUnifApplnNode:provingground.learning.GeneratorNode[provingground.HoTT.ExstFunc]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">typFamilyUnifApplnNode</span><span class="result">: <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>]</span></span><p class="shortcomment cmt">function application with unification starting with type families, with output conditioned to be a type family.</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#typFoldNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="typFoldNode:provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.ExstFunc,provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="typFoldNode:FlatMap[ExstFunc,Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#typFoldNode:provingground.learning.GeneratorNode.FlatMap[provingground.HoTT.ExstFunc,provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">typFoldNode</span><span class="result">: <a href="GeneratorNode$$FlatMap.html" name="provingground.learning.GeneratorNode.FlatMap" id="provingground.learning.GeneratorNode.FlatMap" class="extype">FlatMap</a>[<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>, <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">Node family for fully folding type families to get types
</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#typFromFamily" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="typFromFamily(typF:provingground.HoTT.Term):provingground.learning.GeneratorNode.MapOpt[provingground.HoTT.Term,provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="typFromFamily(Term):MapOpt[Term,Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#typFromFamily(typF:provingground.HoTT.Term):provingground.learning.GeneratorNode.MapOpt[provingground.HoTT.Term,provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">typFromFamily</span><span class="params">(<span name="typF">typF: <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a></span>)</span><span class="result">: <a href="GeneratorNode$$MapOpt.html" name="provingground.learning.GeneratorNode.MapOpt" id="provingground.learning.GeneratorNode.MapOpt" class="extype">MapOpt</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">types from a type family by filtering partial applications to consider only types.</p><div class="fullcomment"><div class="comment cmt"><p>types from a type family by filtering partial applications to consider only types.
</p></div><dl class="paramcmts block"><dt class="param">typF</dt><dd class="cmt"><p>the type family</p></dd><dt>returns</dt><dd class="cmt"><p>distribution of types.</p></dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#typUnifApplnBase" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="typUnifApplnBase:provingground.learning.GeneratorNode.ZipMapOpt[provingground.HoTT.ExstFunc,provingground.HoTT.Term,provingground.HoTT.Term]"></a><a id="typUnifApplnBase:ZipMapOpt[ExstFunc,Term,Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#typUnifApplnBase:provingground.learning.GeneratorNode.ZipMapOpt[provingground.HoTT.ExstFunc,provingground.HoTT.Term,provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">typUnifApplnBase</span><span class="result">: <a href="GeneratorNode$$ZipMapOpt.html" name="provingground.learning.GeneratorNode.ZipMapOpt" id="provingground.learning.GeneratorNode.ZipMapOpt" class="extype">ZipMapOpt</a>[<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">function application with unification starting with type families, but with output not conditioned.</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#typUnifApplnNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="typUnifApplnNode:provingground.learning.GeneratorNode[provingground.HoTT.Typ[provingground.HoTT.Term]]"></a><a id="typUnifApplnNode:GeneratorNode[Typ[Term]]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#typUnifApplnNode:provingground.learning.GeneratorNode[provingground.HoTT.Typ[provingground.HoTT.Term]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">typUnifApplnNode</span><span class="result">: <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]]</span></span><p class="shortcomment cmt">function application with unification starting with type families, with output conditioned to be a type.</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes#unifApplnNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="unifApplnNode:provingground.learning.GeneratorNode.ZipMapOpt[provingground.HoTT.ExstFunc,provingground.HoTT.Term,provingground.HoTT.Term]"></a><a id="unifApplnNode:ZipMapOpt[ExstFunc,Term,Term]"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#unifApplnNode:provingground.learning.GeneratorNode.ZipMapOpt[provingground.HoTT.ExstFunc,provingground.HoTT.Term,provingground.HoTT.Term]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">unifApplnNode</span><span class="result">: <a href="GeneratorNode$$ZipMapOpt.html" name="provingground.learning.GeneratorNode.ZipMapOpt" id="provingground.learning.GeneratorNode.ZipMapOpt" class="extype">ZipMapOpt</a>[<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]</span></span><p class="shortcomment cmt">function application with unification node to get terms
</p></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.Appln" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="Appln"></a><a id="Appln:Appln"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$Appln$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$Appln$.html" title="Wrapper for application to allow equality and  toString to work."><span class="name">Appln</span></a><span class="result"> extends (<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>) =&gt; <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a> with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span><p class="shortcomment cmt">Wrapper for application to allow equality and  <code>toString</code> to work.</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.CurryForTyp" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="CurryForTyp"></a><a id="CurryForTyp:CurryForTyp"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$CurryForTyp$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$CurryForTyp$.html" title=""><span class="name">CurryForTyp</span></a><span class="result"> extends (<span name="shapeless.::" class="extype">::</span>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="shapeless.HNil" class="extype">HNil</span>]) =&gt; <span name="scala.Option" class="extype">Option</span>[<a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.FlipAppln" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="FlipAppln"></a><a id="FlipAppln:FlipAppln"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$FlipAppln$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$FlipAppln$.html" title="Wrapper for flipped application to allow equality and  toString to work."><span class="name">FlipAppln</span></a><span class="result"> extends (<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>) =&gt; <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a> with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span><p class="shortcomment cmt">Wrapper for flipped application to allow equality and  <code>toString</code> to work.</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.FoldTypFamily" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="FoldTypFamily"></a><a id="FoldTypFamily:FoldTypFamily"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$FoldTypFamily$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$FoldTypFamily$.html" title=""><span class="name">FoldTypFamily</span></a><span class="result"> extends (<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>) =&gt; <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.FoldedTargetFunctionNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="FoldedTargetFunctionNode"></a><a id="FoldedTargetFunctionNode:FoldedTargetFunctionNode"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$FoldedTargetFunctionNode$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$FoldedTargetFunctionNode$.html" title=""><span class="name">FoldedTargetFunctionNode</span></a><span class="result"> extends (<span name="shapeless.::" class="extype">::</span>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="shapeless.HNil" class="extype">HNil</span>]) =&gt; <a href="GeneratorNode$$FlatMapOpt.html" name="provingground.learning.GeneratorNode.FlatMapOpt" id="provingground.learning.GeneratorNode.FlatMapOpt" class="extype">FlatMapOpt</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.InducFuncsFolded" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="InducFuncsFolded"></a><a id="InducFuncsFolded:InducFuncsFolded"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$InducFuncsFolded$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$InducFuncsFolded$.html" title=""><span class="name">InducFuncsFolded</span></a><span class="result"> extends (<a href="../induction/ExstInducDefn.html" name="provingground.induction.ExstInducDefn" id="provingground.induction.ExstInducDefn" class="extype">ExstInducDefn</a>) =&gt; <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.LambdaIsle" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="LambdaIsle"></a><a id="LambdaIsle:LambdaIsle"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$LambdaIsle$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$LambdaIsle$.html" title="Wrapper for lambda island to allow equality and  toString to work."><span class="name">LambdaIsle</span></a><span class="result"> extends (<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]) =&gt; <a href="GeneratorNode$$Island.html" name="provingground.learning.GeneratorNode.Island" id="provingground.learning.GeneratorNode.Island" class="extype">Island</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span><p class="shortcomment cmt">Wrapper for lambda island to allow equality and  <code>toString</code> to work.</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.LambdaIsleForFuncWithDomain" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="LambdaIsleForFuncWithDomain"></a><a id="LambdaIsleForFuncWithDomain:LambdaIsleForFuncWithDomain"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$LambdaIsleForFuncWithDomain$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$LambdaIsleForFuncWithDomain$.html" title=""><span class="name">LambdaIsleForFuncWithDomain</span></a><span class="result"> extends (<span name="shapeless.::" class="extype">::</span>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="shapeless.HNil" class="extype">HNil</span>]) =&gt; <a href="GeneratorNode$$Island.html" name="provingground.learning.GeneratorNode.Island" id="provingground.learning.GeneratorNode.Island" class="extype">Island</a>[<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>, <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.LambdaTypFamilyIsle" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="LambdaTypFamilyIsle"></a><a id="LambdaTypFamilyIsle:LambdaTypFamilyIsle"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$LambdaTypFamilyIsle$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$LambdaTypFamilyIsle$.html" title="Wrapper for lambda island tageting type families to allow equality and  toString to work."><span class="name">LambdaTypFamilyIsle</span></a><span class="result"> extends (<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]) =&gt; <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span><p class="shortcomment cmt">Wrapper for lambda island tageting type families to allow equality and  <code>toString</code> to work.</p></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.NodeForTyp" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="NodeForTyp"></a><a id="NodeForTyp:NodeForTyp"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$NodeForTyp$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$NodeForTyp$.html" title=""><span class="name">NodeForTyp</span></a><span class="result"> extends (<span name="shapeless.::" class="extype">::</span>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="shapeless.HNil" class="extype">HNil</span>]) =&gt; <span name="scala.Option" class="extype">Option</span>[<a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.PiIsle" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="PiIsle"></a><a id="PiIsle:PiIsle"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$PiIsle$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$PiIsle$.html" title=""><span class="name">PiIsle</span></a><span class="result"> extends (<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]) =&gt; <a href="GeneratorNode$$Island.html" name="provingground.learning.GeneratorNode.Island" id="provingground.learning.GeneratorNode.Island" class="extype">Island</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>, <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.RecFuncsFolded" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="RecFuncsFolded"></a><a id="RecFuncsFolded:RecFuncsFolded"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$RecFuncsFolded$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$RecFuncsFolded$.html" title=""><span class="name">RecFuncsFolded</span></a><span class="result"> extends (<a href="../induction/ExstInducDefn.html" name="provingground.induction.ExstInducDefn" id="provingground.induction.ExstInducDefn" class="extype">ExstInducDefn</a>) =&gt; <a href="GeneratorNode.html" name="provingground.learning.GeneratorNode" id="provingground.learning.GeneratorNode" class="extype">GeneratorNode</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.SigmaIsle" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="SigmaIsle"></a><a id="SigmaIsle:SigmaIsle"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$SigmaIsle$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$SigmaIsle$.html" title=""><span class="name">SigmaIsle</span></a><span class="result"> extends (<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>]) =&gt; <a href="GeneratorNode$$Island.html" name="provingground.learning.GeneratorNode.Island" id="provingground.learning.GeneratorNode.Island" class="extype">Island</a>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>, <a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.TargetInducNode" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="TargetInducNode"></a><a id="TargetInducNode:TargetInducNode"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$TargetInducNode$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$TargetInducNode$.html" title=""><span class="name">TargetInducNode</span></a><span class="result"> extends (<span name="shapeless.::" class="extype">::</span>[<a href="../HoTT$$Typ.html" name="provingground.HoTT.Typ" id="provingground.HoTT.Typ" class="extype">Typ</a>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>], <span name="shapeless.HNil" class="extype">HNil</span>]) =&gt; <a href="GeneratorNode$$FlatMapOpt.html" name="provingground.learning.GeneratorNode.FlatMapOpt" id="provingground.learning.GeneratorNode.FlatMapOpt" class="extype">FlatMapOpt</a>[<a href="../induction/ExstInducDefn.html" name="provingground.induction.ExstInducDefn" id="provingground.induction.ExstInducDefn" class="extype">ExstInducDefn</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span></li><li class="indented0 " name="provingground.learning.TermGeneratorNodes.UnifApplnOpt" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="UnifApplnOpt"></a><a id="UnifApplnOpt:UnifApplnOpt"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes$UnifApplnOpt$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="TermGeneratorNodes$UnifApplnOpt$.html" title="Wrapper for unified application to allow equality and  toString to work."><span class="name">UnifApplnOpt</span></a><span class="result"> extends (<a href="../HoTT$$ExstFunc.html" name="provingground.HoTT.ExstFunc" id="provingground.HoTT.ExstFunc" class="extype">ExstFunc</a>, <a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>) =&gt; <span name="scala.Option" class="extype">Option</span>[<a href="../HoTT$$Term.html" name="provingground.HoTT.Term" id="provingground.HoTT.Term" class="extype">Term</a>] with <span name="scala.Product" class="extype">Product</span> with <a href="../../scala/index.html#Serializable=java.io.Serializable" name="scala.Serializable" id="scala.Serializable" class="extmbr">Serializable</a></span></span><p class="shortcomment cmt">Wrapper for unified application to allow equality and  <code>toString</code> to work.</p></li></ol></div><div class="values members"><h3>Deprecated Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: ">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> <span class="name">@Deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"></dd></dl></div></li><li class="indented0 " name="scala.Predef.ArrowAssoc#→" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="→[B](y:B):(A,B)"></a><a id="→[B](B):(TermGeneratorNodes[InitState],B)"></a> <span class="permalink"><a href="../../provingground/learning/TermGeneratorNodes.html#→[B](y:B):(A,B)" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit deprecated" title="gt4s: $u2192. Deprecated: (Since version 2.13.0) Use -&gt; instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.">→</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span name="scala.Predef.ArrowAssoc.→.B" class="extype">B</span></span>)</span><span class="result">: (<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>], <span name="scala.Predef.ArrowAssoc.→.B" class="extype">B</span>)</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>] to<span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]] performed by method ArrowAssoc in scala.Predef.</dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.13.0)</i> Use <code>-&gt;</code> instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.</p></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <a href="../../scala/index.html#AnyRef=Object" name="scala.AnyRef" id="scala.AnyRef" class="extmbr">AnyRef</a></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div><div name="scala.Predef.any2stringadd" class="conversion"><h3>Inherited by implicit conversion any2stringadd from<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>] to <span name="scala.Predef.any2stringadd" class="extype">any2stringadd</span>[<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]]</h3></div><div name="scala.Predef.StringFormat" class="conversion"><h3>Inherited by implicit conversion StringFormat from<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>] to <span name="scala.Predef.StringFormat" class="extype">StringFormat</span>[<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]]</h3></div><div name="scala.Predef.Ensuring" class="conversion"><h3>Inherited by implicit conversion Ensuring from<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>] to <span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]]</h3></div><div name="scala.Predef.ArrowAssoc" class="conversion"><h3>Inherited by implicit conversion ArrowAssoc from<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>] to <span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="provingground.learning.TermGeneratorNodes" id="provingground.learning.TermGeneratorNodes" class="extype">TermGeneratorNodes</a>[<span name="provingground.learning.TermGeneratorNodes.InitState" class="extype">InitState</span>]]</h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
